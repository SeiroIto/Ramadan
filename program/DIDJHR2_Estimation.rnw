\section{Estimation}

\subsection{Main and placebo estimation}

results
[[ii]][[jj]][[j]][[ge]][[m]][[s]][[k]]\\
ii: main, placebo\\
jj: zE, zS samples\\
j: only nuclear (sd == 1) or include extended (sd == 0)\\
ge: boys, girls, boys+girls\\
m: agHH def\\
s: age cutoff\\
k: specification

Estimation steps:
\begin{enumerate}
\vspace{1.0ex}\setlength{\itemsep}{1.0ex}\setlength{\baselineskip}{12pt}
\item	Use \textsf{fdrobust} to try all specifications and pick the data matrix that has the smallest number of observations. This data is the estimation data to be used for the all specifications so we get the same number of observations for all specifications. We retrieve the first-differenced estimation data.
	\begin{dinglist}{45}
	\vspace{1.0ex}\setlength{\itemsep}{1.0ex}\setlength{\baselineskip}{12pt}
	\item	A programming note. If taking a first-difference in the conventional way, \textsf{diff} function takes $t-(t-1)$ differences. We want $(t-1)-t$ differences to see how enrollment rates change as time passes.
	\item	If we set \textsf{opposite.time.order==F}, then \textsf{diff} function gives $t-(t-1)$ differences. If a child drops out, then \textsf{LHS} changes from 1 to 0, and a $t-(t-1)$ difference gives $-1$. If the child is from an agricultural household, then \textsf{agHH.yr2} (agHH==1 \& 1999==1) changes from 1 to 0, so the $t-(t-1)$ difference gives $-1$. OLS of $\Delta$\textsf{LHS} on $\Delta$\textsf{agHH.yr2} gives a positive estimate under the maintained hypothesis ``agricultural households experienced a larger drop in enrollment rates.'' 
	\item	To retrieve a negative estimate under the maintained hypothesis, we set \textsf{opposite.time.order==F} in \textsf{fdrobust} to get $t-(t-1)$ differenced data. On the differenced data we define \textsf{agHH.yr2} as positive, by multiplying \textsf{agHH.yr2} with -1. The same negative multiplication is applied to all other time-varying covariates.
		\begin{itemize}
		\vspace{1.0ex}\setlength{\itemsep}{1.0ex}\setlength{\baselineskip}{12pt}
		\item	A positive \textsf{agHH.yr2} is effectively an agHH * year 2 (2002) dummy. This turns out to be a lexicographically correct definition.
		\end{itemize}
	\end{dinglist}
\item	Use \textsf{FDestimation} with the first-differenced estimation data. 
\end{enumerate}

\subsubsection{Main and placebo}

Small number of clusters correction for CRSE: BRL \citep{PustejovskyTipton2018} and WCB \citep{CameronGelbachMiller2008}. There are warnings on small number of unique draws in WCB when WCB weight is drawn from a Rademacher distribution. We use Webb weights as suggested by the \textsf{boottest} message. 
% sandwich has a function: vcovBS(reg1, cluster = ~ thana, type = "wild-webb"). Not tested. Can take long.
% Covariates OldSibF, OldSibM, OldSchSibF, OldSchSibM reduces sample size of agHHs. This causes wildbootstrap to give an error for zSm.1999 Aghhdef = occ, older 10, k>=5, zEp.2002, zSp.1999 fwildclusterboot odler 10. zSp.2002. This is because UDOldSibF = 0 for all obs, UDOldSibM = 0 for all but 2 obs. 
<<main and placebo gender BRL WCB, eval = F, results = 'hide', cache = F>>=
# Estimation by main/placebo * aghh.defs * age lb * gender * demeaned/level interaction * HHtype
# with LiangZeger or Satterthwaite CRSEs.
# source(paste0(pathprogram, "PartialFile.R"))
library(clubSandwich)
clusterlevel <- "thana"
DivInto2Tables <- T
source(paste0(pathprogram0, "TabGeneric.R"))
regressors.list <- list(
  main = regressorsM,
  placebo = regressorsM2002
)
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds")) 
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
# non ag HHs have no siblings in agriculture...this is how we defined ag HHs.
zEm.1999[survey==1999 & age>=10 & age<=18, 
  .(AgSibM=mean(UDOldAgSibM, na.rm= T), SibM=mean(UDOldSibM)), by = agHH0]
zSm.1999 <- readRDS(paste0(pathsaveThisVer, "zSm1999.rds")) 
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds")) 
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds")) 
zSp.1999 <- readRDS(paste0(pathsaveThisVer, "zSp1999.rds")) 
zSp.2002 <- readRDS(paste0(pathsaveThisVer, "zSp2002.rds")) 
zYp.1999 <- readRDS(paste0(pathsaveThisVer, "zYp1999.rds")) 
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
zSp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
samples <- c("main", "placebo")
z234 <- c("z2", "z3", "z4")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")[1]
# jj: 1,2 = 10-18 in 2002, 3,4 = 10-18 in 1999, 5 = 6-9 in 1999
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999", "zYp.1999")[c(1, 3)]
cohort.years.list <- list(# year age is defined
  main = 1999,  # main: use 1999 age to set age range
  placebo = c(2002, 1999)
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
# Used in "interaction with year InterYears" in results table
InterYearsList <- list(main = rep(2002, 2), placebo = rep(2006, 2))
variables.always.use <- "schoolp|Enrolled|^agHH.yr2|^agHH$|^thana$|uniqu|^UDnon|^UDfl|^UD.*Sib|^UDhds|^pcland$|^pcnlasset$"
yrXs <- c("yr2", "yr3")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
)
boxWidth <- 4
centerWidth <- 1.3
Enr.Base <- Enrchg.Base <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
names(results) <- names(resultsN) <- samples
ii <- jj <- j <- m <- s <- 1
ii <- 2; jj <- 2
SkipLowerBound <- 40
for (ii in 1:length(samples)) {
#for (ii in 2) {
  zSobj <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  yrX <- yrXs[ii]
  var.always.use <- gsub("yr2", yrX, variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("schoolp", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  # res[[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  names(results0) <- names(resultsN0) <- zSobj
  for (jj in 1:length(zSobj)) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
      z1 = copy(z01)
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      for (s in 1:3)
      #  choice of age cutoff
      {
        s0 <- (10:12)[s]
        i <- paste0("older", s0)
        # latter panel: s <= age < maxAge in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= maxAge 
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        z4 <- z2[sd != 1, ]
        z4 <- dropunbalanced(z4, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
        for (j in 1:2) {
          zz00 <- get(z234[j])
          setkey(zz00, uniquid, survey)
          zz00[, survey := NULL]
          for (ge in 1:3)
          {
            if (ge == 1) {
              zz0 = copy(zz00[sex <= 0, ]) 
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else  if (ge == 2){
              zz0 = copy(zz00[sex > 0, ])
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else zz0 = copy(zz00)
            if (nrow(zz0) < SkipLowerBound) {
              cat("Skipped due to small number of obs:", nrow(zz0), "\n")
              next
            }
            for (m in 1:length(aghh.defs))
            {
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              ns <- NULL
              resul <- est <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                # pick covariates for k-th regression: 
                #  paste " ..|.." & "..|.." with collapse = "|" then use it in grepout
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                #if (grepl("zEp.2|zSp", zSobj[jj]))
                # zEp.2002: UDOldSibF is all 0, UDOldSibM is all 0 but 2 obs, so drop them (and interactions).
                #  covariates <- covariates[!grepl("OldSib", covariates)]
                covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)] # drop real valued level variables
                zr <- zz[, covariates, with = F]
                # source("EstimatorFunctions.R")
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$|^UD|^pc.*[dt]$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   # opposite.time.order: set to F to get t-(t-1) difference. 
                   # (to be used in FDestimation in the later chunk)
                   # Under F, diff(LHS) = -1 if schoolp 1 (1999) -> 0 (2002).
                   # agHH.yr2 is demeaned interaction (of agHH and yr2=1999 dummies), 
                   #   275 of obs (agHH==0) =  .59 because   -.39  (1999)  ->  .20 (2002)
                   #   407 of obs (agHH==1) = -.401 because  .266 (1999) -> -.135 (2002)
                   # In diff data, ag HH who dropped out: LHS = -1, agHH.yr2 = -.4 => OLS estimate > 0.
                   # A larger drop in LHS (more negative) for agHH == 1 dummy 
                   # needs agHH.yr2 to be defined as a positive value.
                   # Similarly, sex (female) == 1 gives diff(sex.yr2) < 0 for females in t-(t-1) diff. 
                   # X.yr2 needs to be defind as positive. To do so, in FDestimation, 
                   # one needs to set opposite.time.order = F & all time variant covariates
                   # to be X.yr2 := -1 * X.yr2 [so diff(agHH.yr2) > 0].
                   opposite.time.order = F, # Use t - (t-1) diff
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est, org.data = zz)
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              if (!any(grepl("latrine.agHH.yr|water.agHH.yr", rownames(est[[k]])))) {
                cat(zSobj[jj], "agelb", s0, z234[j], c("boys", "girls", "boys+girls")[ge], 
                  aghh.defs[m], "\n")
                cat("Skipped, some covariates cannot be used due to too small number of obs:", nrow(zr), "\n\n")
                next
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[s]][[j]][[ge]][[m]] <- resul
              # First run estimation data is stored in resul.
              # Pick the last item of data list which has the least num of obs. 
              # (This is data to use for all specifications.)
              # zidd: Differenced data of the last item in resul.
              # zid2: Level data to reconstruct and demean interaction terms of covariates.
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex"))
              zidd[, tee := 1]
              enrr <- zid[, .(EnRate = mean(Enrolled), Num = .N), by = .(agHH, tee)]
              Enr.Base <- rbind(Enr.Base, 
                cbind(zSobj[jj], c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m], 
                  s0, enrr),
                use.names = F
              )
              # Save mean enrollment rate changes
              # x: agHH, y: nonagHH
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "Enrolled")
              ttestE <- t.test(zidd[agHH == 1, Enrolled], zidd[agHH == 0, Enrolled])
              Enrchg.Base <- rbind(Enrchg.Base, 
                cbind(
                    zSobj[jj], c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m], 
                    s0, -diff(unlist(ttestE["estimate"])), # -diff = -(y - x) = AgHH - nonagHH
                    t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                    )
                  )
              #for (cl in c("LiangZeger", "satterthwaite", "wildclusterboot")) 
              for (cl in c("LiangZeger", "satterthwaite")) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl
                cat("\n\n###", cl, "###\n\n")
                #if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl) & any(grepl("Sib", colnames(zidd)))) {
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  # Julia fails for specification 6 in zEm.1999, zEp.1999, zEp.2002
                  if (grepl("wild", cl) & k == 6) next
                  #if (ii == 1 & grepl("S", zSobj[jj]) & s >= 1 & m == 4 & k >= 5 & grepl("wild", cl)) 
                  #zSm1999FDOlder10Occ
                  #  next
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  # var.always.use has level variables used only for destat purpose, so drop them
                  covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)]
                  # Commented out: Aug 2, 2023 Start
                  #if (grepl("zEp|zSp", zSobj[jj]))
                  #  covariates <- covariates[!grepl("OldSib", covariates)]
                  # Commented out: Aug 2, 2023 End
                  zr <- zidd[, c(covariates, "tee"), with = F]
                # source("EstimatorFunctions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "Enrolled", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  results0[[jj]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                    list(est = rsl$est, ci = rsl$CI,
                      df = rsl$reg$df, reg = rsl$reg,
                      #level.data = leveldata[, gsub("Enrolled", "LHS", covariates), with = F], 
                      level.data = zid, 
                      diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  # Sign reversion is done before FDestimation. Below is redundant.
                  # Take19992002Diff is set to F in "read data chunk" at the beginning
                  # If (t-1) - t difference (opposite time order), signs of yrX cross terms are inverted.
                  #if (Take19992002Diff) est[[k]][grepout("Inter|yr.$", rownames(est[[k]])), c(1, 3)] <- 
                  #  -1 * est[[k]][grepout("Inter|yr.$", rownames(est[[k]])), c(1, 3)]
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean at baseline" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "control mean at follow up" = 
                       rep(formatC(enrr[tee == 2 & agHH == 0, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at baseline" =
                       rep(formatC(enrr[tee == 1 & agHH == 1, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at follow up" =
                       rep(formatC(enrr[tee == 2 & agHH == 1, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "raw DID" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1, EnRate] - enrr[tee == 1 & agHH == 1, EnRate] 
                       -(enrr[tee == 2 & agHH == 0, EnRate] - enrr[tee == 1 & agHH == 0, EnRate]), 
                         digits = 2, format = "f"), length(regressorsS))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "epc"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source("tabulate_est.R")
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, 
                  CIInTinySize = T, 
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$",
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                  # Split a table in to 2 tables
                if (DivInto2Tables) {
                  # Split a table in to 2 tables
                  if (grepl("e[ps]$", OUTformat)) 
                    NumRowsAfterEst <- 2 else 
                    NumRowsAfterEst <- 3
                  tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                  tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                  tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                  tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                  iispace11 <- which(
                    grepl(".", tbest11) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                    )
                  iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                  iispace21 <- which(
                    grepl(".", tbest21) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                    )
                  # drop last rows of tbest2 to shrink row space
                  iispace21 <- iispace21[iispace21 < max(grep("toilet|water", tbest21))]
                  iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                  if (grepl("e[ps]$", OUTformat)) {
                  # ep, es: 2 rows per estimate
                    AdjustLineSkipRows1 <- iispace11
                    AltColorRows1 <- c(iispace12, iispace12+1)
                    AdjustLineSkipRows2 <- iispace21
                    AltColorRows2 <- c(iispace22, iispace22+1)
                  } else {
                  # epc, esc, satt: 3 rows per estimate
                    AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                    AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                    AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                    AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                  }
                  tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows1,
                    alternatecolorManual = AltColorRows1,
                    alternatecolorManualColor = "gray80")
                  tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest21),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows2,
                    alternatecolorManual = AltColorRows2,
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows1 <- grep("nteract.*\\d", tbl1)
                  InterRows2 <- grep("nteract.*\\d", tbl2)
                  for (ir in InterRows1) {
                    if (any(grepl("rowcolor", tbl1[ir])))
                      tbl1[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl1[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          )
                    # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                    # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                    tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                    tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                    tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                  }
                  for (ir in InterRows2) {
                    if (any(grepl("rowcolor", tbl2[ir])))
                      tbl2[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl2[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          )
                    tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                    tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                    tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                  }
                  clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                  # file path to saved table
                  pathtosavedtable1 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = gsub("\\.", "", zSobj[jj]), 
                    AgeCutoff = paste0("Older", (10:12)[s]),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 1)
                    )
                  pathtosavedtable2 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = gsub("\\.", "", zSobj[jj]), 
                    AgeCutoff = paste0("Older", (10:12)[s]),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 2)
                    )
                  write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable1, "\n")
                  cat("Table saved as", pathtosavedtable2, "\n")
                } else {
                  # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                  iispace <- which(
                    # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                    grepl(".", tbest[[1]]) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                    )
                  iispace2 <- iispace[seq(2, length(iispace), 2)]
                  # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                  # adjlskiprows = c(iispace, iispace+1)
                  tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest[[1]]),
                    hleft = "\\hfil\\tiny$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.5ex", 
                    adjlskiprows = c(iispace, iispace+1),
                    alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                    alternatecolorManualColor = "gray80")
                  if (grepl("Liang", cl))
                    tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                      estimationspacelast = grep("thana dummi", tbest[[1]]),
                      hleft = "\\hfil\\tiny$", hright = "$", 
                      hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                      delimiterline = NULL, adjustlineskip = "-0.5ex", 
                      adjlskiprows = c(iispace),
                      alternatecolorManual = c(iispace2, iispace2+1),
                      alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows <- grep("nteract.*\\d", tbl)
                  for (ir in InterRows)
                    if (any(grepl("rowcolor", tbl[ir])))
                      tbl[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          ) else
                        # rows without rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          )
                  pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                    Sample = gsub("\\.", "", zSobj[jj]), 
                    AgeCutoff = paste0("Older", (10:12)[s]),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                  write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable, "\n")
                } # if end: DivInto2Tables
              } # cl: SE clustering option
            }  # m: ag HH definitions
          } # ge: gendered or both gender
      }  # s: lowerbound age cutoffs (10, 11, 12)
    }  # j: all children or direct offspring
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
#    [[ii]][[jj]][[s]][[j]][[ge]][[m]][[clnum]][[k]]
# resultsN: Results under varying number of obs between specifications
#    [[ii]][[jj]][[s]][[j]][[ge]][[m]][[k]]
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
library(qs)
qsave(results, paste0(pathsaveThisVer, "DID_MainResults.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "DID_N_MainResults.qs"))
# results <- qread(paste0(pathsaveThisVer, "DID_MainResults.qs"))
Enr.Base <- data.table(Enr.Base)
Enrchg.Base <- data.table(Enrchg.Base)
setnames(Enrchg.Base, c("sample", "HHtype", "agHHdef", "demean", "age", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue")[-4])
setnames(Enr.Base, c("sample", "HHtype", "agHHdef", "demean", "age", "agHH", "tee", "rate", "Obs")[-4])
qsave(Enr.Base, paste0(pathsaveThisVer, "Enr.Base.qs"))
qsave(Enrchg.Base, paste0(pathsaveThisVer, "Enrchg.Base.qs"))
@
<<plot main agelb 10 agHH0 by gender demeaned undemeaned, eval = F>>=
library(ggplot2)
Res <- qread(paste0(pathsaveThisVer, "TabulatedMainSelectedResults1.qs"))
re <- Res[grepl("Em", data) & grepl("4|5|6|7", reg) & grepl("B", inference)
   & agelb == 10 & grepl("all|dir", HHtype), ]
re <- re[grepl("ma", coeff), ]
setkey(re, data, coeff, reg)
re[, hr := paste0(HHtype, "-", reg)]
re[, yintercept := 0]
g <- ggplot(data = re, 
    aes(x = demean, y = beta, group = hr, fill = hr, shape = hr, colour = hr)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .5)) +
  scale_shape_manual(values = c(0:6, 8))+
  facet_grid(coeff ~ gender, scales = "free_y")+
  ThisThemeEnd+
  #scale_y_continuous(limits = c(-1, 1)/2)+
  xlab("interaction terms") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 2),
    fill = guide_legend(title = "regression specifications", nrow = 2),
    shape = guide_legend(title = "regression specifications", nrow = 2)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "MainImpactsByGenderByDemeanAgelb10.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<plot placebo zEp1999 agHH0 by gender demeaned undemeaned, eval = F>>=
library(ggplot2)
Res <- qread(paste0(pathsaveThisVer, "TabulatedMainSelectedResults1.qs"))
re <- Res[grepl("Ep.1", data) & grepl("4|5|6|7", reg) & grepl("B", inference)
   & agelb == 10 & grepl("all|dir", HHtype), ]
re <- re[grepl("ma", coeff), ]
setkey(re, data, coeff, reg)
re[, hr := paste0(HHtype, "-", reg)]
re[, yintercept := 0]
g <- ggplot(data = re, 
    aes(x = demean, y = beta, group = hr, fill = hr, shape = hr, colour = hr)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .5)) +
  scale_shape_manual(values = c(0:6, 8))+
  facet_grid(coeff ~ gender, scales = "free_y")+
  ThisThemeEnd+
  #scale_y_continuous(limits = c(-1, 1)/2)+
  xlab("interaction terms") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 2),
    fill = guide_legend(title = "regression specifications", nrow = 2),
    shape = guide_legend(title = "regression specifications", nrow = 2)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "PlaceboImpactsByGenderByDemeanAgelb10.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<plot placebo zEp2002 agHH0 by gender demeaned undemeaned, eval = F>>=
library(ggplot2)
Res <- qread(paste0(pathsaveThisVer, "TabulatedMainSelectedResults1.qs"))
re <- Res[grepl("Ep.2", data) & grepl("4|5|6|7", reg) & grepl("B", inference)
   & agelb == 10 & grepl("all|dir", HHtype) & grepl(0, agdef), ]
re <- re[grepl("^agHH.yr.$|Sib.*H.*yr.$", Coef), ]
setkey(re, data, coeff, reg)
re[, hr := paste0(HHtype, "-", reg)]
re[, yintercept := 0]
g <- ggplot(data = re, 
    aes(x = demean, y = beta, group = hr, fill = hr, shape = hr, colour = hr)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .5)) +
  scale_shape_manual(values = c(0:6, 8))+
  facet_grid(coeff ~ gender, scales = "free_y")+
  ThisThemeEnd+
  #scale_y_continuous(limits = c(-1, 1)/2)+
  xlab("interaction terms") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 2),
    fill = guide_legend(title = "regression specifications", nrow = 2),
    shape = guide_legend(title = "regression specifications", nrow = 2)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "Placebo2ImpactsByGenderByDemeanAgelb10.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<>>=
library(qs)
Enr.Base <- qread(paste0(pathsaveThisVer, "Enr.Base.qs"))
Enrchg.Base <- qread(paste0(pathsaveThisVer, "Enrchg.Base.qs"))
@
<<tabulate results age gender wise, eval = F>>=
results <- qread(paste0(pathsaveThisVer, "DID_SubsampleAgeGroupGenderResults.qs"))
names(results[[1]][[1]])
zsobj <- c("zEm.1999", "zEp.2002", "zEp.1999", "zYp.1999")[-4]
# results[[ii]][[ge]][[m]][[j]][[gg]][[ag]][[cl]][[k]] levels.
# zsobj <- c("zEm.1999", "zEp.2002", "zEp.1999", "zYp.1999"): ii = 1, 2, 3, 4.
# ii = data, m = agHHdef, ge = gender, j = HH type, gg = AgeGroup1,  
#  ag = age groups , cl = LiangZeger/satterthwaite
# age groups
AGEgrouping <- c("agewise", "AgeGroup1", "AgeGroup2", "AgeGroup3")[3:4]
agewise <- as.list(6:18); names(agewise) <- putzeroontop(6:18)
AgeGroup1 <- list(pri=6:10, jsec=11:13, sec=14:15, hsec=16:17, coll=18)
AgeGroup2 <- list(pri=6:10, sec=11:17, coll=18)
AgeGroup3 <- list(young=6:9, junior=10:15, senior=16:18)
names(results[[1]][[ge]][[m]][[j]][[gg]])
Res2 <- NR2 <- Enr2 <- NULL
for (ii in 1:length(zsobj)) {
  thisdata <- zsobj[[ii]]
  for (ge in 1:3) {
      for (m in 1:4) {
        for (j in 1:2) {
          for (gg in 1:length(AGEgrouping)) {
            AGEgroup <- get(AGEgrouping[gg])
            for (ag in 1:length(AGEgroup)) {
              for (clnum in 1:2) {
                estobj <- results[[ii]][[ge]][[m]][[j]][[gg]][[ag]][[clnum]]
                CIs <- lapply(estobj, "[[", "ci")
                if (length(CIs) == 0 || is.null(CIs[[1]])) {
                  cat("Skipped due to no estimation:", 
                    paste0("ii==", zsobj[ii]),
                    paste0("ge==", genderitems[ge]), 
                    paste0("m==", aghh.defs[m]), 
                    paste0("j==", c("all", "direct")[j]), 
                    paste0("gg==", AGEgrouping[gg]), 
                    paste0("ag==", AGEgroup[ag]), "\n")
                  next
                }
                CIs <- lapply(CIs, data.table)
                CIs <- lapply(1:length(CIs), function(i) CIs[[i]][, reg := i])
                CIs <- rbindlist(CIs, use.names = T, fill = T)
                # if clnum == 1, estobj only contains CIs
                if (clnum == 1) {
                  esp <- lapply(estobj, "[[", "est")
                  esp <- lapply(esp, as.matrix)
                  esprn <- unlist(lapply(esp, rownames))
                  esp <- lapply(esp, function(x) as.data.table(x[, ]))
                  dfs <- lapply(lapply(estobj, "[[", "est"), function(x) attributes(x)$df)
                  esp <- lapply(1:length(esp), function(i) esp[[i]][, df := dfs[[i]]])
                  esp <- rbindlist(esp, use.names = T, fill = T)
                  if (any(grepl("z value", colnames(esp)))) esp[, "z value" := NULL]
                  CIs <- cbind(Coef = esprn, esp, CIs)
                  setnames(CIs,  c("Coef", "beta", "SE", "t", "p_val", "df", "CI_L", "CI_U", "reg"))
                  CIs[, t := NULL]
                }
                CIs[, inference := c("LZ", "BRL")[clnum]]
                CIs[, group := names(results[[ii]][[ge]][[m]][[j]][[gg]])[ag]]
                CIs[, agegroup := names(results[[ii]][[ge]][[m]][[j]])[gg]]
                CIs[, agdef := aghh.defs[m]]
                CIs[, HHtype := c("all", "direct", "exonly")[j]]
                CIs[, gender := genderitems[ge]]
                CIs[, data := thisdata]
                CIs[, p_val := round(p_val, 6)]
                CIs[, SE := round(SE, 8)]
                setcolorder(CIs,  c("data", "gender", "agdef", "HHtype", "demean", 
                  "agegroup", "group", "Coef", "beta", "SE", "df", "p_val", "CI_L", "CI_U", "reg", "inference")[-5])
                Res2 <- rbindlist(list(Res2, CIs), use.names = F)
                # n and R2
                nR <- lapply(lapply(estobj, "[[", "reg"), 
                  function(x) t(c(length(summary(x)$res), summary(x)$r.sq)))
                nR <- lapply(nR, data.table)
                nR <- lapply(1:length(nR), function(i) nR[[i]][, spec := i])
                nR <- rbindlist(nR, use.names = T, fill = T)
                nR[, gender := genderitems[ge]]
                setnames(nR, c("n", "R", "spec", "gender"))
                nR[, n := formatC(n, digits = 0, format = "f")]
                nR[, R := formatC(R, digits = 4, format = "f")]
                # number of agHHs
                nR2 <- unique(unlist(lapply(lapply(estobj, "[[", "diff.data"), 
                  function(x) sum(x[, agHH]>0))))
                nR[, Yes := formatC(nR2, digits = 0, format = "f")]
                nR[, inference := c("LZ", "BRL")[clnum]]
                nR[, group := names(results[[ii]][[ge]][[m]][[j]][[gg]])[ag]]
                nR[, agegroup := names(results[[ii]][[ge]][[m]][[j]])[gg]]
                nR[, agdef := aghh.defs[m]]
                nR[, HHtype := c("all", "direct", "exonly")[j]]
                nR[, data := thisdata]
                NR2 <- rbindlist(list(NR2, nR), use.names = F)
                # treated and control means
                zid <- estobj[[1]][["level.data"]]
                zidd <- estobj[[1]][["diff.data"]]
                zid <- zid[uniquid %in% zidd[, uniquid], ]
                zid[eval(parse(text=grepout("agHH$", colnames(x)))) > 0, agHH := 1L]
                zid[eval(parse(text=grepout("agHH$", colnames(x)))) < 0, agHH := 0L]
                zid[, tee := 1:.N, by = uniquid]
                if (any(grepl("Enrolled", colnames(zid)))) setnames(zid, "Enrolled", "schoolp")
                enr <- zid[, .(EnRate = mean(schoolp), Num = .N), by = .(agHH, tee)]
                enr[, inference := c("LZ", "BRL")[clnum]]
                enr[, group := names(results[[ii]][[ge]][[m]][[j]][[gg]])[ag]]
                enr[, agegroup := names(results[[ii]][[ge]][[m]][[j]])[gg]]
                enr[, HHtype := c("all", "direct", "exonly")[j]]
                enr[, agdef := aghh.defs[m]]
                enr[, gender := genderitems[ge]]
                enr[, data := thisdata]
                Enr2 <- rbindlist(list(Enr2, enr), use.names = F)
              } # clnum
            } # ag
          } # gg
        } # j
      } # m
    } # ge
} # ii
setcolorder(Res2, c("data", "gender", "agegroup", "group",  "HHtype", "reg", "agdef",
  grepout("bet|SE|df|CI|^p", colnames(Res2))))
Res2[, agdef := factor(agdef)]
Res2[, gender := factor(gender)]
Res2[, agegroup := factor(agegroup)]
Res2[, reg := factor(reg)]
Res2[, Coef := factor(Coef)]
Res2[, HHtype := factor(HHtype)]
Res2[, inference := factor(inference)]
Res2[, data := factor(data)]
Res2[, gender := factor(gender, levels = genderitems)]
maxageinGroup <- max(as.numeric(as.character(unique(Res2[, group]))), na.rm = T)
Res2[, group := factor(group, levels = c("pri", "sec", "young", "junior", "senior", "coll"))]
Res2[, yintercept := 0]
qsave(Res2, paste0(pathsaveThisVer, "TabulatedMainResults2.qs"))
qsave(Enr2, paste0(pathsaveThisVer, "TabulatedMainResultsEnr2.qs"))
qsave(NR2, paste0(pathsaveThisVer, "TabulatedMainResultsNR2.qs"))
<<tabulate main results, eval = F>>=
library(qs)
AddStar <- T
results1 <- qread(paste0(pathsaveThisVer, "DID_MainResults.qs"))
results2 <- qread(paste0(pathsaveThisVer, "DID_SubsampleAgeGroupGenderResults.qs"))
# results1[[ii]][[jj]][[s]][[j]][[ge]][[m]][[clnum]][[k]]
# cl: c("LiangZeger", "satterthwaite", "wildclusterboot")
# at k=4: program is added to covariates
# ii=2, jj = 1 is zEp.2002, dd = 2 is level interactions
# results2[[ii]][[ge]][[m]][[j]][[gg]][[ag]][[cl]][[k]]
## for results1, 
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")[1] 
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999", "zYp.1999")[c(1, 3)]
samples <- c("main", "placebo")
z234 <- c("z2", "z3", "z4")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")[1]
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999")[c(1, 3)]
EstGen <- NR <- Enr <- NULL
results <- results1
for (ii in 1:2) {
  zSobj <- get(zsobj[[ii]])
  for (jj in 1:length(zSobj)) {
    thisdata <- zSobj[[jj]]
    for (s in 1:3) {
      for (j in 1:2) {
        for (ge in 1:3) {
          for (m in 1:4) {
            for (clnum in 1:2) {
              # cl: 1: LZ, 2: satterthwaite
              estGen1 <- results[[ii]][[jj]][[s]][[j]][[ge]][[m]][[clnum]]
              if (all(unlist(lapply(estGen1, is.null)))) next
              estGen <- lapply(estGen1, "[[", "ci")
              estGen <- lapply(estGen, data.table)
              estGen <- lapply(1:length(estGen), function(i) estGen[[i]][, reg := i])
              estGen <- rbindlist(estGen, use.names = T, fill = T)
              # if clnum == 1, estGen only contain CIs
              if (clnum == 1) {
                esp <- lapply(estGen1, "[[", "est")
                esp <- lapply(esp, as.matrix)
                esprn <- unlist(lapply(esp, rownames))
                esp <- lapply(esp, function(x) as.data.table(x[, ]))
                dfs <- lapply(lapply(estGen1, "[[", "est"), function(x) attributes(x)$df)
                esp <- lapply(1:length(esp), function(i) esp[[i]][, df := dfs[[i]]])
                esp <- rbindlist(esp, use.names = T, fill = T)
                if (any(grepl("z value", colnames(esp)))) esp[, "z value" := NULL]
                estGen <- cbind(Coef = esprn, esp, estGen)
                setnames(estGen,  c("Coef", "beta", "SE", "t", "p_val", "df", "CI_L", "CI_U", "reg"))
                estGen[, t := NULL]
              }
              estGen[, p_val := round(p_val, 6)]
              estGen[, SE := round(SE, 8)]
              estGen[, inference := c("LZ", "BRL")[clnum]]
              estGen[, gender := genderitems[ge]]
              estGen[, agdef := aghh.defs[m]]
              estGen[, agelb := c(10:12)[s]]
              estGen[, HHtype := c("all", "direct", "exonly")[j]]
              estGen[, data := thisdata]
              estGen[, objective := c("main", "placebo")[ii]]
              setcolorder(estGen,  c("objective", "data", "gender", "agdef", "agelb", "HHtype", 
                "demean", "Coef", "beta", "SE", "df", "p_val", "CI_L", "CI_U", "reg", "inference")[-7])
              EstGen <- rbindlist(list(EstGen, estGen), use.names = T, fill = T)
              # n and R2
              nR <- lapply(lapply(estGen1, "[[", "reg"), 
                function(x) t(c(length(summary(x)$res), summary(x)$r.sq)))
              nR <- lapply(nR, data.table)
              nR <- lapply(1:length(nR), function(i) nR[[i]][, spec := i])
              nR <- rbindlist(nR, use.names = T, fill = T)
              nR[, gender := genderitems[ge]]
              setnames(nR, c("n", "R", "spec", "gender"))
              nR[, n := formatC(n, digits = 0, format = "f")]
              nR[, R := formatC(R, digits = 4, format = "f")]
              # number of agHHs
              nR2 <- unique(unlist(lapply(lapply(estGen1, "[[", "diff.data"), 
                function(x) sum(x[, agHH]>0))))
              nR[, Yes := formatC(nR2, digits = 0, format = "f")]
              nR[, agdef := aghh.defs[m]]
              nR[, agelb := c(10:12)[s]]
              nR[, HHtype := c("all", "direct", "exonly")[j]]
              nR[, data := thisdata]
              nR[, objective := c("main", "placebo")[ii]]
              nR[, inference := c("LZ", "BRL")[clnum]]
              NR <- rbind(NR, nR, use.names = T, fill = T)
              # treated and control means
              zid <- lapply(estGen1, "[[", "level.data")
              zidd <- lapply(estGen1, "[[", "diff.data")
              zid <- lapply(1:length(zid), function(i) zid[[i]][uniquid %in% zidd[[i]][, uniquid], ])
              zid <- lapply(zid, function(x) x[eval(parse(text=grepout("agHH$", colnames(x)))) > 0, 
                        agHH := 1L])
              zid <- lapply(zid, function(x) x[eval(parse(text=grepout("agHH$", colnames(x)))) < 0, 
                        agHH := 0L])
              zid <- lapply(zid, function(x) x[, tee := 1:.N, by = uniquid])
              if (any(grepl("Enrolled", colnames(zid[[1]]))))
                lapply(zid, function(x) setnames(x, "Enrolled", "schoolp"))
              enr <- lapply(zid, function(x) x[, .(EnRate = mean(schoolp), Num = .N), by = .(agHH, tee)])
              enr <- lapply(1:length(enr), function(i) enr[[i]][, spec := i])
              enr <- rbindlist(enr, use.names = T, fill = T)
              enr[, gender := genderitems[ge]]
              enr[, agdef := aghh.defs[m]]
              enr <- unique(enr[, spec := NULL])
              enr[, agelb := c(10:12)[s]]
              enr[, HHtype := c("all", "direct", "exonly")[j]]
              enr[, data := thisdata]
              enr[, objective := c("main", "placebo")[ii]]
              enr[, inference := c("LZ", "BRL")[clnum]]
              Enr <- rbind(Enr, enr, use.names = T, fill = T)
            } # clnum
          } # m
        } # ge
      } # j
    } # s
  } # jj
} # ii
#EstGen[grepl("m", objective) & grepl("Em", data) & grepl("b.*g", gender) & agelb == 10 & 
#  HHtype == "all" & grepl("^agHH.yr2$", Coef) & reg == 3 & grepl("B", inference), ]
setnames(EstGen, "p_val", "p")
EstGen[, coeff := as.character(NA)]
EstGen[grepl("^agHH.yr.$", Coef), coeff := "main"]
EstGen[grepl("SibF.*H", Coef), coeff := "older female siblings"]
EstGen[grepl("SibM.*H", Coef), coeff := "older male siblings"]
EstGen[, coeff := factor(coeff)]
EstGen[, Coef := factor(Coef)]
EstGen[, inference := factor(inference)]
EstGen[, objective := factor(objective)]
EstGen[, data := factor(data)]
EstGen[, agdef := factor(agdef)]
EstGen[, gender := factor(gender)]
EstGen[, HHtype := factor(HHtype)]
EstGen[, gender := factor(gender, levels = genderitems)]
qsave(EstGen, paste0(pathsaveThisVer, "TabulatedMainResults1.qs"))
qsave(Enr, paste0(pathsaveThisVer, "TabulatedMainResultsEnr1.qs"))
qsave(NR, paste0(pathsaveThisVer, "TabulatedMainResultsNR1.qs"))

<<rbind tabulated main and agewise results, eval = F>>=
Res1 <- qread(paste0(pathsaveThisVer, "TabulatedMainResults1.qs"))
Enr1 <- qread(paste0(pathsaveThisVer, "TabulatedMainResultsEnr1.qs"))
NR1 <- qread(paste0(pathsaveThisVer, "TabulatedMainResultsNR1.qs"))
Res2 <- qread(paste0(pathsaveThisVer, "TabulatedMainResults2.qs"))
Enr2 <- qread(paste0(pathsaveThisVer, "TabulatedMainResultsEnr2.qs"))
NR2 <- qread(paste0(pathsaveThisVer, "TabulatedMainResultsNR2.qs"))
Res <- rbindlist(list(Res1, Res2), use.names = T, fill = T)
Res[, gender := factor(gender, levels = genderitems)]
Res[, reg := as.integer(unlist(reg))]
setnames(Res, "stat", "SattDoF", skip_absent = T)
Res[grepl("F.*H", Coef), coeff := "older female siblings"]
Res[grepl("M.*H", Coef), coeff := "older male siblings"]
Enr <- rbindlist(list(Enr1, Enr2), use.names = T, fill = T)
NR <- rbindlist(list(NR1, NR2), use.names = T, fill = T)
NR[, objective := factor(objective)]
NR[, data := factor(data)]
NR[, agdef := factor(agdef)]
NR[, gender := factor(gender, levels = genderitems)]
NR[, HHtype := factor(HHtype)]
NR[, inference := factor(inference)]
NR[, group := factor(group)]
NR[, agegroup := factor(agegroup)]
setnames(NR, "spec", "reg")
Enr[, objective := factor(objective)]
Enr[, data := factor(data)]
Enr[, agdef := factor(agdef)]
Enr[, gender := factor(gender, levels = genderitems)]
Enr[, HHtype := factor(HHtype)]
Enr[, inference := factor(inference)]
Enr[, group := factor(group)]
Enr[, agegroup := factor(agegroup)]
qsave(Res, paste0(pathsaveThisVer, "TabulatedAllResults.qs"))
qsave(Enr, paste0(pathsaveThisVer, "TabulatedAllResultsEnr.qs"))
qsave(NR, paste0(pathsaveThisVer, "TabulatedAllResultsNR.qs"))
@




<<>>=
library(qs)
Enr.Base <- qread(paste0(pathsaveThisVer, "Enr.Base.qs"))
Enrchg.Base <- qread(paste0(pathsaveThisVer, "Enrchg.Base.qs"))
@

\subsubsection{Progression (number of added grades)}

Number of added grades is a difference between class in 2002 and 1999 for individuals who are not classfied as not-in-school. Not-in-school is defined as individuals who have schooling only up to nursery in both 1999 and 2002, or who report non-enrollment in both 1999 and 2002, or who have zero grade progression between 2002 and 1999. 

<<num grades of enrollers by gender impacts, eval = F, results = 'hide', cache = F>>=
library(clubSandwich)
DivInto2Tables <- T
clusterlevel <- "thana"
regressors.list <- list(
  main = regressorsNumGrades,
  placebo = regressorsNumGrades2002
)
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
samples <- "main"
z234 <- c("z2", "z3", "z4")
zsobj <- "zmobjOther"
zmobjOther <- "zEm.1999"
cohort.years.list <- list(# year age is defined
  main = rep(1999, 1), # main: use 1999 age to set age range
  placebo = c(rep(2002, 1), rep(1999, 1))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
# Used in "interaction with year InterYears" in results table
InterYearsList <- list(main = rep(2002, 1), placebo = rep(c(2006, 2002), each = 1))
variables.always.use <- "NumGrades|^agHH.yr2|^agHH$|^thana$|uniqu"
yrXs <- c("yr2", "yr3")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
)
boxWidth <- 4
centerWidth <- 1.3
SkipLowerBound <- 50
NumGrades <- NumGradeschg <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  yrX <- yrXs[ii]
  var.always.use <- gsub("yr2", yrX, variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("NumGrades", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  res <- list("initial" = res,  "all time" = res) # en
  # res[[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  for (jj in 1:length(zSobj)) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    ## Select initial or all time enrollers ##
    # InitialEnrollers: enrolled in 1999. 
    # AllTimeEnrollers: enrolled in 1999 and 2002. 
    # Others: not enrolled or enrolled only in 2002
    z01[, EnrollerStatus := "others"]
    z01[, ss1 := schoolp[1], by = uniquid]
    z01[grepl(1, ss1), EnrollerStatus := "initial"]
    z01[, ss := cumsum(schoolp), by = uniquid]
    z01[, ss2 := ss[2], by = uniquid]
    z01[grepl(2, ss2), EnrollerStatus := "all time"]
    z01[, c("ss", "ss1", "ss2") := NULL]
    z01[, EnrollerStatus := factor(EnrollerStatus, levels = 
      c("initial", "all time", "others"))]
    for (en in 1:2) {
      enrs <- c("initial", "all time", "others")[en]
      z02 <- z01[grepl(enrs, EnrollerStatus), ]
      # This gives a warning, so avoid: z01[grepl(c("initial", "all time", "others")[en], EnrollerStatus), ]
      z1 = copy(z02)
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      tabextend <- c("yes", "", "yes", "")
      tabcohortdemeaned <- c("", "yes", "", "yes")
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      if (ii == 2 & jj == 5) smax <- 1 else smax <- 3
      for (s in 1:3)
      #  choice of age cutoff
      {
        if (ii == 2 & jj == 5) {
          s0 <- 6
          MaxAge <- 9
        } else {
          MaxAge <- 18
        }
        i <- paste0("older", s0)
        s0 <- (10:12)[s]
        i <- paste0("older", s0)
        # latter panel: s <= age < maxAge in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
          #maxAge
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
        for (j in 1:length(z23))
        {
          zz00 = copy(get(z234[j]))
          setkey(zz00, uniquid, survey)
          for (ge in 1:3)
          {
            if (ge == 1) {
              zz0 = copy(zz00[sex <= 0, ]) 
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else  if (ge == 2){
              zz0 = copy(zz00[sex > 0, ])
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else zz0 = copy(zz00)
            if (nrow(zz0) < SkipLowerBound) {
              cat("Skipped due to small number of obs:", nrow(zz0), "\n")
              next
            }
            setkey(zz0, uniquid, survey)
            zz0[, survey := NULL]
            for (m in 1:length(aghh.defs))
            {
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              ns <- NULL
              resul <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                zr <- zz[, covariates, with = F]
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   opposite.time.order = F,
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[en]][[s]][[j]][[ge]][[m]] <- resul
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) 
              zidd[, tee := 1]
              zid[, tee := 1:.N, by = uniquid]
              if (any(grepl("NumGrades", colnames(zidd)))) setnames(zidd, "NumGrades", "LHS")
              if (any(grepl("NumGrades", colnames(zid)))) setnames(zid, "NumGrades", "LHS")
              # Save mean number of grades
              enrr <- zid[, .(MeanNumGrades = mean(LHS), Num = .N), by = .(agHH, tee)]
              NumGrades <- rbind(NumGrades, 
                cbind(zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                  c("initial", "all time")[en], c("boys", "girls", "boys+girls")[ge], s0, enrr),
                use.names = F
              )
              # Save mean progression rate changes
              # x: agHH, y: nonagHH
              ttestE <- t.test(zidd[agHH == 1, LHS], zidd[agHH == 0, LHS])
              NumGradeschg <- rbind(NumGradeschg, 
                cbind(
                    zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                    c("initial", "all time")[en], c("boys", "girls", "boys+girls")[ge], 
                    s0, round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                    t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                    )
                  )
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "NumGrades")
              for (cl in c("LiangZeger", "satterthwaite"))#, "wildclusterboot")) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl 
                cat("\n\n###", cl, "###\n\n")
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "NumGrades", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (!is.logical(UseSmallClusterCorrection) && grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (!is.logical(UseSmallClusterCorrection) && grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    #   estimate, Std.Error, statistic, Pr(>|t|), ci.lb, ci.ub
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    #   Estimate, Std. Error, t-value, Pr(>|t|)
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  results0[[jj]][[en]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                    list(est = rsl$est, ci = rsl$CI,
                      df = rsl$reg$df, reg = rsl$reg,
                      level.data = zid2[, covariates, with = F], 
                      diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean at baseline" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "control mean at follow up" = 
                       rep(formatC(enrr[tee == 2 & agHH == 0, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at baseline" =
                       rep(formatC(enrr[tee == 1 & agHH == 1, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at follow up" =
                       rep(formatC(enrr[tee == 2 & agHH == 1, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "raw DID" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1, MeanNumGrades] - enrr[tee == 1 & agHH == 1, MeanNumGrades] 
                       -(enrr[tee == 2 & agHH == 0, MeanNumGrades] - enrr[tee == 1 & agHH == 0, MeanNumGrades]), 
                         digits = 2, format = "f"), length(regressorsS))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source(paste0(pathprogram, "tabulate_est.R"))
                # source("c:/seiro/settings/Rsetting/functions.R")
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, #TableFormat = tabformat,
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$", 
                  CIInTinySize = T, 
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                if (DivInto2Tables) {
                  # Split a table in to 2 tables
                  if (grepl("Lian", cl)) 
                    NumRowsAfterEst <- 2 else 
                    NumRowsAfterEst <- 3
                  tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                  tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                  tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                  tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                  iispace11 <- which(
                    grepl(".", tbest11) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                    )
                  iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                  iispace21 <- which(
                    grepl(".", tbest21) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                    )
                  # drop last rows of tbest2 to shrink row space
                  iispace21 <- iispace21[iispace21 < max(grep("toilet|water|nonla", tbest21))]
                  iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                  if (grepl("Lian|^e[ps]$", cl)) {
                  # ep: 2 rows per estimate
                    AdjustLineSkipRows1 <- iispace11
                    AltColorRows1 <- c(iispace12, iispace12+1)
                    AdjustLineSkipRows2 <- iispace21
                    AltColorRows2 <- c(iispace22, iispace22+1)
                  } else {
                  # epc, satt: 3 rows per estimate
                    AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                    AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                    AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                    AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                  }
                  # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                  tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-.7ex", 
                    adjlskiprows = AdjustLineSkipRows1,
                    AddTopStripSpace = "1.0ex",
                    alternatecolorManual = AltColorRows1,
                    alternatecolorManualColor = "gray80")
                  tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest21),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-.7ex", 
                    adjlskiprows = AdjustLineSkipRows2,
                    alternatecolorManual = AltColorRows2,
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows1 <- grep("nteract.*\\d", tbl1)
                  InterRows2 <- grep("nteract.*\\d", tbl2)
                  for (ir in InterRows1) {
                    if (any(grepl("rowcolor", tbl1[ir])))
                      tbl1[ir] <- 
                        # \makbox[XXcm]{inter with A} &&&& \\
                        #  => \multicolumn{5}{l}{\makebox[10cm]{inter with A}} \\
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl1[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          )
                      # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                      # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                      tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                      tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                      tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                  }
                  for (ir in InterRows2) {
                    if (any(grepl("rowcolor", tbl2[ir])))
                      tbl2[ir] <- 
                        # For rows with rowcolor command at the end
                        paste0("[1ex]\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl2[ir] <- 
                        paste0("[1ex]\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          )
                      tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                      tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                      tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                  }
                  clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                  # file path to saved table
                  pathtosavedtable1 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("Initial", "AllTime", "Others")[en]),
                    AgeCutoff = paste0("NumGradesOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 1)
                    )
                  pathtosavedtable2 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("Initial", "AllTime", "Others")[en]),
                    AgeCutoff = paste0("NumGradesOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 2)
                    )
                  write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable1, "\n")
                  cat("Table saved as", pathtosavedtable2, "\n")
                } else {
                # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                iispace <- which(
                  # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                  grepl(".", tbest[[1]]) & 
                  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                  )
                iispace2 <- iispace[seq(2, length(iispace), 2)]
                # adjlskiprows = c(iispace, iispace+1)
                # saveEstTable is in functions.R
                # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                  estimationspacelast = grep("thana dummi", tbest[[1]]),
                  hleft = "\\hfil\\tiny$", hright = "$", 
                  hcenter = c(boxWidth, rep(centerWidth-.15, ncol(tbest[[2]]))), 
                  delimiterline = NULL, adjustlineskip = "-0.5ex", 
                  adjlskiprows = c(iispace, iispace+1),
                  alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                  alternatecolorManualColor = "gray80")
                # Modify "interaction with ..." lines to use multicolumn
                InterRows <- grep("nteract.*\\d", tbl)
                for (ir in InterRows)
                  if (any(grepl("rowcolor", tbl[ir])))
                    tbl[ir] <- 
                      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                      # rows with rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                        )
                        ) else
                      # rows without rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                        )
                        )
                  # file path to saved table
                  pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("Initial", "AllTime", "Others")[en]),
                    AgeCutoff = paste0("NumGradesOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                  write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable, "\n")
                } # If: DivInto2Tables ends
              } # cl: SE clustering option
            }  # m: ag HH definitions
          } # ge: gender
        }  # j: z2 (incl. extended) or z3 (nuclear)
      }  # s: lowerbound age cutoffs (10, 11, 12)
    }# en: enroller selection, 1=initial enrollers, 2=all time enrollers
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0 # [[jj]][[s]][[j]][[ge]][[m]][[clnum]][[k]]
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
library(qs)
qsave(results, paste0(pathsaveThisVer, "DID_NumGradesEnrollersGenderResults.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "DID_N_NumGradesEnrollersGenderResults.qs"))
NumGrades <- data.table(NumGrades)
NumGradeschg <- data.table(NumGradeschg)
setnames(NumGradeschg, c("sample", "HHtype", "agHHdef", "enroll", "gender", "agelb", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(NumGrades, c("sample", "HHtype", "agHHdef", "enroll", "gender", 
  "agelb", "agHH", "tee", "rate", "Obs"))
qsave(NumGrades, paste0(pathsaveThisVer, "NumGradesEnrollersGender.qs"))
qsave(NumGradeschg, paste0(pathsaveThisVer, "NumGradeschgEnrollersGender.qs"))
@

\subsubsection{Days absent in June-August}

Days absent is mean number of days per month absent from school between June-August (2000, Table A.2.A 3 [\textsf{seca2a\_6.dta} \textsf{sabsl3}]) and July and August (2003, Table 1B 5, 6 [\textsf{hh01b\_005.dta} \textsf{q1b05, q1b06}]). For ``all children'' results, I use 0 for non-enrollers. This is misleading. Absent days can only be defined for enrollers. One needs to use the sample of all-time enrollers.

<<days absent of enrollers by gender impacts, eval = F, results = 'hide', cache = F>>=
library(clubSandwich)
clusterlevel <- "thana"
DivInto2Tables <- T
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
samples <- "main"
z23 <- c("z2", "z3")
zsobj <- c("zmobjDays", "zpobjDays")
zmobjDays <- c("zEm.1999", "zSm.1999")[1]
zpobjDays <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999")[c(1, 3)]
cohort.years.list <- list(# year age is defined
  main = rep(1999, 2), 
  placebo = c(rep(2002, 1), rep(1999, 1))
  )
cutout.years<- c(rep(2006, 1), rep(1999, 1), rep(2006, 1)) # year to drop in data, main = 2006, placebo 1999
# Used in "interaction with year InterYears" in results table
InterYearsList <- list(main = rep(2002, 1), placebo = rep(c(2006, 2002), each = 2))
regressors.list <- list(
  main = regressorsM,
  placebo = regressorsM2002
)
variables.always.use <- "^DaysAbsent$|^agHH.yr2|^agHH$|^thana$|uniqu"
yrXs <- c("yr2", "yr3")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
)
boxWidth <- 4
centerWidth <- 1.3
DaysAbsent <- DaysAbsentchg <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  var.always.use <- gsub("yr2", yrXs[ii], variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("DaysAbsent", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  # Use satterthwaite only.
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  # res[[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  for (jj in 1:length(zSobj)) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    # ss == 2: enrolled in 1999 and 2002. Number of grade progression?
    z01[, ss := cumsum(schoolp), by = uniquid]
    z01[, ss := ss[2], by = uniquid]
    z02 <- z01[ss==2, ]
      z1 = copy(z02)
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      tabextend <- c("yes", "", "yes", "")
      tabcohortdemeaned <- c("", "yes", "", "yes")
      for (s in 1:3)
      #  choice of age cutoff
      {
        s0 <- (10:12)[s]
        if (ii == 2 & jj == 5) {
          s0 <- 6
          MaxAge <- 9
        } else {
          MaxAge <- 18
        }
        i <- paste0("older", s0)
        # latter panel: 5 <= age < s0 in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
          #maxAge
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
        for (j in 1:length(z23))
        {
          zz00 = copy(get(z23[j]))
          for (ge in 1:3)
          {
            if (ge == 1) {
              zz0 = copy(zz00[sex <= 0, ]) 
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else  if (ge == 2){
              zz0 = copy(zz00[sex > 0, ])
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else zz0 = copy(zz00)
            if (nrow(zz0) < SkipLowerBound) {
              cat("Skipped due to small number of obs:", nrow(zz0), "\n")
              next
            }
            setkey(zz0, uniquid, survey)
            zz0[, survey := NULL]
            for (m in 1:length(aghh.defs))
            {
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              ns <- NULL
              resul <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                zr <- zz[, covariates, with = F]
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   opposite.time.order = F,
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[s]][[j]][[ge]][[m]] <- resul
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) 
              zidd[, tee := 1]
              zid[, tee := 1:.N, by = uniquid]
              if (any(grepl("DaysAbsent", colnames(zidd)))) setnames(zidd, "DaysAbsent", "LHS")
              if (any(grepl("DaysAbsent", colnames(zid)))) setnames(zid, "DaysAbsent", "LHS")
              # Save mean days of absence
              enrr <- zid[, .(MeanDaysAbsent = mean(LHS), Num = .N), by = .(agHH, tee)]
              DaysAbsent <- rbind(DaysAbsent, 
                cbind(zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                  c("boys", "girls", "boys+girls")[ge],
                  s0, enrr),
                use.names = F
              )
              # Save mean progression rate changes
              # x: agHH, y: nonagHH
              ttestE <- t.test(zidd[agHH == 1, LHS], zidd[agHH == 0, LHS])
              DaysAbsentchg <- rbind(DaysAbsentchg, 
                cbind(
                    zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                    c("boys", "girls", "boys+girls")[ge],
                    s0, round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                    t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                    )
                  )
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "DaysAbsent")
              zidd[, tee := 1]
              for (cl in c("LiangZeger", "satterthwaite", "wildclusterboot")[-3]) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl 
                cat("\n\n###", cl, "###\n\n")
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  source("EstimatorFunctions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "DaysAbsent", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (!is.logical(UseSmallClusterCorrection) && grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (!is.logical(UseSmallClusterCorrection) && grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  results0[[jj]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                    list(est = rsl$est, ci = rsl$CI,
                      df = rsl$reg$df, reg = rsl$reg,
                      level.data = zid2[, covariates, with = F], 
                      diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean at baseline" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0, MeanDaysAbsent], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "control mean at follow up" = 
                       rep(formatC(enrr[tee == 2 & agHH == 0, MeanDaysAbsent], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at baseline" =
                       rep(formatC(enrr[tee == 1 & agHH == 1, MeanDaysAbsent], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at follow up" =
                       rep(formatC(enrr[tee == 2 & agHH == 1, MeanDaysAbsent], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "raw DID" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1, MeanDaysAbsent] - enrr[tee == 1 & agHH == 1, MeanDaysAbsent] 
                       -(enrr[tee == 2 & agHH == 0, MeanDaysAbsent] - enrr[tee == 1 & agHH == 0, MeanDaysAbsent]), 
                         digits = 2, format = "f"), length(regressorsS))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "satt"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source(paste0(pathprogram, "tabulate_est.R"))
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, #TableFormat = tabformat,
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$",
                  CIInTinySize = T, 
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                if (DivInto2Tables) {
                  # Split a table in to 2 tables
                  if (grepl("Lian", cl)) 
                    NumRowsAfterEst <- 2 else 
                    NumRowsAfterEst <- 3
                  tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                  tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                  tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                  tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                  iispace11 <- which(
                    grepl(".", tbest11) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                    )
                  iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                  iispace21 <- which(
                    grepl(".", tbest21) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                    )
                  # drop last rows of tbest2 to shrink row space
                  iispace21 <- iispace21[iispace21 < max(grep("toilet|water|nonla", tbest21))]
                  iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                  if (grepl("Lian", cl)) {
                  # ep: 2 rows per estimate
                    AdjustLineSkipRows1 <- iispace11
                    AltColorRows1 <- c(iispace12, iispace12+1)
                    AdjustLineSkipRows2 <- iispace21
                    AltColorRows2 <- c(iispace22, iispace22+1)
                  } else {
                  # epc, satt: 3 rows per estimate
                    AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                    AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                    AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                    AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                  }
                  tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows1,
                    alternatecolorManual = AltColorRows1,
                    alternatecolorManualColor = "gray80")
                  tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest21),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows2,
                    alternatecolorManual = AltColorRows2,
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows1 <- grep("nteract.*\\d", tbl1)
                  InterRows2 <- grep("nteract.*\\d", tbl2)
                  for (ir in InterRows1) {
                    if (any(grepl("rowcolor", tbl1[ir])))
                      tbl1[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl1[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          )
                      # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                      # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                      tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                      tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                      tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                  }
                  for (ir in InterRows2) {
                    if (any(grepl("rowcolor", tbl2[ir])))
                      tbl2[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl2[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          )
                      tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                      tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                      tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                  }
                  # file path to saved table
                  pathtosavedtable1 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = gsub("\\.", "", zSobj[jj]), 
                    AgeCutoff = paste0("DaysAbsentEnrollersOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 1)
                    )
                  pathtosavedtable2 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = gsub("\\.", "", zSobj[jj]), 
                    AgeCutoff = paste0("DaysAbsentEnrollersOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 2)
                    )
                  write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable1, "\n")
                  cat("Table saved as", pathtosavedtable2, "\n")
                } else {
                  # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                  # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                  iispace <- which(
                    # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                    grepl(".", tbest[[1]]) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                    )
                  iispace2 <- iispace[seq(2, length(iispace), 2)]
                  # adjlskiprows = c(iispace, iispace+1)
                  # saveEstTable is in functions.R
                  # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                  tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest[[1]]),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth-.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = c(iispace, iispace+1),
                    alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows <- grep("nteract.*\\d", tbl)
                  for (ir in InterRows)
                    if (any(grepl("rowcolor", tbl[ir])))
                      tbl[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          ) else
                        # rows without rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          )
                  # file path to saved table
                  pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                    Sample = gsub("\\.", "", zSobj[jj]), 
                    AgeCutoff = paste0("DaysAbsentEnrollersOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                  write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable, "\n")
                } # If: DivInto2Tables ends
              } # cl: SE clustering choice ends
            }  # m: ag HH definitions
          } # ge: gender
        }  # j: z2 (incl. extended) or z3 (nuclear)
      }  # s: upperbound age cutoffs (10, 15)
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
library(qs)
qsave(results, paste0(pathsaveThisVer, "DID_DaysAbsentEnrollersGenderResults.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "DID_N_DaysAbsentEnrollersGenderResults.qs"))
DaysAbsent <- data.table(DaysAbsent)
DaysAbsentchg <- data.table(DaysAbsentchg)
setnames(DaysAbsentchg, c("sample", "HHtype", "agHHdef", "demean", "gender", "agelb", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue")[-4])
setnames(DaysAbsent, c("sample", "HHtype", "agHHdef", "demean", "gender", "agelb",
   "agHH", "tee", "rate", "Obs")[-4])
qsave(DaysAbsent, paste0(pathsaveThisVer, "DaysAbsentEnrollersGender.qs"))
qsave(DaysAbsentchg, paste0(pathsaveThisVer, "DaysAbsentchgEnrollersGender.qs"))
@

<<days absent of enrollers cross section, eval = F, results = 'hide', cache = F>>=
library(clubSandwich)
clusterlevel <- "thana"
DivInto2Tables <- T
SkipLowerBound <- 40
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
samples <- c("main", "placebo")
z23 <- c("z2", "z3")
zsobj <- c("zmobjDays", "zpobjDays")
zmobjDays <- c("zEm.1999", "zSm.1999")[1]
zpobjDays <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999")[1]
cohort.years.list <- list(# year age is defined
  main = rep(1999, 2), 
  placebo = c(rep(2002, 1), rep(1999, 1))
  )
cutout.years<- c(rep(2006, 1), rep(1999, 1), rep(2006, 1)) # year to drop in data, main = 2006, placebo 1999
# Used in "interaction with year InterYears" in results table
InterYearsList <- list(main = rep(2002, 1), placebo = rep(c(2006, 2002), each = 2))
regressors.list <- list(
  main = regressorsM,
  placebo = regressorsM2002
)
variables.always.use <- "^DaysAbsent$|^agHH$|^thana$|uniqu"
yrXs <- c("yr2", "yr3")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
)
boxWidth <- 4
centerWidth <- 1.3
DaysAbsent <- DaysAbsentchg <- CIs <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  # take away all .yr2$ and .*2 from regressorsS
  regressorsS <-  regressors.list[[ii]]
  regressorsS <- gsub("\\.yr.|\\.\\*yr[23]", "", regressorsS)
  regressorsS <- gsub("\\.\\*[23]", "", regressorsS)
  regressorsS <- gsub("\\$", "", regressorsS)
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  var.always.use <- gsub("yr[23]", yrXs[ii], variables.always.use)
  reorder <- reorder.list[[ii]]
  sampleyears <- list(c(1999, 2002), c(2002, 2006))[[ii]]
  regsnd <- rep("DaysAbsent", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  # Use satterthwaite only.
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  res <- list("1999" = res, "2002" = res) # yy, cross section year
  # res[[s]][[j]][[ge]][[m]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  for (jj in 1) {
    results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    # ss == 2: enrolled in 1999 and 2002. Number of grade progression?
    z01[, ss := cumsum(schoolp), by = uniquid]
    z01[, ss := ss[2], by = uniquid]
    for (rr in 1:2) {
      # Choose year
      for (yy in 1:2) {
        z02 = copy(z01[survey == sampleyears[yy] & schoolp == 1 & ss>=rr & 
          !is.na(sp.edulevel.primary) & !is.na(sp.edulevel.secondary) & !is.na(pcland), ])
          z1 = copy(z02)
          z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
    #       # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
    #       setnames(z1, 
    #         grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
    #         gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
    #       z1[, grepout("^UD", colnames(z1)) := NULL]
    #       setnames(z1, 
    #         grepout("^ud", colnames(z1)),
    #         gsub("ud", "UD", grepout("^ud", colnames(z1))))
          tabextend <- c("yes", "", "yes", "")
          tabcohortdemeaned <- c("", "yes", "", "yes")
          for (s in 1:3)
          #  choice of age cutoff
          {
            s0 <- (10:12)[s]
            if (ii == 2 & jj == 5) {
              s0 <- 6
              MaxAge <- 9
            } else {
              MaxAge <- 18
            }
            i <- paste0("older", s0)
            # latter panel: 5 <= age < s0 in 1999/2002
            iiid <- unique(z1[
              s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
              eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
              #maxAge
              , uniquid])
            # Keep only former complete panel and respective years.
            z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
            z2[, grepout("exist|In", colnames(z2)) := NULL]
            z2 <- dropunbalanced(z2, returnDT = T)
            # z3: nuclear family
            z3 <- z2[sd == 1, ]
            z3 <- dropunbalanced(z3, returnDT = T)
            cat("\n\nage cutoff:", i, "\n\n")
            print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
            cat("dimension of original z1:", dim(z1), "\n")
            cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
            dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
            cat("dimension of z2 after keeping only balanced portion:", 
            dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
            cat("number of individuals in the panel:")
            print(table(table(z2[, uniquid])))
            cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
            cat("first-diffference estimator\n")
            for (j in 2) {
              zz00 = copy(get(z23[j]))
              for (ge in 1:3) {
                if (ge == 1) {
                  zz0 = copy(zz00[UDsex <= 0, ]) 
                  zz0[, grepout("^sex", colnames(zz0)) := NULL]
                } else  if (ge == 2){
                  zz0 = copy(zz00[sex > 0, ])
                  zz0[, grepout("^sex", colnames(zz0)) := NULL]
                } else zz0 = copy(zz00)
                if (nrow(zz0) < SkipLowerBound) {
                  cat("Skipped due to small number of obs:", nrow(zz0), "\n")
                  next
                }
                setkey(zz0, uniquid, survey)
                zz0[, survey := NULL]
                for (m in 1:length(aghh.defs)) {
                  zz = copy(zz0)
                  # Use a particular agHH definition.
                  # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
                  setnames(zz, 
                    grepout(aghh.defs[m], colnames(zz))
                    ,
                    gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
                  )
                  # drop other ag HH definitions
                  zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
                  zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
                  zz[, grepout(paste0("^UD", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
                  # Create X.agHH terms
                  # add sex as covariate for UDTerms to have corresponding DemeanedTerms
                  zz[, sex := UDsex - mean(UDsex)]
                  # 1. Extract interaction terms
                  yrXTerms <- grepout("\\.yr.$", colnames(zz))
                  agIntTerms <- gsub("\\.yr.", "", grepout("\\.ag.*?\\.yr", yrXTerms))
                  agIntHead <- gsub("\\.agHH", "", agIntTerms)
                  UDagIntHead <- paste0("UD", agIntHead)
                  UDagIntTerms <- paste0("UD", agIntTerms)
                  # 2. Create UDagIntTerms (undemeaned interaction) UDX.agHH0 terms
                  zz[, (UDagIntTerms) := NA]
                  # agHH def is already demeaned
                  zz[, agHH := as.integer(agHH>0)]
                  for (v in 1:length(UDagIntTerms))
                    set(zz, j = UDagIntTerms[v], value = zz[[UDagIntHead[v]]]*zz[["agHH"]])
                  # 4. Create demeaned X terms
                  # Restore demeaned terms to form demeaned interactions
                  # (Also demean agHH def which is included in DemeanedTerms)
                  for (v in 1:length(UDagIntHead))
                    set(zz, j = agIntHead[v], 
                      value = zz[[UDagIntHead[v]]]-mean(zz[[UDagIntHead[v]]]))
                  # 4. Create agIntTerms (demeaned X.agHH terms)
                  zz[, (agIntTerms) := NA]
                  for (v in 1:length(agIntTerms))
                    set(zz, j = agIntTerms[v], value = zz[[agIntHead[v]]]*zz[["agHH"]])
                  # drop yrX terms
                  zz[, grepout("\\.yr.$", colnames(zz)) := NULL]
                  ns <- Rs <- NULL
                  resul <- est <- vector("list", length = length(regressorsS))
                  for (k in 1:length(regressorsS)) {
                    if (s0 == 10 & j == 1 & m == 1) {
                      cat(paste0("(", k, ")\n"))
                      print0(paste0("+ ", 
                        grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                    }
                    regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                    covariates <- grepout(
                      paste(var.always.use, regrsr, sep = "|", collapse = "|")
                      , colnames(zz))
                    zr <- zz[, covariates, with = F]
                    RHS <- covariates[!grepl("^uniquid$|^thana$|^DaysAbsent$|^UD", covariates)]
                    form <- as.formula(paste0(regsnd[k], "~", paste(RHS, collapse = "+")))
                    rsl <- lm(data=data.frame(zr), form)
                    estres <- clubSandwich::coef_test(rsl, vcov = "CR2", 
                      cluster = as.numeric(zr[, thana]), test = "Satterthwaite")
                    estres <- as.data.frame(estres)
                    estres <- estres[, -1]
                    estci <- clubSandwich::conf_int(rsl, vcov = "CR2", level = 0.95, 
                      test = "Satterthwaite", cluster = as.numeric(zr[, thana]), coefs = "All", p_values = T)
                    estci <- as.data.frame(estci)
                    colnames(estres)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                    estresLZ <- clx(rsl, cluster = matrix(as.numeric(zr[, thana])), 
                      returnV = T, deviation = F)
                    enrr <- zr[, .(MeanDaysAbsent = mean(DaysAbsent), Num = .N), by = agHH]
                    resul[[k]] <- 
                      list(est = summary(rsl)$coeff, estBRL = estres, ciBRL = estci,
                        estLZ = estresLZ$est, ciLZ = estresLZ$ci,
                        df = rsl$df.residual, reg = rsl, 
                        R = summary(rsl)$adj.r, n = nrow(rsl$model),
                        rate = enrr, level.data = zr)
                    est[[k]] <- round(estres[, -3], 5)
                    Rs <- c(Rs, summary(rsl)$adj.r)
                    ns <- c(ns, nrow(rsl$model))
                  }
                  results0[[jj]][[yy]][[s]][[j]][[ge]][[m]] <- resul
                  ciBRL <- lapply(resul, "[[", "ciBRL")
                  ciBRL <- lapply(ciBRL, as.matrix)
                  ciBRL <- lapply(ciBRL, function(x) as.data.table(x[, ]))
                  ciBRL <- lapply(1:length(ciBRL), function(i) ciBRL[[i]][, reg := i])
                  dfs <- lapply(resul, "[[", "df")
                  ciBRL <- lapply(1:length(ciBRL), function(i) ciBRL[[i]][, df := dfs[[i]]])
                  ciBRL <- lapply(1:length(ciBRL), function(i) ciBRL[[i]][, n := ns[i]])
                  ciBRL <- lapply(1:length(ciBRL), function(i) ciBRL[[i]][, R2 := Rs[i]])
                  ciBRL <- rbindlist(ciBRL, use.names = T, fill = T)
                  ciBRL[, inference := "BRL"]
                  setcolorder(ciBRL,  c("reg", "n", "df", "R2", "inference", "Coef", "beta", "SE", "p_val", "CI_L", "CI_U"))
                  esp <- lapply(resul, "[[", "ciLZ")
                  esp <- lapply(esp, as.matrix)
                  esprn <- unlist(lapply(esp, rownames))
                  esp <- lapply(esp, function(x) as.data.table(x[, ]))
                  esp <- lapply(1:length(esp), function(i) esp[[i]][, reg := i])
                  dfs <- lapply(resul, "[[", "df")
                  esp <- lapply(1:length(esp), function(i) esp[[i]][, df := dfs[[i]]])
                  esp <- lapply(1:length(esp), function(i) esp[[i]][, n := ns[i]])
                  esp <- lapply(1:length(esp), function(i) esp[[i]][, R2 := Rs[i]])
                  esp <- rbindlist(esp, use.names = T, fill = T)
                  if (any(grepl("z value", colnames(esp)))) esp[, "z value" := NULL]
                  estlz <- lapply(resul, "[[", "estLZ")
                  estlz <- lapply(estlz, as.matrix)
                  estrn <- unlist(lapply(estlz, rownames))
                  estlz <- lapply(estlz, function(x) as.data.table(x[, ]))
                  estlz <- rbindlist(estlz, use.names = T, fill = T)
                  ciLZ <- cbind(Coef = estrn, estlz, esp)
                  setnames(ciLZ,  c("Coef", "beta", "SE", "t", "p_val", "CI_L", "CI_U", "reg", "df", "n", "R2"))
                  ciLZ[, t := NULL]
                  ciLZ[, inference := "LZ"]
                  cis <- rbindlist(list(ciBRL, ciLZ), use.names = T)
                  cis[, data := zSobj[jj]]
                  cis[, HHtype := c("all", "direct")[j]]
                  cis[, agdef := aghh.defs[m]]
                  cis[, agelb := s0]
                  cis[, year := sampleyears[yy]]
                  cis[, sample := c("contemporaneous", "all time")[rr]]
                  cis[, gender := genderitems[ge]]
                  CIs <- rbind(CIs, cis)
                  enrr <- zr[, .(MeanDaysAbsent = mean(DaysAbsent), Num = .N), by = agHH]
                  DaysAbsent <- rbind(DaysAbsent, 
                    cbind(zSobj[jj], c("all", "nuclear")[j], 
                      sampleyears[yy], c("contemporaneous", "all time")[rr],
                      c("default", aghh.defs[-1])[m], 
                      c("boys", "girls", "boys+girls")[ge],
                      s0, enrr),
                    use.names = F
                  )
                  # Save mean progression rate changes
                  # x: agHH, y: nonagHH
                  ttestE <- t.test(zr[agHH == 1L, DaysAbsent], zr[agHH == 0L, DaysAbsent])
                  DaysAbsentchg <- rbind(DaysAbsentchg, 
                    cbind(
                        zSobj[jj], c("all", "nuclear")[j], 
                        sampleyears[yy], c("contemporaneous", "all time")[rr],
                        c("default", aghh.defs[-1])[m], 
                        c("boys", "girls", "boys+girls")[ge],
                        s0, round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                        t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                        )
                      )
                }  # m: ag HH definitions
              } # ge: gender
            }  # j: z2 (incl. extended) or z3 (nuclear)
          }  # s: upperbound age cutoffs (10, 15)
      } # yy: 1999 or 2002
    } # rr: 1 contemporanesou enroller or 2 all time enroller
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
setcolorder(CIs,  c("data", "sample", "year", "HHtype", "agdef", "agelb", "gender", "reg", "n", "df", "R2", "inference", 
   "Coef", "beta", "SE", "p_val", "CI_L", "CI_U"))
thesecols <- c("n", "df", "R2", "beta", "SE", "p_val", "CI_L", "CI_U")
CIs[, (thesecols) := lapply(.SD, as.numeric), .SDcols = thesecols]
thesecols <- colnames(CIs)[!colnames(CIs) %in% thesecols]
CIs[, (thesecols) := lapply(.SD, as.factor), .SDcols = thesecols]
library(qs)
qsave(results, paste0(pathsaveThisVer, "DID_DaysAbsentCrossSection_results.qs"))
qsave(CIs, paste0(pathsaveThisVer, "DID_DaysAbsentCrossSection_CIs.qs"))

CIs[grepl("Em", data) & grepl("4|5|7", reg) & grepl("^agH", Coef) & grepl("all", sample) & grepl(9, year) &
  agelb == 10 & grepl("B", inference) & grepl("s.g", gender), ]

DaysAbsent <- data.table(DaysAbsent)
DaysAbsentchg <- data.table(DaysAbsentchg)
setnames(DaysAbsentchg, c("data", "HHtype", "year", "sample", "agHHdef", 
  "gender", "agelb", "AgNonag", "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(DaysAbsent, c("data", "HHtype", "year", "sample", "agHHdef", "gender", "agelb",
   "agHH",  "rate", "Obs"))
DaysAbsent[, gender := factor(gender, levels=genderitems)]
DaysAbsent[, agHHdef := factor(agHHdef, levels=aghh.defs)]
qsave(DaysAbsent, paste0(pathsaveThisVer, "DaysAbsentCrossSection.qs"))
qsave(DaysAbsentchg, paste0(pathsaveThisVer, "DaysAbsentchgCrossSection.qs"))
@

<<tabulate grade absent by gender results, eval = F>>=
# grades: results[[ii]][[jj]][[ge]][[s]][[j]][[m]][[clnum]][[k]]
resultsGG <- qread( paste0(pathsaveThisVer, "DID_NumGradesEnrollersGenderResults.qs"))
# days absent: results[[ii]][[jj]][[ge]][[s]][[j]][[m]][[clnum]][[k]]
resultsDE <- qread(paste0(pathsaveThisVer, "DID_DaysAbsentEnrollersGenderResults.qs"))
#resultsDN <- qread(paste0(pathsaveThisVer, "FD_N_DaysAbsentGenderCRCoV_results.qs"))
# G: 1, D: 2, GE: 3, GIE: 4, DE: 5
# GG: en: 1=initial enrollers, 2=all time enrollers
# G: 1, D: 2, GG[[2]] all time: 3, GG[[1]] initial: 4, DE: 5
zsobj <- c("zmobj", "zpobj")
zmobj <- "zEm.1999"
zpobj <- c("zEp.2002", "zEp.1999")
eGD <- NR <- Enr <- NULL
for (gd in 1:3) {   
  for (ii in 1) {
    zSobj <- get(zsobj[[ii]])
    for (jj in 1:length(zSobj)) {
      thisdata <- zSobj[[jj]]
      for (s in 1:3) {
        for (j in 1:2) {
          for (ge in 1:3) {
            for (m in 1:4) {
              for (clnum in 1:2) {
                if (gd == 1)  {
                  # grades, initial enrollers
                  estGDs1 <- resultsG[[ii]][[jj]][[1]][[s]][[j]][[ge]][[m]][[clnum]]
                } else if (gd == 2) { # all time enrollers
                  # grades, all time enrollers
                  estGDs1 <- resultsG[[ii]][[jj]][[2]][[s]][[j]][[ge]][[m]][[clnum]]
                } else if (gd == 3) { 
                  # days absent, all time enrollers
                  estGDs1 <- resultsD[[ii]][[jj]][[s]][[j]][[ge]][[m]][[clnum]]
                }
                estGDs <- lapply(estGDs1, "[[", "ci")
                estGDs <- lapply(estGDs, data.table)
                estGDs <- lapply(1:length(estGDs), function(i) estGDs[[i]][, reg := i])
                estGDs <- rbindlist(estGDs)
                # if clnum == 1, estFM only contain CIs
                if (clnum == 1) {
                  esp <- lapply(estGDs1, "[[", "est")
                  esp <- lapply(esp, as.matrix)
                  esprn <- unlist(lapply(esp, rownames))
                  esp <- lapply(esp, function(x) as.data.table(x[, ]))
                  dfs <- lapply(lapply(estGDs1, "[[", "est"), function(x) attributes(x)$df)
                  esp <- lapply(1:length(esp), function(i) esp[[i]][, df := dfs[[i]]])
                  esp <- rbindlist(esp, use.names = T, fill = T)
                  if (any(grepl("z value", colnames(esp)))) esp[, "z value" := NULL]
                  estGDs <- cbind(Coef = esprn, esp, estGDs)
                  setnames(estGDs,  c("Coef", "beta", "SE", "t", "p_val", "df", "CI_L", "CI_U", "reg"))
                  estGDs[, t := NULL]
                }
                setcolorder(estGDs,  c("Coef", "beta", "SE", "df", "p_val", "CI_L", "CI_U", "reg"))
                estGD <- estGDs
                estGD[, file := c("grade", "absent", "grade enr", "grade initial enr", "absent enr")[gd]]
                estGD[, agelb := (10:12)[s]]
                estGD[, agdef := aghh.defs[m]]
                estGD[, HHtype := c("all", "direct")[j]]
                estGD[, inference := c("LZ", "BRL")[clnum]]
                estGD[, gender := genderitems[ge]]
                estGD[, data := thisdata]
                eGD <- rbind(eGD, estGD)
                # n and R2
                nR <- lapply(lapply(estGDs1, "[[", "reg"), 
                  function(x) t(c(length(summary(x)$res), summary(x)$r.sq)))
                nR <- lapply(nR, data.table)
                nR <- lapply(1:length(nR), function(i) nR[[i]][, reg := i])
                nR <- rbindlist(nR)
                nR[, file := c("grade", "absent", "grade enr", "grade initial enr", "absent enr")[gd]]
                nR[, agelb := (10:12)[s]]
                nR[, agdef := aghh.defs[m]]
                nR[, HHtype := c("all", "direct")[j]]
                nR[, gender := genderitems[ge]]
                nR[, data := thisdata]
                setnames(nR, paste0("V", 1:2), c("n", "R"))
                nR[, n := formatC(n, digits = 0, format = "f")]
                nR[, R := formatC(R, digits = 4, format = "f")]
                NR <- rbind(NR, nR)
                # treated and control means
                zid <- lapply(estGDs1, "[[", "level.data")
                zidd <- lapply(estGDs1, "[[", "diff.data")
                zid <- lapply(1:length(zid), function(i) zid[[i]][uniquid %in% zidd[[i]][, uniquid], ])
                zid <- lapply(zid, function(x) x[eval(parse(text=grepout("agHH$", colnames(x)))) > 0, 
                          agHH := 1L])
                zid <- lapply(zid, function(x) x[eval(parse(text=grepout("agHH$", colnames(x)))) <= 0, 
                          agHH := 0L])
                zid <- lapply(zid, function(x) x[, tee := 1:.N, by = uniquid])
                if (gd %in% c(1, 3, 4)) 
                  lapply(zid, function(x) setnames(x, "NumGrades", "LHS")) else
                  lapply(zid, function(x) setnames(x, "DaysAbsent", "LHS"))
                enr <- lapply(zid, function(x) x[, .(EnRate = mean(LHS), Num = .N), by = .(agHH, tee)])
                enr <- lapply(1:length(enr), function(i) enr[[i]][, spec := i])
                enr <- rbindlist(enr)
                enr[, agelb := (10:12)[s]]
                enr[, agdef := aghh.defs[m]]
                enr[, HHtype := c("all", "direct")[j]]
                enr[, gender := genderitems[ge]]
                enr[, data := thisdata]
                enr[, file := c("grade", "absent", "grade enr", "grade initial enr", "absent enr")[gd]]
                enr <- unique(enr[, spec := NULL])
                Enr <- rbind(Enr, enr)
              } # clnum
            } # m
          } # ge
        } # j
      } # s
    } # jj
  } # ii
} # gd
eGD[, file := factor(file)]
eGD[, reg := factor(reg)]
eGD[, agelb := factor(agelb)]
eGD[, agdef := factor(agdef)]
eGD[, HHtype := factor(HHtype)]
eGD[, inference := factor(inference)]
eGD[, gender := factor(gender, levels = genderitems)]
eGD[, data := factor(data)]
qsave(eGD, paste0(pathsaveThisVer, "GenderGradeDaysAbsentTabulated.qs"))
qsave(NR, paste0(pathsaveThisVer, "GenderGradeDaysAbsentTabulatedNR.qs"))
qsave(Enr, paste0(pathsaveThisVer, "GenderGradeDaysAbsentTabulatedEnr.qs"))
@





\subsection{Subsample estimation: age groups, non Muslims, flood}



\subsubsection{Age wise subsamples}


<<agewise subsample by gender, eval = F, results = 'hide', warning = F, cache = F>>=
library(clubSandwich)
library(fwildclusterboot)
SkipLowerBound <- 40
clusterlevel <- "thana"
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zSm.1999 <- readRDS(paste0(pathsaveThisVer, "zSm1999.rds"))
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zSp.1999 <- readRDS(paste0(pathsaveThisVer, "zSp1999.rds"))
zSp.2002 <- readRDS(paste0(pathsaveThisVer, "zSp2002.rds"))
zYp.1999 <- readRDS(paste0(pathsaveThisVer, "zYp1999.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
zSp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
zf <- unique(zEm.1999[, .(uniquid, AgeGroup1999, Agegroup1999)])
zf[, AgeGroup1999 := droplevels(AgeGroup1999)]
zf[, Agegroup1999 := droplevels(Agegroup1999)]
setkey(zf, uniquid)
ze <- unique(zEm.1999[, .(uniquid, Edu1999)])
ze <- ze[!grepl("other", Edu1999), ]
ze[, Edu1999 := droplevels(Edu1999)]
setkey(ze, uniquid)
z23 <- c("z2", "z3")
# Edu1999 is actual class in 1999 which is not defined for outofschool children.
#    6-10: Primary (primary0103, primary0405)
#  11-13: Junior secondary (secondary 0608)
#  14-15: Secondary (secondary0912)
#  16-17: Higher secondary (secondary0912)
## Age wise agHH.yrX was created in Construct3RoundPanel_JHR.rnw
#  zEm.1999: Main, exist sample.
#  zEp.1999: Placebo, 2002 shocks on 1999 cohort.
#  zEp.2002: Placebo, 2002 shocks on 2002 cohort.
for (zob in c("zEm.1999", "zEp.1999", "zEp.2002")) {
  zdata <- get(zob)
  for (agstring in aghh.defs) {
    for (aa in 6:maxAge) {
      if (grepl("m", zob)) # zEm.1999
      {
        zdata[, dumage := as.numeric(eval(parse(text=paste0("Age==", aa, ""))))]
        zdata[, dumage := dumage - mean(dumage, na.rm = T)]
        zdata[, (paste0("DummyAgeIn1999.", putzeroontop(aa, F, 2), ".yr2")) :=
          eval(parse(text="(survey == 1999)*dumage"))] 
        # agHH.yr2 * dumage
        zdata[, (paste0("DummyAgeIn1999.", putzeroontop(aa, F, 2), ".", agstring, ".yr2")) :=
          eval(parse(text=paste0(agstring, ".yr2*dumage")))] 
      } else if (grepl("p.1", zob)) # zEp.1999
      {
        zdata[, dumage := as.numeric(eval(parse(text=paste0("Age==", aa, ""))))]
        zdata[, dumage := dumage - mean(dumage, na.rm = T)]
        zdata[, (paste0("DummyAgeIn1999.", putzeroontop(aa, F, 2), ".yr3")) :=
          eval(parse(text="(survey == 2002)*dumage"))] 
        zdata[, (paste0("DummyAgeIn1999.", putzeroontop(aa, F, 2), ".", agstring, ".yr3")) :=
          eval(parse(text=paste0(agstring, ".yr3*dumage")))] 
      } else { # zEp.2002
        zdata[, dumage := as.numeric(eval(parse(text=paste0("Age==", aa, ""))))]
        zdata[, dumage := dumage - mean(dumage, na.rm = T)]
        zdata[, (paste0("DummyAgeIn2002.", putzeroontop(aa, F, 2), ".yr3")) :=
          eval(parse(text="(survey == 2002)*dumage"))] 
        zdata[, (paste0("DummyAgeIn2002.", putzeroontop(aa, F, 2), ".", agstring, ".yr3")) :=
          eval(parse(text=paste0(agstring, ".yr3*dumage")))] 
      }
    }
  }
  assign(zob, zdata)
}
zsobj <- c("zEm.1999", "zEp.2002", "zEp.1999")
names(zsobj) <- c("main", "placebo2", "placebo9")
# Data vector elements. 
# Except for Y, each has 3 elements because there are 3 age groupings.
# zEm.1999: 1999 shocks on 1999 cohorts (agewise, AgeGroup, Agegroup)
# zEp.2002: 2002 shocks on 2002 cohorts (agewise, AgeGroup, Agegroup)
# zEp.1999: 2002 shocks on 1999 cohorts (agewise, AgeGroup, Agegroup)
# zYp.1999: 2002 shocks on young 1999 cohorts
cohort.years.list <- list(
    main = 1999
  , placebo2 = 2002
  , placebo9 = 1999
)
# year to drop from data
cutout.years <- c(2006, 1999, 1999, 1999)[-4]
InterYearsList <- list(
    main = 2002
  , placebo2 = 2006
  , placebo9 = 2002
)
yrXs <- c("yr2", "yr3", "yr3")
ShockYears <- c(1999, 2002, 2002)
AGEgrouping <- c("AgeGroup2", "AgeGroup3")
AgeGroup2 <- list(pri=6:10, sec=11:17, coll=18)
AgeGroup3 <- list(young=6:9, junior=10:15, senior=16:18)
  # AgeGroup2 = Agegroup: 6-10, 11-17, above17
  # AgeGroup3 = Agegroup: 6-10, 11-15, above16
variables.always.use <- "schoolp|Enrolled|^agHH.yr2|^agHH$|^thana$|uniqu|^UDO|UDhds"
# year to interact with agHH. yr2 is yr1-yr2 diff, yr3 is yr2-yr3 diff.
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
  , placebo2 = main.reorder.JHR
)
regressors.list <- list(
  main = regressorsM,
  placebo2 = regressorsM2002,
  placebo9 = regressorsM2002
)
# EnrCV.age: enrollment rates by agHH*agegroup*period
# EnrCVchg.age: enrollment rate changes by agHH*agegroup*period
Enr.Agegroup <- Enrchg.Agegroup <- NULL
boxWidth <- 4
centerWidth <- 1.2
old <- F
results <- vector("list", length(zsobj)) # ii
names(results) <- names(zsobj)
for (ii in 1:length(zsobj)) {
  z001 <- changehyphen(get(zsobj[ii]))
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]] # tested on cohort 1999 or cohort 2002
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  reorder <- reorder.list[[ii]]
  yrxYear <- ShockYears[ii] # Supposed shock year: 1999 or 2002
  yrX <- yrXs[ii]  # Supposed shock year in yrY description: yr2 or yr3
  resge <- list(boys = NULL, girls = NULL, "boys+girls" = NULL) # j
  for (ge in 1:3) {
    if (ge == 1) z01 <- z001[sex <= 0, ] else if (ge == 2) z01 <- z001[sex > 0, ] else z01 <- z001
    resdd <- list(demeaned = NULL, undemeaned = NULL)
      z1 = copy(z01)
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      z1[, village := factor(gsub(" ", "", village))]
      z1[, grepout("exist|\\-\\d$|DummyAge", colnames(z1)) := NULL]
      resm <- vector("list", length = length(aghh.defs)) # m
      names(resm) <- aghh.defs
      for (m in 1:4) {
        z11 = copy(z1)
        # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
        setnames(z11, 
          grepout(aghh.defs[m], colnames(z1))
          ,
          gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(z11)))
        )
        # drop other ag HH definition
        z11[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(z11)) := NULL]
        # change yr2 => yr3 if placebo, yr3 => yr2 if main
        var.always.use <- variables.always.use
        if (grepl("yr2", yrX)) 
          var.always.use <- gsub("yr3", "yr2", var.always.use) else
          var.always.use <- gsub("yr2", "yr3", var.always.use)
        z2 <- z11[survey != cutout.year, ]
        # Drop yrX other than yrx
        if (any(grepl(unique(yrXs[yrX != yrXs]), colnames(z2))))
          z2[, grepout(unique(yrXs[yrX != yrXs]), colnames(z2)) := NULL]
        # Do not drop agHH.yrX becase we use it as the regressor of reference category
        z2 <- dropunbalanced(z2, returnDT = T)
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        resj <- vector("list", length = 2) # j
        names(resj) <- c("all", "direct")
        regsnd <- rep("schoolp", length(regressorsS))
        for (j in 1:2) {
          zz0 <- get(z23[j])
          setkey(zz0, uniquid, survey)
          zz = copy(zz0)
          resgg <- vector("list", length = length(AGEgrouping)) # gg
          names(resgg) <- AGEgrouping
          for (gg in 1:length(AGEgrouping)) {
            AGEgroup <- get(AGEgrouping[gg])  # agewise, AgeGroup1, AgeGroup2
            aghhvar <- aghh.defs[1]
            ns <- NULL
            cat("\n\n")
            print0(zSobj[gg])
            cat("\n")
            cat(AGEgrouping[gg])
            cat("\n\n")
            print(grepout("agHH\\.|Age", grepout(var.always.use, colnames(z3))))
            resag <- vector("list", length = length(AGEgroup)) # ag
            names(resag) <-  names(AGEgroup)
            for (ag in 1:length(AGEgroup))
            {
              # target ages: minAge - maxAge in cohort.years
              iiid <- unique(z2[eval(parse(text = paste0("AgeIn", cohort.years))) >= min(AGEgroup[[ag]]) 
                & eval(parse(text = paste0("AgeIn", cohort.years))) <= max(AGEgroup[[ag]]), uniquid]) 
              zzg <- zz[uniquid %in% iiid, ]
              if (nrow(zzg) < SkipLowerBound) {
                cat("Skipped due to small number of obs:", nrow(zzg), "\n")
                next
              }
              ns <- NULL
              resul <- est <- vector("list", length = length(regressorsS))
              for (k in 1:length(regressorsS))
              {
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), colnames(zzg))
                print0(paste0("+ ", grepout(regressorsS[k], colnames(z3))))
                zr <- zzg[, covariates, with = F]
                # source("EstimatorFunctions.R")
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                    clusterstring = clusterlevel, group = "^uniquid$", 
                    NotToBeDifferenced = "^agHH$|^UD|^pc.*[dt]$",
                    intercept = T, PeriodToDropForLC = 2, 
                    TimeVariant = "program|age2|meanY",
                    opposite.time.order = F,
                    TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) 
              zt = copy(zz) # zz is z2/z3
              if (any(grepl("schoolp", colnames(zt)))) setnames(zt, "schoolp", "Enrolled")
              # save mean enrollment rate changes
              zt[, aghh := 1L]
              zt[agHH <= 0, aghh := 0L]
              zt[, tee := 1]
              zt[survey == max(survey), tee := 2]
              enrr <- zt[, .(EnRate = mean(Enrolled), Obs = .N), 
                by = .(aghh, tee)]
              d0 <- zt[aghh == 0L, .(diff = diff(Enrolled)), by = uniquid][, diff]
              d1 <- zt[aghh == 1L, .(diff = diff(Enrolled)), by = uniquid][, diff]
              ttestE <- t.test(d1, d0)
              Enr.Agegroup <- rbind(Enr.Agegroup, 
                cbind(zSobj[jj], aghh.defs[m],  
                  names(resj)[j], AGEgrouping[gg], names(AGEgroup)[ag], names(resge)[ge],
                  enrr)
                , use.names = T, fill = T)
              Enrchg.Agegroup <- rbind(Enrchg.Agegroup, 
                t(c(zSobj[jj], aghh.defs[m], 
                  names(resj)[j], AGEgrouping[gg], names(AGEgroup)[ag], names(resge)[ge],
                  round(-diff(unlist(ttestE["estimate"])), 3),
                  unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                , use.names = F)
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "Enrolled")
              # Drop covariates not used in 1st run for zYp.1999 data, because they are all zero's.
              # Covariates of: AgeIn1999.06, AgeIn1999.07.
              iiAllZero <- sapply(zidd, function(x) all(x == 0))
              zidd <- zidd[, !iiAllZero, with = F]
              zidd[, tee := 1] # redundant but needed in FDestimation.
              res <- vector("list", length(ClusteringMethod)) # ii
              names(res) <- names(ClusteringMethod)
              for (cl in ClusteringMethod[-3]) {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl 
                cat("\n\n###", cl, "###\n\n")
                est <- res <- resul <- vector("list", length = length(regressorsS)) # k
                res <- rep(list(res), length(ClusteringMethod)) # cl: 
                names(res) <- ClusteringMethod
                clnum <- 1 
                if (grepl("satt", cl)) clnum <- 2
                # res[[cl]][[k]]: this is stored for each cl in resge[[ag]]
                # resultsN: raw results (not under same obs)
                for (k in 1:length(regressorsS)) {
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  # var.always.use has level variables used only for destat purpose, so drop them
                  covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)]
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  # zidd took t - (t-1) difference, so schoolp is usually 0 or -1 (1 in 1999, 0 in 2002).
                  # In our estimation, we take (t-1) - t difference.
                  # source("EstimatorFunctions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "Enrolled", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (!is.logical(UseSmallClusterCorrection) && grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (!is.logical(UseSmallClusterCorrection) && grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  res[[clnum]][[k]] <- list(
                    est = rsl$est, ci = rsl$CI,
                    df = rsl$reg$df, reg = rsl$reg,
                    level.data = z2[uniquid %in% zidd[, uniquid], gsub("Enrolled", "schoolp", covariates), with = F], 
                    diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean at baseline" = 
                       rep(formatC(enrr[tee == 1 & aghh == 0, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "control mean at follow up" = 
                       rep(formatC(enrr[tee == 2 & aghh == 0, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at baseline" =
                       rep(formatC(enrr[tee == 1 & aghh == 1, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at follow up" =
                       rep(formatC(enrr[tee == 2 & aghh == 1, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "raw DID" =
                       rep(formatC(
                       enrr[tee == 2 & aghh == 1, EnRate] - enrr[tee == 1 & aghh == 1, EnRate] 
                       -(enrr[tee == 2 & aghh == 0, EnRate] - enrr[tee == 1 & aghh == 0, EnRate]), 
                         digits = 2, format = "f"), length(regressorsS))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "satt"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source("tabulate_est.R")
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, #TableFormat = tabformat,
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears, c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$",
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                  # If base::":"(from, to) error, check reorder.
                # Split a table in to 2 tables
                tbest11 <- tbest[[1]][1:(grep(paste0("inter.*", InterYears, ".*ag"), tbest[[1]])-3)]
                tbest12 <- tbest[[2]][1:(grep(paste0("inter.*", InterYears, ".*ag"), tbest[[1]])-3), ]
                tbest21 <- tbest[[1]][grep(paste0("inter.*", InterYears, ".*ag"), tbest[[1]]):length(tbest[[1]])]
                tbest22 <- tbest[[2]][grep(paste0("inter.*", InterYears, ".*ag"), tbest[[1]]):length(tbest[[1]]), ]
                iispace11 <- which(
                  grepl(".", tbest11) & 
                  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                  )
                if (nrow(tbest12) == max(iispace11)) iispace11 <- iispace11[iispace11 != max(iispace11)]
                iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                iispace21 <- which(
                  grepl(".", tbest21) & 
                  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                  )
                if (nrow(tbest22) == max(iispace21)) iispace21 <- iispace21[iispace21 != max(iispace21)]
                # drop last rows of tbest2 to shrink row space
                iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                if (grepl("Lian", cl)) {
                # ep: 2 rows per estimate
                  AdjustLineSkipRows1 <- iispace11
                  AltColorRows1 <- c(iispace12, iispace12+1)
                  AdjustLineSkipRows2 <- iispace21
                  AltColorRows2 <- c(iispace22, iispace22+1)
                } else {
                # epc, satt: 3 rows per estimate
                  AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                  AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                  AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                  AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                }
                tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                  hleft = "\\hfil\\tiny$", hright = "$", 
                  hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                  delimiterline = NULL, adjustlineskip = "-0.7ex", 
                  adjlskiprows = AdjustLineSkipRows1,
                  alternatecolorManual = AltColorRows1,
                  alternatecolorManualColor = "gray80")
                tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                  estimationspacelast = grep("thana dummi", tbest21),
                  hleft = "\\hfil\\tiny$", hright = "$", 
                  hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                  delimiterline = NULL, adjustlineskip = "-0.7ex", 
                  adjlskiprows = AdjustLineSkipRows2,
                  alternatecolorManual = AltColorRows2,
                  alternatecolorManualColor = "gray80")
                # Modify "interaction with ..." lines to use multicolumn
                InterRows1 <- grep("nteract.*\\d", tbl1)
                InterRows2 <- grep("nteract.*\\d", tbl2)
                for (ir in InterRows1) {
                  if (any(grepl("rowcolor", tbl1[ir])))
                    tbl1[ir] <- 
                      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                      # For rows with rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                        )
                        ) else
                      # For rows without rowcolor command at the end
                    tbl1[ir] <- 
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                        )
                        )
                    # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                    # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                    tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                    tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                    tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                }
                for (ir in InterRows2) {
                  if (any(grepl("rowcolor", tbl2[ir])))
                    tbl2[ir] <- 
                      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                      # For rows with rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                        )
                        ) else
                      # For rows without rowcolor command at the end
                    tbl2[ir] <- 
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                        )
                        )
                    # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                    # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                    tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                    tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                    tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                }
                clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                pathtosavedtable1 <- TabFilePathF(
                  FolderPath = pathsaveThisVer, 
                  Sample = gsub("\\.", "", zSobj[jj]), 
                  AgeCutoff = paste0(AGEgrouping[gg], names(AGEgroup)[ag]),
                  HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                  AgHHDef = "",
                  CRSEMethod = paste0(clCap, 1)
                )
                pathtosavedtable2 <- TabFilePathF(
                  FolderPath = pathsaveThisVer, 
                  Sample = gsub("\\.", "", zSobj[jj]), 
                  AgeCutoff = paste0(AGEgrouping[gg], names(AGEgroup)[ag]),
                  HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                  AgHHDef = "",
                  CRSEMethod = paste0(clCap, 2)
                )
                write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                cat("Table saved as", pathtosavedtable1, "\n")
                cat("Table saved as", pathtosavedtable2, "\n")
              } # cl: SE clustering option
              # res has [[clnum]][[k]] levels for each ag.
              # resag has [[ag]][[clnum]][[k]] levels.
              resag[[ag]] <- res
            } # ag: age group
            # resgg has [[gg]][[ag]][[clnum]][[k]] levels.
            resgg[[gg]] <- resag
          } # gg: AGEgrouping
          # resj has [[j]][[gg]][[ag]][[clnum]][[k]] levels.
          resj[[j]] <- resgg
        } # j: household type
        # resm has [[m]][[j]][[gg]][[ag]][[clnum]][[k]] levels.
        resm[[m]] <- resj
      } # m: agHH def
    # resge has [[ge]][[j]][[gg]][[ag]][[clnum]][[k]] levels.
    resge[[ge]] <- resm
  } # ge: gender: 1 = boys, 2 = girls, 3 = boys+girls
  # results has [[ii]][[ge]][[m]][[j]][[gg]][[ag]][[clnum]][[k]] levels.
  results[[ii]] <- resge
} # ii: main/placebo
library(qs)
qsave(results, paste0(pathsaveThisVer, "DID_SubsampleAgeGroupGenderResults.qs"))
Enr.Agegroup <- data.table(Enr.Agegroup)
Enrchg.Agegroup <- data.table(Enrchg.Agegroup)
setnames(Enrchg.Agegroup, c("sample", "agdef", "HHtype", 
  "AgeGrouping", "ages", "gender",
  "AgNonag", "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(Enr.Agegroup, c("sample", "agdef", "HHtype", "AgeGrouping", 
  "ages", "gender", "agHH", "survey", "rate", "Obs"))
Enr.Agegroup[, gender := factor(gender, levels = genderitems)]
Enr.Agegroup[, ages := factor(ages)]
Enr.Agegroup[, AgeGrouping := factor(AgeGrouping)]
Enr.Agegroup[, HHtype := factor(HHtype)]
Enr.Agegroup[, agdef := factor(agdef)]
Enr.Agegroup[, sample := factor(sample)]
qsave(Enr.Agegroup, paste0(pathsaveThisVer, "Enr.AgegroupGender.qs"))
qsave(Enrchg.Agegroup, paste0(pathsaveThisVer, "Enrchg.AgegroupGender.qs"))
Enr.Agegroup <- qread(paste0(pathsaveThisVer, "Enr.AgegroupGender.qs"))
<<>>=
ThisTheme <- theme(
   axis.text.x = element_text(size = 12, angle = 0, vjust = 1, hjust = .5), 
   axis.text.y = element_text(size = 12), 
   axis.title = element_text(size = 10), 
   strip.text.x = element_text(color = "blue", size = 8, 
     margin = margin(0, 1.25, 0, 1.25, "cm")), 
   strip.text.y = element_text(color = "blue", size = 8, 
     margin = margin(1.5, 0, 1.5, 0, "cm")),
   panel.spacing.x = unit(c(.1), units = "cm"),
   panel.spacing.y = unit(.1, units = "cm"), 
   legend.position = "none")
ThisThemeEnd <- ThisTheme + theme(legend.position="bottom")
@

<<plot gender AgeGroup2, eval = F>>=
library(ggplot2)
Res2 <- qread(paste0(pathsaveThisVer, "TabulatedMainResults2.qs"))
Res2[, gender := factor(gender, levels = genderitems)]
mbga <- Res2[grepl("4|5|7", reg) & grepl("di", HHtype) & grepl("^de", demean) & 
  grepl(0, agdef) & grepl("^agHH.yr2$", Coef), ]
mbga[, hr := paste0(HHtype, "-", reg)]
PointRange <-  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .25))
g <- 
ggplot(data = mbga[grepl("A.*2", agegroup) & !is.na(group), ], 
    aes(x = group, y = beta, group = hr, fill = hr, shape = hr, colour = hr)) + 
  PointRange + ThisTheme + facet_grid( ~ gender) +
  xlab("age groups") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  ThisThemeEnd +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 1),
    fill = guide_legend(title = "regression specifications", nrow = 1),
    shape = guide_legend(title = "regression specifications", nrow = 1)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "GenderAgeGroup2Impacts.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<plot gender AgeGroup3, eval = F>>=
library(ggplot2)
Res2 <- qread(paste0(pathsaveThisVer, "TabulatedMainResults2.qs"))
Res2[, gender := factor(gender, levels = genderitems)]
mbga <- Res2[grepl("4|5|7", reg) & grepl("di", HHtype) & grepl("^de", demean) & 
  grepl(0, agdef) & grepl("^agHH.yr2$", Coef), ]
mbga[, hr := paste0(HHtype, "-", reg)]
g <- 
ggplot(data = mbga[grepl("3", agegroup), ],
    aes(x = group, y = beta, group = hr, fill = hr, shape = hr, colour = hr)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .5)) +
  facet_grid(agdef ~ gender)+
  ThisThemeEnd+
  xlab("age groups") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 1),
    fill = guide_legend(title = "regression specifications", nrow = 1),
    shape = guide_legend(title = "regression specifications", nrow = 1)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "GenderAgegroup3Impacts.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<plot gender older siblings AgeGroup3, eval = F>>=
# Not an interesting nor convincing figure (better if we plot results of 10-18 for boys, 12-18 for girls)
library(ggplot2)
mbga <- qread(paste0(pathsaveThisVer, "MainByGenderAge.qs"))
mbga[, hs := paste0(HHtype, "-", spec)]
mbga[, Sib := gsub("OldSib", "", gsub("\\..*", "", Coef))]
mbga[, gs := paste0(Gender, "-", Sib)]
mbga <- mbga[grepl("3", Agegroup) & grepl("4|5|6", spec) & grepl("Sib.*H.yr2$", Coef), ]
g <- 
ggplot(data = mbga, 
    aes(x = Group, y = beta, group = hs, fill = hs, shape = hs, colour = hs)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .5)) +
  facet_grid(Agdef ~ gs)+
  ThisThemeEnd+
  xlab("age groups") + 
  scale_y_continuous(limits = c(-.75, .5))+
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 1),
    fill = guide_legend(title = "regression specifications", nrow = 1),
    shape = guide_legend(title = "regression specifications", nrow = 1)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "GenderAgegroup3SibInteractionImpacts.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<plot AgeGroup2, eval = F>>=
library(ggplot2)
g <- ggplot(data = MainByAge[grepl("A.*2", Agegroup), ], 
    aes(x = Group, y = beta, group = spec, fill = spec, shape = spec, colour = spec)) + 
  PointRange + ThisTheme + facet_grid(. ~ HHtype) +
  xlab("age groups") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 1),
    fill = guide_legend(title = "regression specifications", nrow = 1),
    shape = guide_legend(title = "regression specifications", nrow = 1)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "AgeGroup2Impacts.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<plot AgeGroup3, eval = F>>=
library(ggplot2)
g <- ggplot(data = MainByAge[grepl("A.*3", Agegroup), ], 
    aes(x = Group, y = beta, group = spec, fill = spec, shape = spec, colour = spec)) + 
  PointRange + ThisTheme + facet_grid(. ~ HHtype) +
  xlab("age groups") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 1),
    fill = guide_legend(title = "regression specifications", nrow = 1),
    shape = guide_legend(title = "regression specifications", nrow = 1)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "AgeGroup3Impacts.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<>>=
Enr.Agegroup <- qread(paste0(pathsaveThisVer, "Enr.Agegroup.qs"))
Enrchg.Agegroup <- qread(paste0(pathsaveThisVer, "Enrchg.Agegroup.qs"))
@


\subsubsection{Non Muslims estimation}

<<non muslim gender, eval = F, results = 'hide', cache = F>>=
# Estimation by main/placebo * aghh.defs * age lb * gender * demeaned/level interaction * HHtype
# with LiangZeger or Satterthwaite CRSEs.
# source(paste0(pathprogram, "PartialFile.R"))
library(clubSandwich)
clusterlevel <- "thana"
DivInto2Tables <- T
regressors.list <- list(
  main = regressorsN,
  placebo = regressorsN2002
)
Enr.Base <- qread(paste0(pathsaveThisVer, "Enr.Base.qs"))
Enrchg.Base <- qread(paste0(pathsaveThisVer, "Enrchg.Base.qs"))
source("TabGeneric.R")
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds")) 
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds")) 
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds")) 
cohort.years.list <- list(# year age is defined
  main = rep(1999, 2), # main: use 1999 age to set age range
  placebo = c(rep(2002, 1), rep(1999, 1))
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
InterYearsList <- list(main = rep(2002, 2), placebo = rep(2006, 2))
yrXs <- c("yr2", "yr3")
variables.always.use <- "schoolp|Enrolled|^agHH.yr2|^agHH$|^thana$|uniqu|^UDnon|^UDfl|^UD.*Sib|^UDhds|^pcland$|^pcnlasset$"
muslim.reorder.JHR = c("^.Inter|^age$|age2|yield|^(any)?prog|^rain|^high|^low|Std|",
    "^agHH.yr\\d$|^nonmuslim.yr\\d$|^nonm.*agH|",
    "^sex.yr\\d$|^...e.*y.yr\\d$|hd.?sex.yr\\d$|Sib..yr\\d$|^pcland.y|^pcnlasset.y|water.y|latrine.y|",
    "^sex.*H.*\\d$|hd.ed.*H.*\\d$|hd.?sex.*H.*\\d$|Sib.*H.yr\\d$|^pcland.*H.*\\d$|^pcnlasset.*H.*\\d$|water.*H.y|latrine.*H.y")
muslim.reorder.JHR <- paste0(muslim.reorder.JHR, collapse = "")
reorder.list <- list(
  main = muslim.reorder.JHR,
  placebo = muslim.reorder.JHR
  )
var.always.use <- "schoolp|Enrolled|^agHH.yr2|^agHH$|^thana$|uniqu|^nonmuslim$|^UD.*Sib|^UDpcland$|^UDpcnlasset$|hdsex$"
boxWidth <- 4
centerWidth <- 1.3
# Below gives: IDinNonMuslimDID14
source(paste0(pathprogram0, "IDinNonMuslimDID14.R"))
z23 <- c("z2", "z3")
samples <- c("main", "placebo")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")[1]
zpobj <- c("zEp.2002", "zEp.1999")
results <- resultsN <- vector("list", length = length(samples)) # ii
names(results) <- names(resultsN) <- samples
Enr.NonMuslim <- Enrchg.NonMuslim <- NULL
SkipLowerBound <- 50
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  yrX <- yrXs[ii]
  var.always.use <- gsub("yr2", yrX, variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("schoolp", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  # res[[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  names(results0) <- names(resultsN0) <- zSobj
  for (jj in 1:length(zSobj)) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
      z1 = copy(z01)
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      tabextend <- c("yes", "", "yes", "")
      tabcohortdemeaned <- c("", "yes", "", "yes")
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      if (ii == 2 & jj == 5) smax <- 1 else smax <- 3
      for (s in 1:smax)
      #  choice of age cutoff
      {
        s0 <- (10:12)[s]
        if (ii == 2 & jj == 5) {
          s0 <- 6
          MaxAge <- 9
        } else {
          MaxAge <- 18
        }
        i <- paste0("older", s0)
        # latter panel: s <= age < maxAge in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
          #maxAge
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        z4 <- z2[sd != 1, ]
        z4 <- dropunbalanced(z4, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
        for (j in 1:length(z23))
        {
          zz00 <- get(z23[j])
          setkey(zz00, uniquid, survey)
          zz00[, survey := NULL]
          for (ge in 1:3)
          {
            if (ge == 1) {
              zz0 = copy(zz00[sex <= 0, ]) 
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else  if (ge == 2){
              zz0 = copy(zz00[sex > 0, ])
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else zz0 = copy(zz00)
            if (nrow(zz0) < SkipLowerBound) {
              cat("Skipped due to small number of obs:", nrow(zz0), "\n")
              next
            }
            for (m in 1:length(aghh.defs))
            {
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              ns <- NULL
              resul <- est <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                # pick covariates for k-th regression: 
                #  paste " ..|.." & "..|.." with collapse = "|"
                #  then use it in grepout
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                # if (ii == 2 & jj == 1)
                #if (grepl("zEp.2|zSp", zSobj[jj]))
                # zEp.2002: UDOldSibF is all 0, UDOldSibM is all 0 but 2 obs, so drop them (and interactions).
                #  covariates <- covariates[!grepl("OldSib", covariates)]
                covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)] # drop real valued level variables
                zr <- zz[, covariates, with = F]
                # source("EstimatorFunctions.R")
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$|^UD|^pc.*[dt]$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   opposite.time.order = F, # Use t - (t-1) diff
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              if (!any(grepl("latrine.agHH.yr|water.agHH.yr", rownames(est[[k]])))) {
                cat(zSobj[jj], "agelb", s0, z234[j], c("boys", "girls", "boys+girls")[ge], 
                  c("demeaned", "undemeaned")[dd], aghh.defs[m], "\n")
                cat("Skipped, some covariates cannot be used due to too small number of obs:", nrow(zr), "\n\n")
                next
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[s]][[j]][[ge]][[m]] <- resul
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex"))
              zidd[, tee := 1]
              zidd[, nonmuslim := as.numeric(eval(parse(text=paste0("nonmuslim.", yrX, ">0"))))]
              enrr <- zid[, .(EnRate = mean(Enrolled), Num = .N), by = .(agHH, nonmuslim, tee)]
              Enr.NonMuslim <- rbind(Enr.NonMuslim, 
                cbind(zSobj[jj], c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("boys", "girls", "boys+girls")[ge], s0, enrr),
                use.names = F
              )
              # Save mean enrollment rate changes
              # x: agHH, y: nonagHH
              if (length(zidd[nonmuslim > 0 & agHH == 0, LHS]) > 1 & 
                length(zidd[nonmuslim > 0 & agHH == 1, LHS]) > 1) {
                ttestE <- t.test(zidd[nonmuslim > 0 & agHH == 1, LHS], zidd[nonmuslim > 0 & agHH == 0, LHS])
                enrch <- t(c(zSobj[jj], group = "nonmuslim",
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("boys", "girls", "boys+girls")[ge], s0,
                    # DID, diff.x, diff.y, CIlower, CIupper, p value
                  round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                  unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
              } else 
                enrch <- t(c(zSobj[jj], group = "nonmuslim",
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("boys", "girls", "boys+girls")[ge], s0,
                    # DID, diff.x, diff.y, CIlower, CIupper, p value
                  rep(NA, 6)))
              enrch <- data.table(enrch)
              Enrchg.NonMuslim <- rbind(Enrchg.NonMuslim, enrch, use.names = F)
              if (length(zidd[nonmuslim <= 0 & agHH == 0, LHS]) > 1 & 
                length(zidd[nonmuslim <= 0 & agHH == 1, LHS]) > 1) {
                ttestE <- t.test(zidd[nonmuslim <= 0 & agHH == 1, LHS], zidd[nonmuslim <= 0 & agHH == 0, LHS])
                enrch <- t(c(zSobj[jj], group = "muslim",
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("boys", "girls", "boys+girls")[ge], s0,
                    # DID, diff.x, diff.y, CIlower, CIupper, p value
                  rep(NA, 6)))
              } else
                enrch <- t(c(zSobj[jj], group = "muslim", 
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("boys", "girls", "boys+girls")[ge], s0,
                  round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                  unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
              enrch <- data.table(enrch)
              Enrchg.NonMuslim <- rbind(Enrchg.NonMuslim, enrch, use.names = F)
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "Enrolled")
              #for (cl in c("LiangZeger", "satterthwaite", "wildclusterboot")) 
              for (cl in c("LiangZeger", "satterthwaite")) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl
                cat("\n\n###", cl, "###\n\n")
                #if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl) & any(grepl("Sib", colnames(zidd)))) {
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  # Julia fails for specification 6 in zEm.1999, zEp.1999, zEp.2002
                  if (grepl("wild", cl) & k == 6) next
                  #if (ii == 1 & grepl("S", zSobj[jj]) & s >= 1 & m == 4 & k >= 5 & grepl("wild", cl)) 
                  #zSm1999FDOlder10Occ
                  #  next
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  # var.always.use has level variables used only for destat purpose, so drop them
                  covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)]
                  # Commented out: Aug 2, 2023 Start
                  #if (grepl("zEp|zSp", zSobj[jj]))
                  #  covariates <- covariates[!grepl("OldSib", covariates)]
                  # Commented out: Aug 2, 2023 End
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  source("EstimatorFunctions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "Enrolled", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  results0[[jj]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                    list(est = rsl$est, ci = rsl$CI,
                      df = rsl$reg$df, reg = rsl$reg,
                      #level.data = leveldata[, gsub("Enrolled", "LHS", covariates), with = F], 
                      level.data = zid, 
                      diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  # Sign reversion is done before FDestimation. Below is redundant.
                  # Take19992002Diff is set to F in "read data chunk" at the beginning
                  # If (t-1) - t difference (opposite time order), signs of yrX cross terms are inverted.
                  #if (Take19992002Diff) est[[k]][grepout("Inter|yr.$", rownames(est[[k]])), c(1, 3)] <- 
                  #  -1 * est[[k]][grepout("Inter|yr.$", rownames(est[[k]])), c(1, 3)]
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsN)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean in 1999, muslim" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0 & nonmuslim == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "control mean in 1999, nonmuslim" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0 & nonmuslim == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "treated mean in 1999, muslim" =
                       rep(formatC(enrr[tee == 1 & agHH == 1 & nonmuslim == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "treated mean in 1999, nonmuslim" =
                       rep(formatC(enrr[tee == 1 & agHH == 1 & nonmuslim == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "change in control mean, nmuslim" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 0 & nonmuslim == 0, EnRate]-
                         enrr[tee == 1 & agHH == 0 & nonmuslim == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "change in control mean, nonmuslim" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 0 & nonmuslim == 1, EnRate]-
                         enrr[tee == 1 & agHH == 0 & nonmuslim == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "change in treated mean, muslim" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 1 & nonmuslim == 0, EnRate]-
                         enrr[tee == 1 & agHH == 1 & nonmuslim == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "change in treated mean, nonmuslim" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 1 & nonmuslim == 1, EnRate]-
                         enrr[tee == 1 & agHH == 1 & nonmuslim == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "raw DID, muslim" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1 & nonmuslim == 0, EnRate] - 
                       enrr[tee == 1 & agHH == 1 & nonmuslim == 0, EnRate] 
                       -(enrr[tee == 2 & agHH == 0 & nonmuslim == 0, EnRate] - 
                         enrr[tee == 1 & agHH == 0 & nonmuslim == 0, EnRate]), 
                         digits = 3, format = "f"), length(regressorsN)),
                     "raw DID, nonmuslim" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1 & nonmuslim == 1, EnRate] - 
                       enrr[tee == 1 & agHH == 1 & nonmuslim == 1, EnRate] 
                       -(enrr[tee == 2 & agHH == 0 & nonmuslim == 1, EnRate] - 
                         enrr[tee == 1 & agHH == 0 & nonmuslim == 1, EnRate]), 
                         digits = 3, format = "f"), length(regressorsN))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "epc"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source(paste0(pathprogram, "tabulate_est.R"))
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, 
                  CIInTinySize = T, 
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$",
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                  # Split a table in to 2 tables
                if (DivInto2Tables) {
                  # Split a table in to 2 tables
                  if (grepl("e[ps]$", OUTformat)) 
                    NumRowsAfterEst <- 2 else 
                    NumRowsAfterEst <- 3
                  tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                  tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                  tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                  tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                  iispace11 <- which(
                    grepl(".", tbest11) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                    )
                  iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                  iispace21 <- which(
                    grepl(".", tbest21) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                    )
                  # drop last rows of tbest2 to shrink row space
                  iispace21 <- iispace21[iispace21 < max(grep("toilet|water|nonla", tbest21))]
                  iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                  if (grepl("e[ps]$", OUTformat)) {
                  # ep, es: 2 rows per estimate
                    AdjustLineSkipRows1 <- iispace11
                    AltColorRows1 <- c(iispace12, iispace12+1)
                    AdjustLineSkipRows2 <- iispace21
                    AltColorRows2 <- c(iispace22, iispace22+1)
                  } else {
                  # epc, esc, satt: 3 rows per estimate
                    AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                    AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                    AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                    AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                  }
                  tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows1,
                    alternatecolorManual = AltColorRows1,
                    alternatecolorManualColor = "gray80")
                  tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest21),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows2,
                    alternatecolorManual = AltColorRows2,
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows1 <- grep("nteract.*\\d", tbl1)
                  InterRows2 <- grep("nteract.*\\d", tbl2)
                  for (ir in InterRows1) {
                    if (any(grepl("rowcolor", tbl1[ir])))
                      tbl1[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl1[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          )
                    # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                    # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                    tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                    tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                    tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                  }
                  for (ir in InterRows2) {
                    if (any(grepl("rowcolor", tbl2[ir])))
                      tbl2[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl2[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          )
                    tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                    tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                    tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                  }
                  clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                  # file path to saved table
                  pathtosavedtable1 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = gsub("\\.", "", zSobj[jj]), 
                    AgeCutoff = paste0("Older", (10:12)[s], "NonMuslim"),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 1)
                    )
                  pathtosavedtable2 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = gsub("\\.", "", zSobj[jj]), 
                    AgeCutoff = paste0("Older", (10:12)[s], "NonMuslim"),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 2)
                    )
                  write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable1, "\n")
                  cat("Table saved as", pathtosavedtable2, "\n")
                } else {
                  # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                  iispace <- which(
                    # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                    grepl(".", tbest[[1]]) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                    )
                  iispace2 <- iispace[seq(2, length(iispace), 2)]
                  # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                  # adjlskiprows = c(iispace, iispace+1)
                  # saveEstTable is in functions.R
                  # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                  tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest[[1]]),
                    hleft = "\\hfil\\tiny$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.5ex", 
                    adjlskiprows = c(iispace, iispace+1),
                    alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                    alternatecolorManualColor = "gray80")
                  if (grepl("Liang", cl))
                    tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                      estimationspacelast = grep("thana dummi", tbest[[1]]),
                      hleft = "\\hfil\\tiny$", hright = "$", 
                      hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                      delimiterline = NULL, adjustlineskip = "-0.5ex", 
                      adjlskiprows = c(iispace),
                      alternatecolorManual = c(iispace2, iispace2+1),
                      alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows <- grep("nteract.*\\d", tbl)
                  for (ir in InterRows)
                    if (any(grepl("rowcolor", tbl[ir])))
                      tbl[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          ) else
                        # rows without rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          )
                  pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                    Sample = gsub("\\.", "", zSobj[jj]), 
                    AgeCutoff = paste0("Older", (10:12)[s], "NonMuslim"),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                  write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable, "\n")
                } # if end: DivInto2Tables
              } # cl: SE clustering option
            }  # m: ag HH definitions
          } # ge: gendered or both gender
        }  # j: z2 (incl. extended) or z3 (nuclear)
      }  # s: lowerbound age cutoffs (10, 11, 12)
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
library(qs)
qsave(results, paste0(pathsaveThisVer, "DID_NonMuslimGenderResults.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "DID_N_NonMuslimGenderResults.qs"))
Enr.NonMuslim <- data.table(Enr.NonMuslim)
Enrchg.NonMuslim <- data.table(Enrchg.NonMuslim)
setnames(Enrchg.NonMuslim, c("sample", "group", "HHtype", "agdef", "demean", "gender", "agelb", 
  "AgNonag", "agHH", "nonagHH", "lb95", "ub95", "pvalue")[-5])
setnames(Enr.NonMuslim, c("sample", "HHtype", "agdef", "demean", "gender", "agelb", 
  "agHH", "nonmuslim", "tee", "rate", "Obs")[-4])
qsave(Enr.NonMuslim, paste0(pathsaveThisVer, "Enr.NonMuslimGender.qs"))
qsave(Enrchg.NonMuslim, paste0(pathsaveThisVer, "Enrchg.NonMuslimGender.qs"))
muslimftnote <- "A first-difference estimator with standard errors clustered at \\textit{thana} level. Non-Muslim dummy variable is interacted with year 2002 dummy and year 2002 * agricultural HH dummy. "
@




\subsubsection{Flooded areas estimation}

<<>>=
thanas <- as.character(lapply(unique(yzw[, thana]), function(x) 
  paste0(toupper(substring(x, 1, 1)), substring(x, 2, 30))))
thanas <- thanas[!grepl("NA", thanas)]
@

Flooded area is defined at thana level. These are \Sexpr{thanas[!grepl("Aailjhar|Chokoria|Kalia|Nilphamary|Mohadebpur", thanas)]}. 
<<flooded gender, eval = F, results = 'hide', message = F, warning = F, cache = F>>=
library(clubSandwich)
library(fwildclusterboot)
clusterlevel <- "thana"
DivInto2Tables <- T
regressors.list <- list(
  main = regressorsF,
  placebo = regressorsF2002
)
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zSm.1999 <- readRDS(paste0(pathsaveThisVer, "zSm1999.rds"))
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zSp.1999 <- readRDS(paste0(pathsaveThisVer, "zSp1999.rds"))
zSp.2002 <- readRDS(paste0(pathsaveThisVer, "zSp2002.rds"))
zYp.1999 <- readRDS(paste0(pathsaveThisVer, "zYp1999.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
zEp.1999[, AgeIn2002 := Age[survey == 2002], by = uniquid]
regsnd <- rep("schoolp", length(regressorsF))
samples <- c("main", "placebo")
z23 <- c("z2", "z3")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")[1]
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999")[c(1, 3)]
cohort.years.list <- list(# year age is defined
  main = rep(1999, 4), # main: use 1999 age to set age range
  placebo = c(rep(2002, 2), rep(1999, 2))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
InterYearsList <- list(# year age is defined
  main = rep(2002, 4), # main: use 1999 age to set age range
  placebo = c(rep(2006, 2), rep(2002, 2))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
variables.always.use <- "schoolp|Enrolled|^agHH.yr2|^agHH$|^thana$|uniqu|tee|^flooded$"
yrXs <- c("yr2", "yr3")
flood.reorder.JHR = c("^.Inter|^age$|age2|yield|^(any)?prog|rain|^high|^low|Std|",
    "^agHH$|^agHH.yr\\d$|^hdagHH.yr\\d$|",
    "fl.*d.y|fl.*H.*\\d$|^sex.yr\\d$|^...e.*y.yr\\d$|hd.?sex.yr\\d$|Sib..yr.$|^pcland.y|^pcnlasset.y|water.yr|latrine.yr|",
    "^sex.*H.*\\d$|hd.ed.*H.*\\d$|hd.?sex.*H.*\\d$|Sib.*H.*yr.$|^pcland.*H.*\\d$|^pcnlasset..*H.*\\d$|water.*H.yr|latrine.*H.yr")
flood.reorder.JHR <- paste(flood.reorder.JHR, collapse = "")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = flood.reorder.JHR
  , placebo = flood.reorder.JHR
)
boxWidth <- 4
centerWidth <- 1.3
Enr.Flood <- Enrchg.Flood <- NULL
table(zEm.1999[, .(aghh = agHH0>0, flooded)])
zFLobj <- c("zEm.1999", "zSm.1999")[1]
var.always.use <- variables.always.use
cohort.years <- c(1999, 1999)
cutout.year <- cutout.years[1]
InterYears <- InterYearsList[[1]]
reorder <- reorder.list[[1]]
results <- resultsN <- vector("list", length = length(samples))
SkipLowerBound <- 50
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  yrX <- yrXs[ii]
  var.always.use <- gsub("yr2", yrX, variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("schoolp", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  # res[[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  names(results0) <- names(resultsN0) <- zSobj
  for (jj in 1:length(zSobj)) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
      z1 = copy(z01)
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      tabextend <- c("yes", "", "yes", "")
      tabcohortdemeaned <- c("", "yes", "", "yes")
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      if (ii == 2 & jj == 5) smax <- 1 else smax <- 3
      for (s in 1:smax)
      {
      #  choice of age cutoff
        s0 <- (10:12)[s]
        if (ii == 2 & jj == 5) {
          s0 <- 6
          MaxAge <- 9
        } else {
          MaxAge <- 18
        }
        i <- paste0("older", s0)
        # latter panel: s <= age < maxAge in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
          #maxAge
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        z4 <- z2[sd != 1, ]
        z4 <- dropunbalanced(z4, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
        for (j in 1:length(z23))
        {
          zz00 = copy(get(z23[j]))
          setkey(zz00, uniquid, survey)
          zz00[, survey := NULL]
          for (ge in 1:3)
          {
            if (ge == 1) {
              zz0 = copy(zz00[sex <= 0, ]) 
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else  if (ge == 2){
              zz0 = copy(zz00[sex > 0, ])
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else zz0 = copy(zz00)
            if (nrow(zz0) < SkipLowerBound) {
              cat("Skipped due to small number of obs:", nrow(zz0), "\n")
              next
            }
            for (m in 1:length(aghh.defs))
            {
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              ns <- NULL
              resul <- est <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                # pick covariates for k-th regression: 
                #  paste " ..|.." & "..|.." with collapse = "|"
                #  then use it in grepout
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                # if (ii == 2 & jj == 1)
                #if (grepl("zEp.2|zSp", zSobj[jj]))
                # zEp.2002: UDOldSibF is all 0, UDOldSibM is all 0 but 2 obs, so drop them (and interactions).
                #  covariates <- covariates[!grepl("OldSib", covariates)]
                covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)] # drop real valued level variables
                zr <- zz[, covariates, with = F]
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$|^UD|^pc.*[dt]$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   opposite.time.order = F, # Use t - (t-1) diff
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              if (!any(grepl("latrine.agHH.yr|water.agHH.yr", rownames(est[[k]])))) {
                cat(zSobj[jj], "agelb", s0, z234[j], c("boys", "girls", "boys+girls")[ge], 
                  c("demeaned", "undemeaned")[dd], aghh.defs[m], "\n")
                cat("Skipped, some covariates cannot be used due to too small number of obs:", nrow(zr), "\n\n")
                next
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[s]][[j]][[ge]][[m]] <- resul
              # First run estimation data is stored in resul.
              # Pick the last item of data list which has the least num of obs. 
              # (This is data to use for all specifications.)
              # zidd: Differenced data of the last item in resul.
              # zid2: Level data to reconstruct and demean interaction terms of covariates.
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) 
              zidd[, tee := 1]
              zidd[, flooded := as.numeric(eval(parse(text=paste0("flooded.", yrX, ">0"))))]
              enrr <- zid[, .(EnRate = mean(Enrolled), Num = .N), by = .(agHH, flooded, tee)]
              Enr.Flood <- rbind(Enr.Flood, 
                cbind(zFLobj[jj], c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                c("boys", "girls", "boys+girls")[ge], s0, enrr),
                use.names = F
              )
              # Save mean enrollment rate changes
              # x: agHH, y: nonagHH
              if (length(zidd[flooded > 0 & agHH == 0, LHS]) > 1 & 
                length(zidd[flooded > 0 & agHH == 1, LHS]) > 1) {
                ttestE <- t.test(zidd[flooded > 0 & agHH == 1, LHS], zidd[flooded > 0 & agHH == 0, LHS])
                enrch <- t(c(zFLobj[jj], group= "flooded",
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("boys", "girls", "boys+girls")[ge], s0,
                    # DID, diff.x, diff.y, CIlower, CIupper, p value
                  round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                  unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
              } else 
                enrch <- t(c(zFLobj[jj], group= "flooded",
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("boys", "girls", "boys+girls")[ge], s0,
                    # DID, diff.x, diff.y, CIlower, CIupper, p value
                  rep(NA, 6)))
              enrch <- data.table(enrch)
              Enrchg.Flood <- rbind(Enrchg.Flood, enrch, use.names = F)
              if (length(zidd[flooded <= 0 & agHH == 0, LHS]) > 1 & 
                length(zidd[flooded <= 0 & agHH == 1, LHS]) > 1) {
                ttestE <- t.test(zidd[flooded <= 0 & agHH == 1, LHS], zidd[flooded <= 0 & agHH == 0, LHS])
                enrch <- t(c(zFLobj[jj], group= "unflooded",
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("boys", "girls", "boys+girls")[ge], s0,
                    # DID, diff.x, diff.y, CIlower, CIupper, p value
                  rep(NA, 6)))
              } else
                enrch <- t(c(zFLobj[jj], group= "unflooded", 
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("boys", "girls", "boys+girls")[ge], s0,
                  round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                  unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
              enrch <- data.table(enrch)
              Enrchg.Flood <- rbind(Enrchg.Flood, enrch, use.names = F)
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "Enrolled")
              #for (cl in c("LiangZeger", "satterthwaite", "wildclusterboot")) 
              for (cl in c("LiangZeger", "satterthwaite")) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl
                cat("\n\n###", cl, "###\n\n")
                #if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl) & any(grepl("Sib", colnames(zidd)))) {
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  # Julia fails for specification 6 in zEm.1999, zEp.1999, zEp.2002
                  if (grepl("wild", cl) & k == 6) next
                  #if (ii == 1 & grepl("S", zSobj[jj]) & s >= 1 & m == 4 & k >= 5 & grepl("wild", cl)) 
                  #zSm1999FDOlder10Occ
                  #  next
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  # var.always.use has level variables used only for destat purpose, so drop them
                  covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)]
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  rsl <- DID2(dX0 = zr, Regressand = "Enrolled", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  results0[[jj]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                    list(est = rsl$est, ci = rsl$CI,
                      df = rsl$reg$df, reg = rsl$reg,
                      #level.data = leveldata[, gsub("Enrolled", "LHS", covariates), with = F], 
                      level.data = zid, 
                      diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean in 1999, unflooded" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0 & flooded == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "control mean in 1999, flooded" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0 & flooded == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "treated mean in 1999, unflooded" =
                       rep(formatC(enrr[tee == 1 & agHH == 1 & flooded == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "treated mean in 1999, flooded" =
                       rep(formatC(enrr[tee == 1 & agHH == 1 & flooded == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "change in control mean, unflooded" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 0 & flooded == 0, EnRate]-
                         enrr[tee == 1 & agHH == 0 & flooded == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "change in control mean, flooded" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 0 & flooded == 1, EnRate]-
                         enrr[tee == 1 & agHH == 0 & flooded == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "change in treated mean, unflooded" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 1 & flooded == 0, EnRate]-
                         enrr[tee == 1 & agHH == 1 & flooded == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "change in treated mean, flooded" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 1 & flooded == 1, EnRate]-
                         enrr[tee == 1 & agHH == 1 & flooded == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "raw DID, unflooded" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1 & flooded == 0, EnRate] - 
                       enrr[tee == 1 & agHH == 1 & flooded == 0, EnRate] 
                       -(enrr[tee == 2 & agHH == 0 & flooded == 0, EnRate] - 
                         enrr[tee == 1 & agHH == 0 & flooded == 0, EnRate]), 
                         digits = 3, format = "f"), length(regressorsS)),
                     "raw DID, flooded" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1 & flooded == 1, EnRate] - 
                       enrr[tee == 1 & agHH == 1 & flooded == 1, EnRate] 
                       -(enrr[tee == 2 & agHH == 0 & flooded == 1, EnRate] - 
                         enrr[tee == 1 & agHH == 0 & flooded == 1, EnRate]), 
                         digits = 3, format = "f"), length(regressorsS))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "epc"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source(paste0(pathprogram, "tabulate_est.R"))
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, 
                  CIInTinySize = T, 
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$",
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                  # Split a table in to 2 tables
                if (DivInto2Tables) {
                  # Split a table in to 2 tables
                  if (grepl("e[ps]$", OUTformat)) 
                    NumRowsAfterEst <- 2 else 
                    NumRowsAfterEst <- 3
                  tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                  tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                  tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                  tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                  iispace11 <- which(
                    grepl(".", tbest11) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                    )
                  iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                  iispace21 <- which(
                    grepl(".", tbest21) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                    )
                  # drop last rows of tbest2 to shrink row space
                  iispace21 <- iispace21[iispace21 < max(grep("toilet|water|nonla", tbest21))]
                  iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                  if (grepl("e[ps]$", OUTformat)) {
                  # ep, es: 2 rows per estimate
                    AdjustLineSkipRows1 <- iispace11
                    AltColorRows1 <- c(iispace12, iispace12+1)
                    AdjustLineSkipRows2 <- iispace21
                    AltColorRows2 <- c(iispace22, iispace22+1)
                  } else {
                  # epc, esc, satt: 3 rows per estimate
                    AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                    AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                    AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                    AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                  }
                  tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows1,
                    alternatecolorManual = AltColorRows1,
                    alternatecolorManualColor = "gray80")
                  tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest21),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows2,
                    alternatecolorManual = AltColorRows2,
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows1 <- grep("nteract.*\\d", tbl1)
                  InterRows2 <- grep("nteract.*\\d", tbl2)
                  for (ir in InterRows1) {
                    if (any(grepl("rowcolor", tbl1[ir])))
                      tbl1[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl1[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          )
                    # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                    # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                    tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                    tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                    tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                  }
                  for (ir in InterRows2) {
                    if (any(grepl("rowcolor", tbl2[ir])))
                      tbl2[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl2[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          )
                    tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                    tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                    tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                  }
                  clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                  # file path to saved table
                  pathtosavedtable1 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = gsub("\\.", "", zSobj[jj]), 
                    AgeCutoff = paste0("Older", (10:12)[s], "Flood"),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 1)
                    )
                  pathtosavedtable2 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = gsub("\\.", "", zSobj[jj]), 
                    AgeCutoff = paste0("Older", (10:12)[s], "Flood"),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 2)
                    )
                  write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable1, "\n")
                  cat("Table saved as", pathtosavedtable2, "\n")
                } else {
                  # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                  iispace <- which(
                    # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                    grepl(".", tbest[[1]]) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                    )
                  iispace2 <- iispace[seq(2, length(iispace), 2)]
                  # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                  # adjlskiprows = c(iispace, iispace+1)
                  # saveEstTable is in functions.R
                  # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                  tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest[[1]]),
                    hleft = "\\hfil\\tiny$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.5ex", 
                    adjlskiprows = c(iispace, iispace+1),
                    alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                    alternatecolorManualColor = "gray80")
                  if (grepl("Liang", cl))
                    tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                      estimationspacelast = grep("thana dummi", tbest[[1]]),
                      hleft = "\\hfil\\tiny$", hright = "$", 
                      hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                      delimiterline = NULL, adjustlineskip = "-0.5ex", 
                      adjlskiprows = c(iispace),
                      alternatecolorManual = c(iispace2, iispace2+1),
                      alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows <- grep("nteract.*\\d", tbl)
                  for (ir in InterRows)
                    if (any(grepl("rowcolor", tbl[ir])))
                      tbl[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          ) else
                        # rows without rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          )
                  pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                    Sample = gsub("\\.", "", zSobj[jj]), 
                    AgeCutoff = paste0("Older", (10:12)[s], "Flood"),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                  write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable, "\n")
                } # if end: DivInto2Tables
              } # cl: SE clustering option
            }  # m: ag HH definitions
          } # ge: gendered or both gender
        }  # j: z2 (incl. extended) or z3 (nuclear)
      }  # s: lowerbound age cutoffs (10, 11, 12)
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
Enr.Flood <- data.table(Enr.Flood)
Enrchg.Flood <- data.table(Enrchg.Flood)
setnames(Enrchg.Flood, c("sample", "group", "HHtype", "agdef", "demean", "gender", "agelb",
  "AgNonag", "agHH", "nonagHH", "lb95", "ub95", "pvalue")[-5])
setnames(Enr.Flood, c("sample", "HHtype", "agdef", "demean", "gender", "agelb", "agHH", 
  "flood", "tee", "rate", "Obs")[-4])
library(qs)
qsave(results, paste0(pathsaveThisVer, "DID_FloodGenderResults.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "DID_N_FloodGenderResults.qs"))
qsave(Enr.Flood, paste0(pathsaveThisVer, "Enr.FloodGender.qs"))
qsave(Enrchg.Flood, paste0(pathsaveThisVer, "Enrchg.FloodGender.qs"))
floodftnote <- "A first-difference estimator with standard errors clustered at \\textit{thana} level. Flood dummy variable is interacted with year 2002 dummy and year 2002 * agricultural HH dummy. "
@




<<tabulate flooded nonmuslim results, eval = F>>=
# Flooded: results[[ii]][[jj]][[s]][[j]][[ge]][[m]][[clnum]][[k]]
resultsF <- qread(paste0(pathsaveThisVer, "DID_FloodGenderResults.qs"))
# Nonmuslims: results[[ii]][[jj]][[s]][[j]][[ge]][[m]][[clnum]][[k]]
resultsM <- qread(paste0(pathsaveThisVer, "DID_NonMuslimGenderResults.qs"))
zsobj <- c("zmobj", "zpobj")
zmobj <- "zEm.1999"
zpobj <- c("zEp.2002", "zEp.1999")
EstFM <- NR <- Enr <- NULL
for (fm in 1:2) {   # flood or muslim
  for (ii in 1) { # main results only
    zSobj <- get(zsobj[[ii]])
    for (jj in 1:length(zSobj)) {
      thisdata <- zSobj[[jj]]
      for (s in 1:3) {
        for (j in 1:2) {
          for (ge in 1:3) {
            for (m in 1:4) {
              for (clnum in 1:2) {
                if (fm == 1)  {
                  estFM1 <- resultsF[[ii]][[jj]][[s]][[j]][[ge]][[m]][[clnum]]
                } else {
                  estFM1 <- resultsM[[ii]][[jj]][[s]][[j]][[ge]][[m]][[clnum]]
                }
                if (all(unlist(lapply(estFM1, is.null)))) next
                estFM <- lapply(estFM1, "[[", "ci")
                estFM <- lapply(estFM, data.table)
                estFM <- lapply(1:length(estFM), function(i) estFM[[i]][, reg := i])
                estFM <- rbindlist(estFM, use.names = T, fill = T)
                # if clnum == 1, estFM only contain CIs
                if (clnum == 1) {
                  esp <- lapply(estFM1, "[[", "est")
                  esp <- lapply(esp, as.matrix)
                  esprn <- unlist(lapply(esp, rownames))
                  esp <- lapply(esp, function(x) as.data.table(x[, ]))
                  dfs <- lapply(lapply(estFM1, "[[", "est"), function(x) attributes(x)$df)
                  esp <- lapply(1:length(esp), function(i) esp[[i]][, df := dfs[[i]]])
                  esp <- rbindlist(esp, use.names = T, fill = T)
                  if (any(grepl("z value", colnames(esp)))) esp[, "z value" := NULL]
                  estFM <- cbind(Coef = esprn, esp, estFM)
                  setnames(estFM,  c("Coef", "beta", "SE", "t", "p_val", "df", "CI_L", "CI_U", "reg"))
                  estFM[, t := NULL]
                }
                estFM[, p_val := round(p_val, 6)]
                estFM[, SE := round(SE, 8)]
                estFM[, inference := c("LZ", "BRL")[clnum]]
                estFM[, gender := genderitems[ge]]
                estFM[, agdef := aghh.defs[m]]
                estFM[, agelb := c(10:12)[s]]
                estFM[, HHtype := c("all", "direct", "exonly")[j]]
                estFM[, data := thisdata]
                estFM[, objective := c("main", "placebo")[ii]]
                estFM[, file := c("flood", "muslim")[fm]]
                setcolorder(estFM,  c("file", "objective", "data", "gender", "agdef", "agelb", "HHtype", 
                  "demean", "Coef", "beta", "SE", "df", "p_val", "CI_L", "CI_U", "reg", "inference")[-8])
                EstFM <- rbindlist(list(EstFM, estFM), use.names = T, fill = T)
                # n and R2
                nR <- lapply(lapply(estFM1, "[[", "reg"), 
                  function(x) t(c(length(summary(x)$res), summary(x)$r.sq)))
                nR <- lapply(nR, data.table)
                nR <- lapply(1:length(nR), function(i) nR[[i]][, spec := i])
                nR <- rbindlist(nR, use.names = T, fill = T)
                nR[, gender := genderitems[ge]]
                setnames(nR, c("n", "R", "spec", "gender"))
                nR[, n := formatC(n, digits = 0, format = "f")]
                nR[, R := formatC(R, digits = 4, format = "f")]
                # number of agHHs
                nR2 <- unique(unlist(lapply(lapply(estFM1, "[[", "diff.data"), 
                  function(x) sum(x[, agHH]>0))))
                if (fm == 1) 
                  nR3 <- unique(unlist(lapply(lapply(estFM1[-1], "[[", "diff.data"), 
                    function(x) sum(x[, paste0("flooded.yr", ii+1), with = F]>0)))) else
                  nR3 <- unique(unlist(lapply(lapply(estFM1[-1], "[[", "diff.data"), 
                    function(x) sum(x[, paste0("nonmuslim.yr", ii+1), with = F]>0))))
                nR[, Yes := formatC(nR2, digits = 0, format = "f")]
                nR[, Ngroup := formatC(nR3, digits = 0, format = "f")]
                nR[, agdef := aghh.defs[m]]
                nR[, agelb := c(10:12)[s]]
                nR[, HHtype := c("all", "direct", "exonly")[j]]
                nR[, data := thisdata]
                nR[, objective := c("main", "placebo")[ii]]
                nR[, file := c("flood", "muslim")[fm]]
                NR <- rbind(NR, nR, use.names = T, fill = T)
                # treated and control means
                zid <- lapply(estFM1, "[[", "level.data")
                zidd <- lapply(estFM1, "[[", "diff.data")
                zid <- lapply(1:length(zid), function(i) zid[[i]][uniquid %in% zidd[[i]][, uniquid], ])
                zid <- lapply(zid, function(x) x[eval(parse(text=grepout("agHH$", colnames(x)))) > 0, 
                          agHH := 1L])
                zid <- lapply(zid, function(x) x[eval(parse(text=grepout("agHH$", colnames(x)))) < 0, 
                          agHH := 0L])
                zid <- lapply(zid, function(x) x[, tee := 1:.N, by = uniquid])
                if (any(grepl("Enrolled", colnames(zid[[1]]))))
                  lapply(zid, function(x) setnames(x, "Enrolled", "schoolp"))
                enr <- lapply(zid, function(x) x[, .(EnRate = mean(schoolp), Num = .N), by = .(agHH, tee)])
                enr <- lapply(1:length(enr), function(i) enr[[i]][, spec := i])
                enr <- rbindlist(enr, use.names = T, fill = T)
                enr[, gender := genderitems[ge]]
                enr[, agdef := aghh.defs[m]]
                enr <- unique(enr[, spec := NULL])
                enr[, agelb := c(10:12)[s]]
                enr[, HHtype := c("all", "direct", "exonly")[j]]
                enr[, data := thisdata]
                enr[, objective := c("main", "placebo")[ii]]
                enr[, inference := c("LZ", "BRL")[clnum]]
                enr[, file := c("flood", "muslim")[fm]]
                Enr <- rbind(Enr, enr, use.names = T, fill = T)
              } # clnum
            } # m
          } # ge
        } # j
      } # s
    } # jj
  } # ii
} # fm
setnames(EstFM, "p_val", "p")
EstFM[, coeff := as.character(NA)]
EstFM[grepl("^agHH.yr.$", Coef), coeff := "main"]
EstFM[grepl("SibF.*H", Coef), coeff := "older female siblings"]
EstFM[grepl("SibM.*H", Coef), coeff := "older male siblings"]
EstFM[, coeff := factor(coeff)]
EstFM[, Coef := factor(Coef)]
EstFM[, inference := factor(inference)]
EstFM[, objective := factor(objective)]
EstFM[, data := factor(data)]
EstFM[, agdef := factor(agdef)]
EstFM[, gender := factor(gender, levels = genderitems)]
EstFM[, HHtype := factor(HHtype)]
EstFM[, file := factor(file)]
NR[, objective := factor(objective)]
NR[, data := factor(data)]
NR[, agdef := factor(agdef)]
NR[, gender := factor(gender, levels = genderitems)]
NR[, HHtype := factor(HHtype)]
NR[, file := factor(file)]
Enr[, inference := factor(inference)]
Enr[, objective := factor(objective)]
Enr[, data := factor(data)]
Enr[, agdef := factor(agdef)]
Enr[, gender := factor(gender, levels = genderitems)]
Enr[, HHtype := factor(HHtype)]
Enr[, file := factor(file)]
qsave(EstFM, paste0(pathsaveThisVer, "TabulatedFloodMuslimResults.qs"))
qsave(Enr, paste0(pathsaveThisVer, "TabulatedFloodMuslimResultsEnr.qs"))
qsave(NR, paste0(pathsaveThisVer, "TabulatedFloodMuslimResultsNR.qs"))
floodftnote <- "A first-difference estimator with standard errors clustered at \\textit{thana} level. Flood dummy variable is interacted with year 2002 dummy and year 2002 * agricultural HH dummy. "
@






