\section{Estimation}

\subsection{Main and placebo estimation}

results
[[ii]][[jj]][[j]][[ge]][[m]][[s]][[k]]\\
ii: main, placebo\\
jj: zE, zS samples\\
j: only nuclear (sd == 1) or include extended (sd == 0)\\
ge: boys, girls, boys+girls\\
m: agHH def\\
s: age cutoff\\
k: specification

Estimation steps:
\begin{enumerate}
\vspace{1.0ex}\setlength{\itemsep}{1.0ex}\setlength{\baselineskip}{12pt}
\item	Use \textsf{DID1} to try all specifications and pick the data matrix that has the smallest number of observations. This data is the estimation data to be used for the all specifications so we get the same number of observations for all specifications. We retrieve the first-differenced estimation data.
	\begin{dinglist}{45}
	\vspace{1.0ex}\setlength{\itemsep}{1.0ex}\setlength{\baselineskip}{12pt}
	\item	A programming note. If taking a first-difference in the conventional way, \textsf{diff} function takes $t-(t-1)$ differences. We want $(t-1)-t$ differences to see how enrollment rates change as time passes.
	\item	If we set \textsf{opposite.time.order==F}, then \textsf{diff} function gives $t-(t-1)$ differences. If a child drops out, then \textsf{LHS} changes from 1 to 0, and a $t-(t-1)$ difference gives $-1$. If the child is from an agricultural household, then \textsf{agHH.yr2} (agHH==1 \& 1999==1) changes from 1 to 0, so the $t-(t-1)$ difference gives $-1$. OLS of $\Delta$\textsf{LHS} on $\Delta$\textsf{agHH.yr2} gives a positive estimate under the maintained hypothesis ``agricultural households experienced a larger drop in enrollment rates.'' 
	\item	To retrieve a negative estimate under the maintained hypothesis, we set \textsf{opposite.time.order==F} in \textsf{DID1} to get $t-(t-1)$ differenced data. On the differenced data we define \textsf{agHH.yr2} as positive, by multiplying \textsf{agHH.yr2} with -1. The same negative multiplication is applied to all other time-varying covariates.
		\begin{itemize}
		\vspace{1.0ex}\setlength{\itemsep}{1.0ex}\setlength{\baselineskip}{12pt}
		\item	A positive \textsf{agHH.yr2} is effectively an agHH * year 2 (2002) dummy. This turns out to be a lexicographically correct definition.
		\end{itemize}
	\end{dinglist}
\item	Use \textsf{DID2} with the first-differenced estimation data. 
\end{enumerate}
AgeIn

The loop structure is given as follows. 
\begin{algorithm}
\For{ii in 1:length(samples)}

\end{algorithm}

Small number of clusters correction for CRSE: BRL \citep{PustejovskyTipton2018} and WCB \citep{CameronGelbachMiller2008}. There are warnings on small number of unique draws in WCB when WCB weight is drawn from a Rademacher distribution. We use Webb weights as suggested by the \textsf{boottest} message. 
% sandwich has a function: vcovBS(reg1, cluster = ~ thana, type = "wild-webb"). Not tested. Can take long.
% Covariates OldSibF, OldSibM, OldSchSibF, OldSchSibM reduces sample size of agHHs. This causes wildbootstrap to give an error for zSm.1999 Aghhdef = occ, older 10, k>=5, zEp.2002, zSp.1999 fwildclusterboot odler 10. zSp.2002. This is because UDOldSibF = 0 for all obs, UDOldSibM = 0 for all but 2 obs. 
<<main and placebo gender BRL WCB, eval = F, results = 'hide', cache = F>>=
# Estimation by main/placebo * aghh.defs * age lb * gender * demeaned/level interaction * HHtype
# with LiangZeger or Satterthwaite CRSEs.
# source(paste0(pathprogram, "PartialFile.R"))
library(clubSandwich)
clusterlevel <- "thana"
DivInto2Tables <- T
source(paste0(pathprogram0, "TabGeneric.R"))
regressors.list <- list(
  main = regressorsM,
  placebo = regressorsM2002
)
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds")) 
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
# non ag HHs have no siblings in agriculture...this is how we defined ag HHs.
zEm.1999[survey==1999 & age>=10 & age<=18, 
  .(AgSibM=mean(UDOldAgSibM, na.rm= T), SibM=mean(UDOldSibM)), by = agHH0]
zSm.1999 <- readRDS(paste0(pathsaveThisVer, "zSm1999.rds")) 
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds")) 
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds")) 
zSp.1999 <- readRDS(paste0(pathsaveThisVer, "zSp1999.rds")) 
zSp.2002 <- readRDS(paste0(pathsaveThisVer, "zSp2002.rds")) 
zYp.1999 <- readRDS(paste0(pathsaveThisVer, "zYp1999.rds")) 
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
zSp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
samples <- c("main", "placebo")
z23 <- c("z2", "z3")
z234 <- c("z2", "z3", "z4")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")[1]
# jj: 1,2 = 10-18 in 2002, 3,4 = 10-18 in 1999, 5 = 6-9 in 1999
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999", "zYp.1999")[c(1, 3)]
cohort.years.list <- list(# year age is defined
  main = rep(1999, 2), # main: use 1999 age to set age range
  placebo = c(rep(2002, 1), rep(1999, 1))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
# Used in "interaction with year InterYears" in results table
InterYearsList <- list(main = rep(2002, 2), placebo = rep(2006, 2))
variables.always.use <- "schoolp|Enrolled|^agHH.yr2|^agHH$|^thana$|uniqu|^UDnon|^UDfl|^UD.*Sib|^UDhds|^pcland$|^pcnlasset$"
yrXs <- c("yr2", "yr3")
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
)
boxWidth <- 4
centerWidth <- 1.3
Enr.Base <- Enrchg.Base <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
names(results) <- names(resultsN) <- samples
ii <- jj <- j <- m <- s <- 1
ii <- 2; jj <- 2
SkipLowerBound <- 40
for (ii in 1:length(samples)) {
#for (ii in 2) {
  zSobj <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  yrX <- yrXs[ii]
  var.always.use <- gsub("yr2", yrX, variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("schoolp", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  # res[[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  names(results0) <- names(resultsN0) <- zSobj
  for (jj in 1:length(zSobj)) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    z1 = copy(z01)
    z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
    tabextend <- c("yes", "", "yes", "")
    tabcohortdemeaned <- c("", "yes", "", "yes")
    # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
    setnames(z1, 
      grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
      gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
    z1[, grepout("^UD", colnames(z1)) := NULL]
    setnames(z1, 
      grepout("^ud", colnames(z1)),
      gsub("ud", "UD", grepout("^ud", colnames(z1))))
    if (ii == 2 & jj == 5) smax <- 1 else smax <- 3
    for (s in 1:smax) {
    #  choice of age cutoff
      s0 <- (10:12)[s]
      if (ii == 2 & jj == 5) {
        s0 <- 6
        MaxAge <- 9
      } else {
        MaxAge <- 18
      }
      i <- paste0("older", s0)
      # latter panel: s <= age < maxAge in 1999/2002
      iiid <- unique(z1[
        s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
        eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
        #maxAge
        , uniquid])
      # Keep only former complete panel and respective years.
      z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
      z2[, grepout("exist|In", colnames(z2)) := NULL]
      z2 <- dropunbalanced(z2, returnDT = T)
      # z3: nuclear family
      z3 <- z2[sd == 1, ]
      z3 <- dropunbalanced(z3, returnDT = T)
      z4 <- z2[sd != 1, ]
      z4 <- dropunbalanced(z4, returnDT = T)
      cat("\n\nage cutoff:", i, "\n\n")
      print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
      cat("dimension of original z1:", dim(z1), "\n")
      cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
      dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
      cat("dimension of z2 after keeping only balanced portion:", 
      dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
      cat("number of individuals in the panel:")
      print(table(table(z2[, uniquid])))
      cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
      cat("first-diffference estimator\n")
      for (j in 1:2) {
        zz00 <- get(z23[j])
        setkey(zz00, uniquid, survey)
        zz00[, survey := NULL]
        for (ge in 1:3) {
          if (ge == 1) {
            zz0 = copy(zz00[sex <= 0, ]) 
            zz0[, grepout("^sex", colnames(zz0)) := NULL]
          } else  if (ge == 2){
            zz0 = copy(zz00[sex > 0, ])
            zz0[, grepout("^sex", colnames(zz0)) := NULL]
          } else zz0 = copy(zz00)
          if (nrow(zz0) < SkipLowerBound) {
            cat("Skipped due to small number of obs:", nrow(zz0), "\n")
            next
          }
          for (m in 1:length(aghh.defs))
          {
            zz = copy(zz0)
            # Use a particular agHH definition.
            # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
            setnames(zz, 
              grepout(aghh.defs[m], colnames(zz))
              ,
              gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
            )
            # drop other ag HH definition
            zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
            zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
            ns <- NULL
            resul <- est <- vector("list", length = length(regressorsS))
            # First run: Estimation loop for getting N (number of obs) and first-differenced data.
            for (k in 1:length(regressorsS))
            {
              if (s0 == 10 & j == 1 & m == 1) {
                cat(paste0("(", k, ")\n"))
                print0(paste0("+ ", 
                  grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
              }
              regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
              # pick covariates for k-th regression: 
              #  paste " ..|.." & "..|.." with collapse = "|"
              #  then use it in grepout
              covariates <- grepout(
                paste(var.always.use, regrsr, sep = "|", collapse = "|")
                , colnames(zz))
              # if (ii == 2 & jj == 1)
              #if (grepl("zEp.2|zSp", zSobj[jj]))
              # zEp.2002: UDOldSibF is all 0, UDOldSibM is all 0 but 2 obs, so drop them (and interactions).
              #  covariates <- covariates[!grepl("OldSib", covariates)]
              covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)] # drop real valued level variables
              zr <- zz[, covariates, with = F]
              # source("EstimatorFunctions.R")
              rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                 clusterstring = clusterlevel, group = "^uniquid$", 
                 NotToBeDifferenced = "^agHH$|^UD|^pc.*[dt]$",
                 intercept = T, 
                 TimeVariant = "program|age2|meanY",
                 PeriodToDropForLC = 2, 
                 # opposite.time.order: set to F to get t-(t-1) difference. 
                 # (to be used in DID2 in the later chunk)
                 # Under F, diff(LHS) = -1 if schoolp 1 (1999) -> 0 (2002).
                 # agHH.yr2 is demeaned interaction (of agHH and yr2=1999 dummies), 
                 #   275 of obs (agHH==0) =  .59 because   -.39  (1999)  ->  .20 (2002)
                 #   407 of obs (agHH==1) = -.401 because  .266 (1999) -> -.135 (2002)
                 # In diff data, ag HH who dropped out: LHS = -1, agHH.yr2 = -.4 => OLS estimate > 0.
                 # A larger drop in LHS (more negative) for agHH == 1 dummy 
                 # needs agHH.yr2 to be defined as a positive value.
                 # Similarly, sex (female) == 1 gives diff(sex.yr2) < 0 for females in t-(t-1) diff. 
                 # X.yr2 needs to be defind as positive. To do so, in DID2, 
                 # one needs to set opposite.time.order = F & all time variant covariates
                 # to be X.yr2 := -1 * X.yr2 [so diff(agHH.yr2) > 0].
                 opposite.time.order = F, # Use t - (t-1) diff
                 TurnFactorToNumeric = T, print.messages = F)
              resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
              #jj: zF, zE, zS
              #s: age cutoff
              #j: nuclear or extended
              #m: agHH def
              #k: specification
              est[[k]] <- round(rs$est[, -3], 5)
              ns <- c(ns, rs$N)
            }
            # If any of latrine or water is not in covariates, do not keep results.
            if (!any(grepl("latrine.agHH.yr|water.agHH.yr", rownames(est[[k]])))) {
              cat(zSobj[jj], "agelb", s0, z234[j], c("boys", "girls", "boys+girls")[ge], 
                aghh.defs[m], "\n")
              cat("Skipped, some covariates cannot be used due to too small number of obs:", nrow(zr), "\n\n")
              next
            }
            # resultsN0: raw results (not under same obs)
            resultsN0[[jj]][[s]][[j]][[ge]][[m]] <- resul
            # First run estimation data is stored in resul.
            # Pick the last item of data list which has the least num of obs. 
            # (This is data to use for all specifications.)
            # zidd: Differenced data of the last item in resul.
            # zid2: Level data to reconstruct and demean interaction terms of covariates.
              # Reconstruct covariates and take demeaned interactions are done in the file below.
              source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) 
            zidd[, tee := 1]
            enrr <- zid[, .(EnRate = mean(Enrolled), Num = .N), by = .(agHH, tee)]
            Enr.Base <- rbind(Enr.Base, 
              cbind(zSobj[jj], c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m], 
                s0, enrr),
              use.names = F
            )
            # Save mean enrollment rate changes
            # x: agHH, y: nonagHH
            if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "Enrolled")
            ttestE <- t.test(zidd[agHH == 1, Enrolled], zidd[agHH == 0, Enrolled])
            Enrchg.Base <- rbind(Enrchg.Base, 
              cbind(
                  zSobj[jj], c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m], 
                  s0, -diff(unlist(ttestE["estimate"])), # -diff = -(y - x) = AgHH - nonagHH
                  t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                  )
                )
            for (cl in c("LiangZeger", "satterthwaite")) 
            {
              Rs <- ns <- NULL
              est <- vector("list", length(regressorsS))
              UseSmallClusterCorrection <- cl
              cat("\n\n###", cl, "###\n\n")
              for (k in 1:length(regressorsS))
              {
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                  colnames(zidd))
                # var.always.use has level variables used only for destat purpose, so drop them
                covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)]
                zr <- zidd[, c(covariates, "tee"), with = F]
                source("EstimatorFunctions.R")
                rsl <- DID2(dX0 = zr, Regressand = "Enrolled", 
                         Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                         TimeVariant = "program|age2|meanY|yield",
                         Exclude = "^agHH$",  
                         SmallClusterCorrection = UseSmallClusterCorrection,
                         return.V = T, print.messages = T)
                if (grepl("satter", UseSmallClusterCorrection)) {
                  # Correct format of estimation results for clubSandwich outputs
                  rsl$est <- as.data.frame(rsl$est)
                  rsl$est <- rsl$est[, -1]
                  colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                } else {
                  # Correct format of estimation results for Liang-Zeger outputs
                  rsl$est <- as.matrix(rsl$est)
                  colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                }
                # results0: results under same obs
                clnum <- 1
                if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                results0[[jj]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                  list(est = rsl$est, ci = rsl$CI,
                    df = rsl$reg$df, reg = rsl$reg,
                    level.data = zid, diff.data = rsl$data)
                est[[k]] <- round(rsl$est[, -3], 5)
                Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                ns <- c(ns, rsl$N)
              } # k: reg specification
              assign(paste0("addthis", j),
                 rbind("\\hspace{.5em}thana dummies" = 
                    paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                   "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                   "n" = ns,
                   "control mean at baseline" = 
                     rep(formatC(enrr[tee == 1 & agHH == 0, EnRate], 
                       digits = 2, format = "f"), length(regressorsS)),
                   "control mean at follow up" = 
                     rep(formatC(enrr[tee == 2 & agHH == 0, EnRate], 
                       digits = 2, format = "f"), length(regressorsS)),
                   "treated mean at baseline" =
                     rep(formatC(enrr[tee == 1 & agHH == 1, EnRate], 
                       digits = 2, format = "f"), length(regressorsS)),
                   "treated mean at follow up" =
                     rep(formatC(enrr[tee == 2 & agHH == 1, EnRate], 
                       digits = 2, format = "f"), length(regressorsS)),
                   "raw DID" =
                     rep(formatC(
                     enrr[tee == 2 & agHH == 1, EnRate] - enrr[tee == 1 & agHH == 1, EnRate] 
                     -(enrr[tee == 2 & agHH == 0, EnRate] - enrr[tee == 1 & agHH == 0, EnRate]), 
                       digits = 2, format = "f"), length(regressorsS))
                 )
              )
              INformat <- "LZ"
              OUTformat <- "ep"
              if (cl == "wildclusterboot") {
                INformat <- "wcb"
                OUTformat <- "epc"
              } else if (cl == "satterthwaite") {
                INformat <- "satt"
                OUTformat <- "epc"
                OUTformat <- "esDoF"
              }
              # Incorporate CI/DoF in table
              # reorder needs to be corrected
              # Tab.Est is in tabulate_est.R
              source("tabulate_est.R")
              source("substitution_table.R")
              tbest <- Tab.Est(est, reorder, output.in.list = T,
                Informat = INformat, Outformat = OUTformat, 
                AddStars = T, 
                CIInTinySize = T, 
                LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$",
                addbottom = get(paste0("addthis", j)), subst.table = sbt)
                # Split a table in to 2 tables
              if (DivInto2Tables) {
                # Split a table in to 2 tables
                if (grepl("e[ps]$", OUTformat)) 
                  NumRowsAfterEst <- 2 else 
                  NumRowsAfterEst <- 3
                tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                iispace11 <- which(
                  grepl(".", tbest11) & 
                  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                  )
                iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                iispace21 <- which(
                  grepl(".", tbest21) & 
                  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                  )
                # drop last rows of tbest2 to shrink row space
                iispace21 <- iispace21[iispace21 < max(grep("toilet|water", tbest21))]
                iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                if (grepl("e[ps]$", OUTformat)) {
                # ep, es: 2 rows per estimate
                  AdjustLineSkipRows1 <- iispace11
                  AltColorRows1 <- c(iispace12, iispace12+1)
                  AdjustLineSkipRows2 <- iispace21
                  AltColorRows2 <- c(iispace22, iispace22+1)
                } else {
                # epc, esc, satt: 3 rows per estimate
                  AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                  AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                  AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                  AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                }
               #source("c:/seiro/settings/Rsetting/functions.R")
                tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                  hleft = "\\hfil\\scriptsize$", hright = "$", 
                  hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                  delimiterline = NULL, adjustlineskip = "-0.7ex", 
                  adjlskiprows = AdjustLineSkipRows1,
                  alternatecolorManual = AltColorRows1,
                  alternatecolorManualColor = "gray80")
                tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                  estimationspacelast = grep("thana dummi", tbest21),
                  hleft = "\\hfil\\scriptsize$", hright = "$", 
                  hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                  delimiterline = NULL, adjustlineskip = "-0.7ex", 
                  adjlskiprows = AdjustLineSkipRows2,
                  alternatecolorManual = AltColorRows2,
                  alternatecolorManualColor = "gray80")
                # Modify "interaction with ..." lines to use multicolumn
                InterRows1 <- grep("nteract.*\\d", tbl1)
                InterRows2 <- grep("nteract.*\\d", tbl2)
                for (ir in InterRows1) {
                  if (any(grepl("rowcolor", tbl1[ir])))
                    tbl1[ir] <- 
                      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                      # For rows with rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                        )
                        ) else
                      # For rows without rowcolor command at the end
                    tbl1[ir] <- 
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                        )
                        )
                  # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                  # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                  tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                  tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                  tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                }
                for (ir in InterRows2) {
                  if (any(grepl("rowcolor", tbl2[ir])))
                    tbl2[ir] <- 
                      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                      # For rows with rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                        )
                        ) else
                      # For rows without rowcolor command at the end
                    tbl2[ir] <- 
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                        )
                        )
                  tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                  tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                  tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                }
                clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                # File paths to saved tables
                pathtosavedtable1 <- TabFilePathF(
                  FolderPath = pathsaveThisVer, 
                  Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                    c("", "Undemeaned")[dd]), 
                  AgeCutoff = paste0("Older", (10:12)[s]),
                  HHType = paste0(c("Boys", "Girls", "")[ge],
                    c("", "Nuclear", "ExOnly")[j]),
                  AgHHDef = c("", "Is", "Hd", "Occ")[m],
                  CRSEMethod = paste0(clCap, 1)
                  )
                pathtosavedtable2 <- TabFilePathF(
                  FolderPath = pathsaveThisVer, 
                  Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                    c("", "Undemeaned")[dd]), 
                  AgeCutoff = paste0("Older", (10:12)[s]),
                  HHType = paste0(c("Boys", "Girls", "")[ge],
                    c("", "Nuclear", "ExOnly")[j]),
                  AgHHDef = c("", "Is", "Hd", "Occ")[m],
                  CRSEMethod = paste0(clCap, 2)
                  )
                write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                cat("Table saved as", pathtosavedtable1, "\n")
                cat("Table saved as", pathtosavedtable2, "\n")
              } else {
                # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                iispace <- which(
                  # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                  grepl(".", tbest[[1]]) & 
                  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                  )
                iispace2 <- iispace[seq(2, length(iispace), 2)]
                # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                # adjlskiprows = c(iispace, iispace+1)
                # saveEstTable is in functions.R
                # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                  estimationspacelast = grep("thana dummi", tbest[[1]]),
                  hleft = "\\hfil\\tiny$", hright = "$", 
                  hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                  delimiterline = NULL, adjustlineskip = "-0.5ex", 
                  adjlskiprows = c(iispace, iispace+1),
                  alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                  alternatecolorManualColor = "gray80")
                if (grepl("Liang", cl))
                  tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest[[1]]),
                    hleft = "\\hfil\\tiny$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.5ex", 
                    adjlskiprows = c(iispace),
                    alternatecolorManual = c(iispace2, iispace2+1),
                    alternatecolorManualColor = "gray80")
                # Modify "interaction with ..." lines to use multicolumn
                InterRows <- grep("nteract.*\\d", tbl)
                for (ir in InterRows)
                  if (any(grepl("rowcolor", tbl[ir])))
                    tbl[ir] <- 
                      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                      # rows with rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                        )
                        ) else
                      # rows without rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                        )
                        )
                pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                  Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                    c("", "Undemeaned")[dd]), 
                  AgeCutoff = paste0("Older", (10:12)[s]),
                  HHType = paste0(c("Boys", "Girls", "")[ge],
                    c("", "Nuclear", "ExOnly")[j]),
                  AgHHDef = c("", "Is", "Hd", "Occ")[m],
                  CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                cat("Table saved as", pathtosavedtable, "\n")
              } # if end: DivInto2Tables
            } # cl: SE clustering option
          }  # m: ag HH definitions
        } # ge: gendered or both gender
      }  # j: z2 (incl. extended) or z3 (nuclear)
    }  # s: lowerbound age cutoffs (10, 11, 12)
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
#    [[ii]][[jj]][[s]][[j]][[ge]][[m]][[clnum]][[k]]
# resultsN: Results under varying number of obs between specifications
#    [[ii]][[jj]][[s]][[j]][[ge]][[m]][[k]]
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
library(qs)
qsave(results, paste0(pathsaveThisVer, "FDMainResults.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "FDNMainResults.qs"))
Enr.Base <- data.table(Enr.Base)
Enrchg.Base <- data.table(Enrchg.Base)
setnames(Enrchg.Base, c("sample", "HHtype", "agHHdef", "demean", "age", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue")[-4])
setnames(Enr.Base, c("sample", "HHtype", "agHHdef", "demean", "age", "agHH", "tee", "rate", "Obs")[-4])
qsave(Enr.Base, paste0(pathsaveThisVer, "Enr.Base.qs"))
qsave(Enrchg.Base, paste0(pathsaveThisVer, "Enrchg.Base.qs"))
@
<<main and placebo gender selected specifications, eval = F, results = 'hide', cache = F>>=
# Estimation by main/placebo * aghh.defs * age lb * gender * demeaned/level interaction * HHtype
# with LiangZeger or Satterthwaite CRSEs.
# source(paste0(pathprogram, "PartialFile.R"))
source(paste0(pathprogram, "EstimatorFunctions.R"))
library(clubSandwich)
clusterlevel <- "thana"
#DivInto2Tables <- T
source(paste0(pathprogram0, "TabGeneric.R"))
regressors.list <- list(
  main = regressorsM,
  placebo = regressorsM2002
)
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds")) 
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
# non ag HHs have no siblings in agriculture...this is how we defined ag HHs.
zEm.1999[survey==1999 & age>=10 & age<=18, 
  .(AgSibM=mean(UDOldAgSibM, na.rm= T), SibM=mean(UDOldSibM)), by = agHH0]
zSm.1999 <- readRDS(paste0(pathsaveThisVer, "zSm1999.rds")) 
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds")) 
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds")) 
zSp.1999 <- readRDS(paste0(pathsaveThisVer, "zSp1999.rds")) 
zSp.2002 <- readRDS(paste0(pathsaveThisVer, "zSp2002.rds")) 
zYp.1999 <- readRDS(paste0(pathsaveThisVer, "zYp1999.rds")) 
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
zSp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
samples <- c("main", "placebo")
z234 <- c("z2", "z3", "z4")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")[1]
# jj: 1,2 = 10-18 in 2002, 3,4 = 10-18 in 1999, 5 = 6-9 in 1999
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999", "zYp.1999")[c(1, 3)]
cohort.years.list <- list(# year age is defined
  main = rep(1999, 2), # main: use 1999 age to set age range
  placebo = c(rep(2002, 1), rep(1999, 1))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
# Used in "interaction with year InterYears" in results table
InterYearsList <- list(main = rep(2002, 2), placebo = rep(2006, 2))
variables.always.use <- "schoolp|Enrolled|LHS|^agHH.yr.|^agHH$|^thana$|uniqu|^UDnon|^UDfl|^UD.*Sib|^UDhds|^pcland$|^pcnlasset$"
yrXs <- c("yr2", "yr3")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
  , main.agewise = mix.reorder("^agHH$|^agH.*2$|^D.*yA.*agHH.yr2$|^D.*yA.*\\.1\\d\\.yr2$|")
  , main.classwise = mix.reorder("^agHH$|^agH.*2$|^D.*yA.*agHH.yr2$|^D.*yA.*\\.1\\d\\.yr2$|^Du.*Ed.*|")
  , placebo.young = mix.reorder("^agHH$|^agHH.yr3$|^hdagHH.yr3$|")
  , placebo.agewise = mix.reorder("^agHH$|^agH.*3$|^D.*yA.*agHH.yr3$|^D.*yA.*\\.1\\d\\.yr3$|")
)
boxWidth <- 4
centerWidth <- 1.3
Enr.Base <- Enrchg.Base <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
names(results) <- names(resultsN) <- samples
ii <- jj <- dd <- m <- s <- 1
j <- 2; ge <- 3
SkipLowerBound <- 40
#for (ii in 1:length(samples)) {
for (ii in 1) {
  zSobj	 <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  yrX <- yrXs[ii]
  var.always.use <- gsub("yr2", yrX, variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("schoolp", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
#  res <- list(demeaned = res, undemeaned = res) # dd, demeaned/level interactions
  # res[[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  names(results0) <- names(resultsN0) <- zSobj
  #for (jj in 1:length(zSobj)) {
  for (jj in 1) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    for (dd in 1) {
      z1 = copy(z01)
      # remove area*agHH.yrX: too much parametrization that loses power and cause an overfit
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      tabextend <- c("yes", "", "yes", "")
      tabcohortdemeaned <- c("", "yes", "", "yes")
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      if (ii == 2 & jj == 5) smax <- 1 else smax <- 3
      for (s in 1)
      #  choice of age cutoff
      {
        s0 <- (10:12)[s]
        if (ii == 2 & jj == 5) {
          s0 <- 6
          MaxAge <- 9
        } else {
          MaxAge <- 18
        }
        i <- paste0("older", s0)
        # latter panel: s <= age < maxAge in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
          #maxAge
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        z4 <- z2[sd != 1, ]
        z4 <- dropunbalanced(z4, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
        for (j in 2)
        {
          zz00 <- get(z234[j])
          setkey(zz00, uniquid, survey)
          zz00[, survey := NULL]
          for (ge in 1:3)
          {
            if (ge == 1) {
              zz0 = copy(zz00[sex <= 0, ]) 
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else  if (ge == 2){
              zz0 = copy(zz00[sex > 0, ])
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else zz0 = copy(zz00)
            if (nrow(zz0) < SkipLowerBound) {
              cat("Skipped due to small number of obs:", nrow(zz0), "\n")
              next
            }
            #for (m in 1:length(aghh.defs))
            for (m in c(1, 3))
            {
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              ns <- NULL
              resul <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                # pick covariates for k-th regression: 
                #  paste " ..|.." & "..|.." with collapse = "|"
                #  then use it in grepout
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                # if (ii == 2 & jj == 1)
                #if (grepl("zEp.2|zSp", zSobj[jj]))
                # zEp.2002: UDOldSibF is all 0, UDOldSibM is all 0 but 2 obs, so drop them (and interactions).
                #  covariates <- covariates[!grepl("OldSib", covariates)]
                covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)] # drop real valued level variables
                zr <- zz[, covariates, with = F]
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$|^UD|^pc.*[dt]$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   # opposite.time.order: set to F to get t-(t-1) difference. 
                   # (to be used in DID2 in the later chunk)
                   # Under F, diff(LHS) = -1 if schoolp 1 (1999) -> 0 (2002).
                   # agHH.yr2 is demeaned interaction (of agHH and yr2=1999 dummies), 
                   #   275 of obs (agHH==0) =  .59 because   -.39  (1999)  ->  .20 (2002)
                   #   407 of obs (agHH==1) = -.401 because  .266 (1999) -> -.135 (2002)
                   # In diff data, ag HH who dropped out: LHS = -1, agHH.yr2 = -.4 => OLS estimate > 0.
                   # A larger drop in LHS (more negative) for agHH == 1 dummy 
                   # needs agHH.yr2 to be defined as a positive value.
                   # Similarly, sex (female) == 1 gives diff(sex.yr2) < 0 for females in t-(t-1) diff. 
                   # X.yr2 needs to be defind as positive. To do so, in DID2, 
                   # one needs to set opposite.time.order = F & all time variant covariates
                   # to be X.yr2 := -1 * X.yr2 [so diff(agHH.yr2) > 0].
                   opposite.time.order = F, # Use t - (t-1) diff
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est, org.data = zz)
                #jj: zF, zE, zS
                #s: age cutoff
                #j: nuclear or extended
                #m: agHH def
                #k: specification
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              if (!any(grepl("latrine.agHH.yr|water.agHH.yr", rownames(est[[k]])))) {
                cat(zSobj[jj], "agelb", s0, z234[j], c("boys", "girls", "boys+girls")[ge], 
                  c("demeaned", "undemeaned")[dd], aghh.defs[m], "\n")
                cat("Skipped, some covariates cannot be used due to too small number of obs:", nrow(zr), "\n\n")
                next
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[s]][[j]][[ge]][[m]] <- resul
              # First run estimation data is stored in resul.
              # Pick the last item of data list which has the least num of obs. 
              # (This is data to use for all specifications.)
              # zidd: Differenced data of the last item in resul.
              # zid2: Level data to reconstruct and demean interaction terms of covariates.
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) 
              zidd[, tee := 1]
              enrr <- zid[, .(EnRate = mean(Enrolled), Num = .N), by = .(agHH, tee)]
              Enr.Base <- rbind(Enr.Base, 
                cbind(zSobj[jj], c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m], 
                  s0, enrr),
                use.names = F
              )
              # Save mean enrollment rate changes
              # x: agHH, y: nonagHH
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "Enrolled")
              ttestE <- t.test(zidd[agHH == 1, Enrolled], zidd[agHH == 0, Enrolled])
              Enrchg.Base <- rbind(Enrchg.Base, 
                cbind(
                    zSobj[jj], c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m], 
                    s0, -diff(unlist(ttestE["estimate"])), # -diff = -(y - x) = AgHH - nonagHH
                    t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                    )
                  )
              #for (cl in c("LiangZeger", "satterthwaite", "wildclusterboot")) 
              for (cl in c("LiangZeger", "satterthwaite")) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl
                cat("\n\n###", cl, "###\n\n")
                #if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl) & any(grepl("Sib", colnames(zidd)))) {
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  # Julia fails for specification 6 in zEm.1999, zEp.1999, zEp.2002
                  if (grepl("wild", cl) & k == 6) next
                  #if (ii == 1 & grepl("S", zSobj[jj]) & s >= 1 & m == 4 & k >= 5 & grepl("wild", cl)) 
                  #zSm1999FDOlder10Occ
                  #  next
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  # var.always.use has level variables used only for destat purpose, so drop them
                  covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)]
                  # Commented out: Aug 2, 2023, start
                  #if (grepl("zEp|zSp", zSobj[jj]))
                  #  covariates <- covariates[!grepl("OldSib", covariates)]
                  # Commented out: Aug 2, 2023, end
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "Enrolled", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  results0[[jj]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                    list(est = rsl$est, ci = rsl$CI,
                      df = rsl$reg$df, reg = rsl$reg,
                      #level.data = leveldata[, gsub("Enrolled", "LHS", covariates), with = F], 
                      level.data = zid, 
                      diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  # Sign reversion is done before DID2. Below is redundant.
                  # Take19992002Diff is set to F in "read data chunk" at the beginning
                  # If (t-1) - t difference (opposite time order), signs of yrX cross terms are inverted.
                  #if (Take19992002Diff) est[[k]][grepout("Inter|yr.$", rownames(est[[k]])), c(1, 3)] <- 
                  #  -1 * est[[k]][grepout("Inter|yr.$", rownames(est[[k]])), c(1, 3)]
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean at baseline" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "control mean at follow up" = 
                       rep(formatC(enrr[tee == 2 & agHH == 0, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at baseline" =
                       rep(formatC(enrr[tee == 1 & agHH == 1, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at follow up" =
                       rep(formatC(enrr[tee == 2 & agHH == 1, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "raw DID" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1, EnRate] - enrr[tee == 1 & agHH == 1, EnRate] 
                       -(enrr[tee == 2 & agHH == 0, EnRate] - enrr[tee == 1 & agHH == 0, EnRate]), 
                         digits = 2, format = "f"), length(regressorsS))
                   )
                )
              } # cl: SE clustering option
            }  # m: ag HH definitions
          } # ge: gendered or both gender
        }  # j: z2 (incl. extended) or z3 (nuclear)
      }  # s: lowerbound age cutoffs (10, 11, 12)
    }  # dd: demeaned/level interaction
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
library(qs)
qsave(results, paste0(pathsaveThisVer, "FDMainSelectedResults.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "FDNMainSelectedResults.qs"))
# results <- qread(paste0(pathsaveThisVer, "FD_MainCRCoVSelected_results.qs"))
# resultsN <- qread(paste0(pathsaveThisVer, "FD_N_MainCRCoVSelected_results.qs"))
Enr.Base <- data.table(Enr.Base)
Enrchg.Base <- data.table(Enrchg.Base)
setnames(Enrchg.Base, c("sample", "HHtype", "agHHdef", "demean", "age", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue")[-4])
setnames(Enr.Base, c("sample", "HHtype", "agHHdef", "demean", "age", "agHH", "tee", "rate", "Obs")[-4])
qsave(Enr.Base, paste0(pathsaveThisVer, "Enr.BaseSelected.qs"))
qsave(Enrchg.Base, paste0(pathsaveThisVer, "Enrchg.BaseSelected.qs"))
ii <- jj <- dd <- s <- m <- 1
j <- clnum <- 2
ge <- 3
rr <- resultsN[[ii]][[jj]][[s]][[j]][[ge]][[m]]
rr <- results[[ii]][[jj]][[s]][[j]][[ge]][[m]][[clnum]]
rbindlist(lapply(lapply(rr, "[[", "est"), function(x) x[grepl("^agH", rownames(x)), ]))
ge <- 1
rr <- results[[ii]][[jj]][[s]][[j]][[ge]][[m]][[clnum]]
rbindlist(lapply(lapply(rr, "[[", "est"), function(x) x[grepl("^agH", rownames(x)), ]))
lapply(lapply(rr, "[[", "level.data"), dim)
lapply(lapply(rr, "[[", "diff.data"), dim)
@
<<replicate earlier results, eval = F, results = 'hide', cache = F>>=
# Dates back to October 2, 2019. (DID14.pdf)
# Uses path0/save/zEm.1999.rds
# Use of Liang Zeger CRSEs. 
# Lack of demeaning in real valued covariates.
# No use of rainfall and siblings. 
# No triple interactions except sex. 
zEm.1999 <- readRDS(paste0(pathsave, "zEm1999.rds")) 
library(clubSandwich)
clusterlevel <- "thana"
DivInto2Tables <- T
source(paste0(pathprogram0, "TabGeneric.R"))
regressors.list <- list(
  main =  
  c("^\\(Interce", indivage22, yield, weather.variables2, 
  hd2, hygiene2, sp2),
  main2 = c("^\\(Interce", 
  paste(indivage22, yield, weathervariables2, sep = "|"),
  nonmuslims2, 
  hd2, hygiene2, sp2, area2)
)
zEm.1999[, agHH0 :=  as.numeric(agHH > 0)]
# non ag HHs have no siblings in agriculture...this is how we defined ag HHs.
zEm.1999[survey==1999 & age>=10 & age<=18, 
  .(AgSibM=mean(UDOldAgSibM, na.rm= T), SibM=mean(UDOldSibM)), by = agHH]
samples <- c("main", "placebo")
z234 <- c("z2", "z3", "z4")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")[1]
# jj: 1,2 = 10-18 in 2002, 3,4 = 10-18 in 1999, 5 = 6-9 in 1999
cohort.years.list <- list(# year age is defined
  main = 1999, # main: use 1999 age to set age range
  main2 = 1999
  )
cutout.years<- rep(2006, 2) 
InterYearsList <- list(main = rep(2002, 2), main2 = rep(2002, 2))
variables.always.use <- "schoolp|Enrolled|LHS|^agHH.yr2|^agHH$|^thana$|uniqu|^UDnon|^UDfl|^UD.*Sib|^UDhds|^pcland$|^pcnlasset$"
yrXs <- c("yr2", "yr3")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
  , main.agewise = mix.reorder("^agHH$|^agH.*2$|^D.*yA.*agHH.yr2$|^D.*yA.*\\.1\\d\\.yr2$|")
  , main.classwise = mix.reorder("^agHH$|^agH.*2$|^D.*yA.*agHH.yr2$|^D.*yA.*\\.1\\d\\.yr2$|^Du.*Ed.*|")
  , placebo.young = mix.reorder("^agHH$|^agHH.yr3$|^hdagHH.yr3$|")
  , placebo.agewise = mix.reorder("^agHH$|^agH.*3$|^D.*yA.*agHH.yr3$|^D.*yA.*\\.1\\d\\.yr3$|")
)
boxWidth <- 4
centerWidth <- 1.3
Enr.Base <- Enrchg.Base <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
names(results) <- names(resultsN) <- samples
ii <- jj <- j <- m <- s <- 1
ii <- 2; 
#for (ii in 1:length(samples)) {
for (ii in 1:2) {
  zSobj	 <- get(zsobj[1])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[1]]
  cutout.year <- cutout.years[1]
  InterYears <- InterYearsList[[1]]
  yrX <- yrXs[1]
  var.always.use <- gsub("yr2", yrX, variables.always.use)
  reorder <- reorder.list[[1]]
  regsnd <- rep("schoolp", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  res <- list(demeaned = res, undemeaned = res) # dd, demeaned/level interactions
  # res[[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  names(results0) <- names(resultsN0) <- zSobj
  for (jj in 1:length(zSobj)) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    for (dd in 1:2) {
      z1 = copy(z01)
      if (dd == 2) {
        ## Restore undemeaned interactions: Start 
        # 1. Drop demeaned interactions
        iiyr <- grepout("\\.yr", colnames(z1))
        iiyr <- gsub("\\.yr.", "", iiyr)
        iiyr <- unique(gsub("\\...agHH|\\.agHH0", "", iiyr))
        # interactions
        iiyrX <- paste0(iiyr, ".", yrX)
        iiagHHyrX <- 
          paste0(rep(iiyr, each = length(aghh.defs)), ".", rep(aghh.defs, length(iiyr)), ".", yrX)
        # drop demeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NULL]
        # 2. Form undemeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NA]
        z1[, (yrX) := as.integer(1:.N-1), by = uniquid]
        # restore demeaned agHH def terms as binary variables
        for (mm in aghh.defs) {
          set(z1, i = which(z1[[mm]] > 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 1L)
          set(z1, i = which(z1[[mm]] <= 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 0L)
        }
        # restore demeaned covariates: copy from corresponding UDX (undemeaned X)
        for (kk in iiyr)
          set(z1, j = grep(kk, colnames(z1)), value = z1[[paste0("UD", kk)]])
        # form level interactions
        # X.yrx
        for (i in 1:length(iiyr))
          set(z1, j = grep(paste0("^", iiyrX[i]), colnames(z1)), value = z1[[iiyr[i]]]*z1[[yrX]])
        # X.agHH.yrx
        for (kk in iiyr)
          for (mm in aghh.defs)
            set(z1, j = grep(paste0("^", kk, ".", mm, ".", yrX),  colnames(z1)), 
              value = z1[[kk]]*z1[[mm]]*z1[[yrX]])
        ## Restore undemeaned interactions: End 
      } # end: if dd == 2
      # remove area*agHH.yrX: too much parametrization that loses power and cause an overfit
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      tabextend <- c("yes", "", "yes", "")
      tabcohortdemeaned <- c("", "yes", "", "yes")
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      if (ii == 2 & jj == 5) smax <- 1 else smax <- 3
      for (s in 1)
      #  choice of age cutoff
      {
        s0 <- (10:12)[s]
        if (ii == 2 & jj == 5) {
          s0 <- 6
          MaxAge <- 9
        } else {
          MaxAge <- 18
        }
        i <- paste0("older", s0)
        # latter panel: s <= age < maxAge in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
          #maxAge
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        z4 <- z2[sd != 1, ]
        z4 <- dropunbalanced(z4, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
        for (j in 1:2)
        {
          zz0 <- get(z234[j])
          setkey(zz0, uniquid, survey)
          zz0[, survey := NULL]
            #for (m in 1:length(aghh.defs))
            for (m in 1)
            {
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              # drop some of triple interactions
              zz[, grepout("edu.*HH|pc.*HH|sp.*HH|hdag|mus", colnames(zz)) := NULL]
              ns <- NULL
              resul <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                # pick covariates for k-th regression: 
                #  paste " ..|.." & "..|.." with collapse = "|"
                #  then use it in grepout
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                # if (ii == 2 & jj == 1)
                #if (grepl("zEp.2|zSp", zSobj[jj]))
                # zEp.2002: UDOldSibF is all 0, UDOldSibM is all 0 but 2 obs, so drop them (and interactions).
                #  covariates <- covariates[!grepl("OldSib", covariates)]
                covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)] # drop real valued level variables
                zr <- zz[, covariates, with = F]
                # source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$|^UD|^pc.*[dt]$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   # opposite.time.order: set to F to get t-(t-1) difference. 
                   # (to be used in DID2 in the later chunk)
                   # Under F, diff(LHS) = -1 if schoolp 1 (1999) -> 0 (2002).
                   # agHH.yr2 is demeaned interaction (of agHH and yr2=1999 dummies), 
                   #   275 of obs (agHH==0) =  .59 because   -.39  (1999)  ->  .20 (2002)
                   #   407 of obs (agHH==1) = -.401 because  .266 (1999) -> -.135 (2002)
                   # In diff data, ag HH who dropped out: LHS = -1, agHH.yr2 = -.4 => OLS estimate > 0.
                   # A larger drop in LHS (more negative) for agHH == 1 dummy 
                   # needs agHH.yr2 to be defined as a positive value.
                   # Similarly, sex (female) == 1 gives diff(sex.yr2) < 0 for females in t-(t-1) diff. 
                   # X.yr2 needs to be defind as positive. To do so, in DID2, 
                   # one needs to set opposite.time.order = F & all time variant covariates
                   # to be X.yr2 := -1 * X.yr2 [so diff(agHH.yr2) > 0].
                   opposite.time.order = F, # Use t - (t-1) diff
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                #jj: zF, zE, zS
                #s: age cutoff
                #j: nuclear or extended
                #m: agHH def
                #k: specification
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[dd]][[s]][[j]][[ge]][[m]] <- resul
              # First run estimation data is stored in resul.
              # Pick the last item of data list which has the least num of obs. 
              # (This is data to use for all specifications.)
              # zidd: Differenced data of the last item in resul.
              # zid2: Level data to reconstruct and demean interaction terms of covariates.
              zid <- lapply(resul, "[[", "level.data")
              zid <- leveldata <- zid[[length(zid)]]
              zidd <- lapply(resul, "[[", "diff.data")
              zidd <- zidd[[length(zidd)]]
              zid <- zid[uniquid %in% zidd[, uniquid], ]
              # reconstruct agHH (it was demeaned)
              zid[eval(parse(text=grepout("agHH$", colnames(zid)))) > 0, 
                agHH := 1L]
              zid[eval(parse(text=grepout("agHH$", colnames(zid)))) <= 0, 
                agHH := 0L]
              zid[, tee := 1:.N, by = uniquid]
              setkey(zid, uniquid, tee)
              zid2 <- unique(zid[, .(uniquid, agHH)])
              # drop agHH if it is in regression data
              if (any(grepl("^agHH$", colnames(zidd)))) zidd[, agHH := NULL]
              # merge zid2 (uniquid, agHH) with zidd
              setkey(zid2, uniquid)
              setkey(zidd, uniquid)
              zidd <- zid2[zidd]
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "Enrolled")
              zidd[, tee := 1]
              enrr <- zid[, .(EnRate = mean(Enrolled), Num = .N), by = .(agHH, tee)]
              Enr.Base <- rbind(Enr.Base, 
                cbind(zSobj[jj], c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m], 
                  c("demeaned", "level")[dd], s0, enrr),
                use.names = F
              )
              # Save mean enrollment rate changes
              # x: agHH, y: nonagHH
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "Enrolled")
              ttestE <- t.test(zidd[agHH == 1, Enrolled], zidd[agHH == 0, Enrolled])
              Enrchg.Base <- rbind(Enrchg.Base, 
                cbind(
                    zSobj[jj], c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m], 
                    c("demeaned", "level")[dd], s0, -diff(unlist(ttestE["estimate"])), # -diff = -(y - x) = AgHH - nonagHH
                    t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                    )
                  )
              #for (cl in c("LiangZeger", "satterthwaite", "wildclusterboot")) 
              for (cl in c("LiangZeger", "satterthwaite")[1]) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl
                cat("\n\n###", cl, "###\n\n")
                #if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl) & any(grepl("Sib", colnames(zidd)))) {
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  # Julia fails for specification 6 in zEm.1999, zEp.1999, zEp.2002
                  if (grepl("wild", cl) & k == 6) next
                  #if (ii == 1 & grepl("S", zSobj[jj]) & s >= 1 & m == 4 & k >= 5 & grepl("wild", cl)) 
                  #zSm1999FDOlder10Occ
                  #  next
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  # var.always.use has level variables used only for destat purpose, so drop them
                  covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)]
                  # Commented out: Aug 2, 2023, start
                  #if (grepl("zEp|zSp", zSobj[jj]))
                  #  covariates <- covariates[!grepl("OldSib", covariates)]
                  # Commented out: Aug 2, 2023, end
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "Enrolled", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  #results0[[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                  #  list(est = rsl$est, ci = rsl$CI,
                  #    df = rsl$reg$df, reg = rsl$reg,
                  #    #level.data = leveldata[, gsub("Enrolled", "LHS", covariates), with = F], 
                  #    level.data = zid, 
                  #    diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  # Sign reversion is done before DID2. Below is redundant.
                  # Take19992002Diff is set to F in "read data chunk" at the beginning
                  # If (t-1) - t difference (opposite time order), signs of yrX cross terms are inverted.
                  #if (Take19992002Diff) est[[k]][grepout("Inter|yr.$", rownames(est[[k]])), c(1, 3)] <- 
                  #  -1 * est[[k]][grepout("Inter|yr.$", rownames(est[[k]])), c(1, 3)]
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean at baseline" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "control mean at follow up" = 
                       rep(formatC(enrr[tee == 2 & agHH == 0, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at baseline" =
                       rep(formatC(enrr[tee == 1 & agHH == 1, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at follow up" =
                       rep(formatC(enrr[tee == 2 & agHH == 1, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "raw DID" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1, EnRate] - enrr[tee == 1 & agHH == 1, EnRate] 
                       -(enrr[tee == 2 & agHH == 0, EnRate] - enrr[tee == 1 & agHH == 0, EnRate]), 
                         digits = 2, format = "f"), length(regressorsS))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "epc"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source(paste0(pathprogram, "tabulate_est.R"))
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, 
                  CIInTinySize = T, 
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$",
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                  # Split a table in to 2 tables
                if (DivInto2Tables) {
                  # Split a table in to 2 tables
                  if (grepl("e[ps]$", OUTformat)) 
                    NumRowsAfterEst <- 2 else 
                    NumRowsAfterEst <- 3
                  tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                  tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                  tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                  tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                  iispace11 <- which(
                    grepl(".", tbest11) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                    )
                  iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                  iispace21 <- which(
                    grepl(".", tbest21) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                    )
                  # drop last rows of tbest2 to shrink row space
                  iispace21 <- iispace21[iispace21 < grep("toilet", tbest21)]
                  iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                  if (grepl("e[ps]$", OUTformat)) {
                  # ep, es: 2 rows per estimate
                    AdjustLineSkipRows1 <- iispace11
                    AltColorRows1 <- c(iispace12, iispace12+1)
                    AdjustLineSkipRows2 <- iispace21
                    AltColorRows2 <- c(iispace22, iispace22+1)
                  } else {
                  # epc, esc, satt: 3 rows per estimate
                    AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                    AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                    AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                    AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                  }
                 #source("c:/seiro/settings/Rsetting/functions.R")
                  tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows1,
                    alternatecolorManual = AltColorRows1,
                    alternatecolorManualColor = "gray80")
                  tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest21),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows2,
                    alternatecolorManual = AltColorRows2,
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows1 <- grep("nteract.*\\d", tbl1)
                  InterRows2 <- grep("nteract.*\\d", tbl2)
                  for (ir in InterRows1) {
                    if (any(grepl("rowcolor", tbl1[ir])))
                      tbl1[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl1[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          )
                    # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                    # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                    tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                    tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                    tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                  }
                  for (ir in InterRows2) {
                    if (any(grepl("rowcolor", tbl2[ir])))
                      tbl2[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl2[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          )
                    tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                    tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                    tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                  }
                  clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                  # file path to saved table
                  pathtosavedtable1 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]), 
                    AgeCutoff = paste0("Older", (10:12)[s]),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 1)
                    )
                  pathtosavedtable2 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]), 
                    AgeCutoff = paste0("Older", (10:12)[s]),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 2)
                    )
                  write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable1, "\n")
                  cat("Table saved as", pathtosavedtable2, "\n")
                } else {
                  # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                  iispace <- which(
                    # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                    grepl(".", tbest[[1]]) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                    )
                  iispace2 <- iispace[seq(2, length(iispace), 2)]
                  # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                  # adjlskiprows = c(iispace, iispace+1)
                  # saveEstTable is in functions.R
                  # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                  tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest[[1]]),
                    hleft = "\\hfil\\tiny$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.5ex", 
                    adjlskiprows = c(iispace, iispace+1),
                    alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                    alternatecolorManualColor = "gray80")
                  if (grepl("Liang", cl))
                    tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                      estimationspacelast = grep("thana dummi", tbest[[1]]),
                      hleft = "\\hfil\\tiny$", hright = "$", 
                      hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                      delimiterline = NULL, adjustlineskip = "-0.5ex", 
                      adjlskiprows = c(iispace),
                      alternatecolorManual = c(iispace2, iispace2+1),
                      alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows <- grep("nteract.*\\d", tbl)
                  for (ir in InterRows)
                    if (any(grepl("rowcolor", tbl[ir])))
                      tbl[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          ) else
                        # rows without rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          )
                  pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]), 
                    AgeCutoff = paste0("Older", (10:12)[s]),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                  write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable, "\n")
                } # if end: DivInto2Tables
              } # cl: SE clustering option
            }  # m: ag HH definitions
        }  # j: z2 (incl. extended) or z3 (nuclear)
      }  # s: lowerbound age cutoffs (10, 11, 12)
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
library(qs)
qsave(results, paste0(pathsaveThisVer, "FD_MainCRCoVSelected_results.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "FD_N_MainCRCoVSelected_results.qs"))
# results <- qread(paste0(pathsaveThisVer, "FD_MainCRCoVSelected_results.qs"))
Enr.Base <- data.table(Enr.Base)
Enrchg.Base <- data.table(Enrchg.Base)
setnames(Enrchg.Base, c("sample", "HHtype", "agHHdef", "demean", "age", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(Enr.Base, c("sample", "HHtype", "agHHdef", "demean", "age", "agHH", "tee", "rate", "Obs"))
qsave(Enr.Base, paste0(pathsaveThisVer, "Enr.BaseSelected.qs"))
qsave(Enrchg.Base, paste0(pathsaveThisVer, "Enrchg.BaseSelected.qs"))
ii <- jj <- dd <- s <- j <- ge <- m <- 1
dd <- j <- 2
clnum <- 2
rr <- results[[ii]][[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]]
@
<<tabulate selected main results, eval = F>>=
library(qs)
AddStar <- T
results1 <- qread(paste0(pathsaveThisVer, "FD_MainCRCoV_results.qs"))
# results1[[ii]][[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]]
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")[1] 
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999", "zYp.1999")[c(1, 3)]
samples <- c("main", "placebo")
z234 <- c("z2", "z3", "z4")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")[1]
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999")[c(1, 3)]
EstGen <- NR <- Enr <- NULL
results <- results1
for (ii in 1) {
  zSobj <- get(zsobj[[ii]])
  for (jj in 1:length(zSobj)) {
    thisdata <- zSobj[[jj]]
    for (dd in 1) {
      for (s in 1) {
        for (j in 1:2) {
          for (ge in 1:3) {
            for (m in 1) {
              for (clnum in 1:2) {
                # cl: 1: LZ, 2: satterthwaite
                estGen1 <- results[[ii]][[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]]
                estGen <- lapply(estGen1, "[[", "ci")
                estGen <- lapply(estGen, data.table)
                estGen <- lapply(1:length(estGen), function(i) estGen[[i]][, reg := i])
                estGen <- rbindlist(estGen, use.names = T, fill = T)
                # if clnum == 1, estGen only contain CIs
                if (clnum == 1) {
                  esp <- lapply(estGen1, "[[", "est")
                  esp <- lapply(esp, as.matrix)
                  esprn <- unlist(lapply(esp, rownames))
                  esp <- lapply(esp, function(x) as.data.table(x[, ]))
                  dfs <- lapply(lapply(estGen1, "[[", "est"), function(x) attributes(x)$df)
                  esp <- lapply(1:length(esp), function(i) esp[[i]][, df := dfs[[i]]])
                  esp <- rbindlist(esp, use.names = T, fill = T)
                  if (any(grepl("z value", colnames(esp)))) esp[, "z value" := NULL]
                  estGen <- cbind(Coef = esprn, esp, estGen)
                  setnames(estGen,  c("Coef", "beta", "SE", "t", "p_val", "df", "CI_L", "CI_U", "reg"))
                  estGen[, t := NULL]
                }
                estGen[, p_val := round(p_val, 6)]
                estGen[, SE := round(SE, 8)]
                estGen[, inference := c("LZ", "BRL")[clnum]]
                estGen[, gender := genderitems[ge]]
                estGen[, agdef := aghh.defs[m]]
                estGen[, agelb := c(10:12)[s]]
                estGen[, HHtype := c("all", "direct", "exonly")[j]]
                estGen[, data := thisdata]
                estGen[, demean := c("demeaned", "undemeaned")[dd]]
                estGen[, objective := c("main", "placebo")[ii]]
                setcolorder(estGen,  c("objective", "data", "gender", "agdef", "agelb", "HHtype", 
                  "demean", "Coef", "beta", "SE", "df", "p_val", "CI_L", "CI_U", "reg", "inference"))
                EstGen <- rbindlist(list(EstGen, estGen), use.names = T, fill = T)
                # n and R2
                nR <- lapply(lapply(estGen1, "[[", "reg"), 
                  function(x) t(c(length(summary(x)$res), summary(x)$r.sq)))
                nR <- lapply(nR, data.table)
                nR <- lapply(1:length(nR), function(i) nR[[i]][, spec := i])
                nR <- rbindlist(nR, use.names = T, fill = T)
                nR[, gender := genderitems[ge]]
                setnames(nR, c("n", "R", "spec", "gender"))
                nR[, n := formatC(n, digits = 0, format = "f")]
                nR[, R := formatC(R, digits = 4, format = "f")]
                nR[, agdef := aghh.defs[m]]
                nR[, agelb := c(10:12)[s]]
                nR[, HHtype := c("all", "direct", "exonly")[j]]
                nR[, data := thisdata]
                nR[, demean := c("demeaned", "undemeaned")[dd]]
                nR[, objective := c("main", "placebo")[ii]]
                nR[, inference := c("LZ", "BRL")[clnum]]
                NR <- rbind(NR, nR, use.names = T, fill = T)
                # treated and control means
                zid <- lapply(estGen1, "[[", "level.data")
                zidd <- lapply(estGen1, "[[", "diff.data")
                zid <- lapply(1:length(zid), function(i) zid[[i]][uniquid %in% zidd[[i]][, uniquid], ])
                zid <- lapply(zid, function(x) x[eval(parse(text=grepout("agHH$", colnames(x)))) > 0, 
                          agHH := 1L])
                zid <- lapply(zid, function(x) x[eval(parse(text=grepout("agHH$", colnames(x)))) < 0, 
                          agHH := 0L])
                zid <- lapply(zid, function(x) x[, tee := 1:.N, by = uniquid])
                if (any(grepl("Enrolled", colnames(zid[[1]]))))
                  lapply(zid, function(x) setnames(x, "Enrolled", "schoolp"))
                enr <- lapply(zid, function(x) x[, .(EnRate = mean(schoolp), Num = .N), by = .(agHH, tee)])
                enr <- lapply(1:length(enr), function(i) enr[[i]][, spec := i])
                enr <- rbindlist(enr, use.names = T, fill = T)
                enr[, gender := genderitems[ge]]
                enr[, agdef := aghh.defs[m]]
                enr <- unique(enr[, spec := NULL])
                enr[, agelb := c(10:12)[s]]
                enr[, HHtype := c("all", "direct", "exonly")[j]]
                enr[, data := thisdata]
                enr[, demean := c("demeaned", "undemeaned")[dd]]
                enr[, objective := c("main", "placebo")[ii]]
                enr[, inference := c("LZ", "BRL")[clnum]]
                Enr <- rbind(Enr, enr, use.names = T, fill = T)
              } # clnum
            } # m
          } # ge
        } # j
      } # s
    } # dd
  } # jj
} # ii
#EstGen[grepl("m", objective) & grepl("Em", data) & grepl("b.*g", gender) & agelb == 10 & 
#  HHtype == "all" & grepl("^agHH.yr2$", Coef) & reg == 3 & grepl("B", inference), ]
setnames(EstGen, "p_val", "p")
EstGen[, coeff := as.character(NA)]
EstGen[grepl("^agHH.yr.$", Coef), coeff := "main"]
EstGen[grepl("SibF.*H", Coef), coeff := "older female siblings"]
EstGen[grepl("SibM.*H", Coef), coeff := "older male siblings"]
EstGen[, coeff := factor(coeff)]
EstGen[, Coef := factor(Coef)]
EstGen[, inference := factor(inference)]
EstGen[, objective := factor(objective)]
EstGen[, data := factor(data)]
EstGen[, agdef := factor(agdef)]
EstGen[, gender := factor(gender, levels = genderitems)]
EstGen[, HHtype := factor(HHtype)]
EstGen[, demean := factor(demean)]
NR[, objective := factor(objective)]
NR[, data := factor(data)]
NR[, agdef := factor(agdef)]
NR[, gender := factor(gender)]
NR[, HHtype := factor(HHtype)]
NR[, demean := factor(demean)]
NR[, inference := factor(inference)]
Enr[, objective := factor(objective)]
Enr[, data := factor(data)]
Enr[, agdef := factor(agdef)]
Enr[, gender := factor(gender)]
Enr[, HHtype := factor(HHtype)]
Enr[, demean := factor(demean)]
Enr[, inference := factor(inference)]
qsave(EstGen, paste0(pathsaveThisVer, "TabulatedMainSelectedResults1.qs"))
qsave(Enr, paste0(pathsaveThisVer, "TabulatedMainSelectedResultsEnr1.qs"))
qsave(NR, paste0(pathsaveThisVer, "TabulatedMainSelectedResultsNR1.qs"))
EstGen[grepl("s.g", gender) & grepl("^a", HHtype) & grepl("^agHH.yr2$", Coef) & grepl("^B", inference), ]
@

<<plot main agelb 10 agHH0 by gender demeaned undemeaned, eval = F>>=
library(ggplot2)
Res <- qread(paste0(pathsaveThisVer, "TabulatedMainSelectedResults1.qs"))
re <- Res[grepl("Em", data) & grepl("4|5|6|7", reg) & grepl("B", inference)
   & agelb == 10 & grepl("all|dir", HHtype), ]
re <- re[grepl("ma", coeff), ]
setkey(re, data, coeff, reg)
re[, hr := paste0(HHtype, "-", reg)]
re[, yintercept := 0]
g <- ggplot(data = re, 
    aes(x = demean, y = beta, group = hr, fill = hr, shape = hr, colour = hr)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .5)) +
  scale_shape_manual(values = c(0:6, 8))+
  facet_grid(coeff ~ gender, scales = "free_y")+
  ThisThemeEnd+
  #scale_y_continuous(limits = c(-1, 1)/2)+
  xlab("interaction terms") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 2),
    fill = guide_legend(title = "regression specifications", nrow = 2),
    shape = guide_legend(title = "regression specifications", nrow = 2)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "MainImpactsByGenderByDemeanAgelb10.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<plot placebo zEp1999 agHH0 by gender demeaned undemeaned, eval = F>>=
library(ggplot2)
Res <- qread(paste0(pathsaveThisVer, "TabulatedMainSelectedResults1.qs"))
re <- Res[grepl("Ep.1", data) & grepl("4|5|6|7", reg) & grepl("B", inference)
   & agelb == 10 & grepl("all|dir", HHtype), ]
re <- re[grepl("ma", coeff), ]
setkey(re, data, coeff, reg)
re[, hr := paste0(HHtype, "-", reg)]
re[, yintercept := 0]
g <- ggplot(data = re, 
    aes(x = demean, y = beta, group = hr, fill = hr, shape = hr, colour = hr)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .5)) +
  scale_shape_manual(values = c(0:6, 8))+
  facet_grid(coeff ~ gender, scales = "free_y")+
  ThisThemeEnd+
  #scale_y_continuous(limits = c(-1, 1)/2)+
  xlab("interaction terms") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 2),
    fill = guide_legend(title = "regression specifications", nrow = 2),
    shape = guide_legend(title = "regression specifications", nrow = 2)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "PlaceboImpactsByGenderByDemeanAgelb10.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<plot placebo zEp2002 agHH0 by gender demeaned undemeaned, eval = F>>=
library(ggplot2)
Res <- qread(paste0(pathsaveThisVer, "TabulatedMainSelectedResults1.qs"))
re <- Res[grepl("Ep.2", data) & grepl("4|5|6|7", reg) & grepl("B", inference)
   & agelb == 10 & grepl("all|dir", HHtype) & grepl(0, agdef), ]
re <- re[grepl("^agHH.yr.$|Sib.*H.*yr.$", Coef), ]
setkey(re, data, coeff, reg)
re[, hr := paste0(HHtype, "-", reg)]
re[, yintercept := 0]
g <- ggplot(data = re, 
    aes(x = demean, y = beta, group = hr, fill = hr, shape = hr, colour = hr)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .5)) +
  scale_shape_manual(values = c(0:6, 8))+
  facet_grid(coeff ~ gender, scales = "free_y")+
  ThisThemeEnd+
  #scale_y_continuous(limits = c(-1, 1)/2)+
  xlab("interaction terms") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 2),
    fill = guide_legend(title = "regression specifications", nrow = 2),
    shape = guide_legend(title = "regression specifications", nrow = 2)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "Placebo2ImpactsByGenderByDemeanAgelb10.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<>>=
library(qs)
Enr.Base <- qread(paste0(pathsaveThisVer, "Enr.Base.qs"))
Enrchg.Base <- qread(paste0(pathsaveThisVer, "Enrchg.Base.qs"))
@
<<tabulate results age gender wise, eval = F>>=
results <- qread(paste0(pathsaveThisVer, "FD_SubsampleAgeGenderCRCoV_results.qs"))
names(results[[1]][[1]])
zsobj <- c("zEm.1999", "zEp.2002", "zEp.1999", "zYp.1999")
# results[[ii]][[ge]][[dd]][[m]][[j]][[gg]][[ag]][[cl]][[k]] levels.
# zsobj <- c("zEm.1999", "zEp.2002", "zEp.1999", "zYp.1999"): ii = 1, 2, 3, 4.
# ii = data, m = agHHdef, ge = gender, j = HH type, gg = AgeGroup1,  
#  ag = age groups , cl = LiangZeger/satterthwaite
# age groups
AGEgrouping <- c("agewise", "AgeGroup1", "AgeGroup2", "AgeGroup3")
agewise <- as.list(6:18); names(agewise) <- putzeroontop(6:18)
AgeGroup1 <- list(pri=6:10, jsec=11:13, sec=14:15, hsec=16:17, coll=18)
AgeGroup2 <- list(pri=6:10, sec=11:17, coll=18)
AgeGroup3 <- list(young=6:9, junior=10:15, senior=16:18)
names(results[[1]][[ge]][[dd]][[m]][[j]][[gg]])
Res2 <- NR2 <- Enr2 <- NULL
for (ii in 1:length(zsobj)) {
  thisdata <- zsobj[[ii]]
  for (ge in 1:3) {
    for (dd in 1:2) {
      for (m in 1:4) {
        for (j in 1:2) {
          for (gg in 1:length(AGEgrouping)) {
            AGEgroup <- get(AGEgrouping[gg])
            for (ag in 1:length(AGEgroup)) {
              for (clnum in 1:2) {
                estobj <- results[[ii]][[ge]][[dd]][[m]][[j]][[gg]][[ag]][[clnum]]
                CIs <- lapply(estobj, "[[", "ci")
                #DFs <- lapply(estobj, "[[", "df")
                if (length(CIs) == 0 || is.null(CIs[[1]])) {
                  cat("Skipped due to no estimation:", 
                    paste0("ii==", zsobj[ii]),
                    paste0("ge==", genderitems[ge]), 
                    paste0("m==", aghh.defs[m]), 
                    paste0("j==", c("all", "direct")[j]), 
                    paste0("gg==", AGEgrouping[gg]), 
                    paste0("ag==", AGEgroup[ag]), "\n")
                  next
                }
                CIs <- lapply(CIs, data.table)
                CIs <- lapply(1:length(CIs), function(i) CIs[[i]][, reg := i])
                CIs <- rbindlist(CIs, use.names = T, fill = T)
                # if clnum == 1, estobj only contains CIs
                if (clnum == 1) {
                  esp <- lapply(estobj, "[[", "est")
                  esp <- lapply(esp, as.matrix)
                  esprn <- unlist(lapply(esp, rownames))
                  esp <- lapply(esp, function(x) as.data.table(x[, ]))
                  dfs <- lapply(lapply(estobj, "[[", "est"), function(x) attributes(x)$df)
                  esp <- lapply(1:length(esp), function(i) esp[[i]][, df := dfs[[i]]])
                  esp <- rbindlist(esp, use.names = T, fill = T)
                  if (any(grepl("z value", colnames(esp)))) esp[, "z value" := NULL]
                  CIs <- cbind(Coef = esprn, esp, CIs)
                  setnames(CIs,  c("Coef", "beta", "SE", "t", "p_val", "df", "CI_L", "CI_U", "reg"))
                  CIs[, t := NULL]
                }
                CIs[, inference := c("LZ", "BRL")[clnum]]
                CIs[, group := names(results[[1]][[ge]][[dd]][[m]][[j]][[gg]])[ag]]
                CIs[, agegroup := names(results[[1]][[ge]][[dd]][[m]][[j]])[gg]]
                CIs[, agdef := aghh.defs[m]]
                CIs[, HHtype := c("all", "direct", "exonly")[j]]
                CIs[, demean := c("demeaned", "undemeaned")[dd]]
                CIs[, gender := genderitems[ge]]
                CIs[, data := thisdata]
                CIs[, p_val := round(p_val, 6)]
                CIs[, SE := round(SE, 8)]
                setcolorder(CIs,  c("data", "gender", "agdef", "HHtype", "demean", 
                  "agegroup", "group", "Coef", "beta", "SE", "df", "p_val", "CI_L", "CI_U", "reg", "inference"))
                Res2 <- rbindlist(list(Res2, CIs), use.names = F)
                # n and R2
                nR <- lapply(lapply(estobj, "[[", "reg"), 
                  function(x) t(c(length(summary(x)$res), summary(x)$r.sq)))
                nR <- lapply(nR, data.table)
                nR <- lapply(1:length(nR), function(i) nR[[i]][, spec := i])
                nR <- rbindlist(nR, use.names = T, fill = T)
                nR[, gender := genderitems[ge]]
                setnames(nR, c("n", "R", "spec", "gender"))
                nR[, n := formatC(n, digits = 0, format = "f")]
                nR[, R := formatC(R, digits = 4, format = "f")]
                # number of agHHs
                nR2 <- unique(unlist(lapply(lapply(estobj, "[[", "diff.data"), 
                  function(x) sum(x[, agHH]>0))))
                nR[, Yes := formatC(nR2, digits = 0, format = "f")]
                nR[, inference := c("LZ", "BRL")[clnum]]
                nR[, group := names(results[[1]][[ge]][[dd]][[m]][[j]][[gg]])[ag]]
                nR[, agegroup := names(results[[1]][[ge]][[dd]][[m]][[j]])[gg]]
                nR[, agdef := aghh.defs[m]]
                nR[, HHtype := c("all", "direct", "exonly")[j]]
                nR[, demean := c("demeaned", "undemeaned")[dd]]
                nR[, data := thisdata]
                NR2 <- rbindlist(list(NR2, nR), use.names = F)
                # treated and control means
                zid <- estobj[[1]][["level.data"]]
                zidd <- estobj[[1]][["diff.data"]]
                zid <- zid[uniquid %in% zidd[, uniquid], ]
                zid[eval(parse(text=grepout("agHH$", colnames(x)))) > 0, agHH := 1L]
                zid[eval(parse(text=grepout("agHH$", colnames(x)))) < 0, agHH := 0L]
                zid[, tee := 1:.N, by = uniquid]


                if (any(grepl("Enrolled", colnames(zid)))) setnames(zid, "Enrolled", "schoolp")
                enr <- zid[, .(EnRate = mean(schoolp), Num = .N), by = .(agHH, tee)]
                enr[, inference := c("LZ", "BRL")[clnum]]
                enr[, group := names(results[[1]][[ge]][[dd]][[m]][[j]][[gg]])[ag]]
                enr[, agegroup := names(results[[1]][[ge]][[dd]][[m]][[j]])[gg]]
                enr[, HHtype := c("all", "direct", "exonly")[j]]
                enr[, agdef := aghh.defs[m]]
                enr[, demean := c("demeaned", "undemeaned")[dd]]
                enr[, gender := genderitems[ge]]
                enr[, data := thisdata]
                Enr2 <- rbindlist(list(Enr2, enr), use.names = F)
              } # clnum
            } # ag
          } # gg
        } # j
      } # m
    } # ge
  } # dd
} # ii
setcolorder(Res2, c("data", "gender", "agegroup", "group",  "HHtype", "reg", "agdef",
  grepout("bet|SE|df|CI|^p", colnames(Res2))))
Res2[grepl("Em", data) & grepl("age", agegroup) & group == "10" & grepl("^d", demean) &
  grepl(0, agdef) & HHtype == "all" & reg == 1 & grepl("^ag", Coef), ]
Res2[, agdef := factor(agdef)]
Res2[, gender := factor(gender)]
Res2[, agegroup := factor(agegroup)]
Res2[, reg := factor(reg)]
Res2[, Coef := factor(Coef)]
Res2[, HHtype := factor(HHtype)]
Res2[, demean := factor(demean)]
Res2[, inference := factor(inference)]
Res2[, data := factor(data)]
Res2[, gender := factor(gender, levels = genderitems)]
maxageinGroup <- max(as.numeric(as.character(unique(Res2[, group]))), na.rm = T)
Res2[, group := factor(group, levels = c(putzeroontop(6:maxageinGroup), 
  "pri", "jsec", "sec", "hsec", #"coll",
  "young", "junior", "senior"))]
Res2[, yintercept := 0]
qsave(Res2, paste0(pathsaveThisVer, "TabulatedMainResults2_.qs"))
qsave(Enr2, paste0(pathsaveThisVer, "TabulatedMainResultsEnr2_.qs"))
qsave(NR2, paste0(pathsaveThisVer, "TabulatedMainResultsNR2_.qs"))
<<tabulate main results, eval = F>>=
library(qs)
AddStar <- T
results1 <- qread(paste0(pathsaveThisVer, "FD_MainCRCoV_results.qs"))
#results2 <- qread(paste0(pathsaveThisVer, "FD_MainCRCoVUndemeaned_results.qs"))
#results2 <- qread(paste0(pathsaveThisVer, "FD_GenderCRCoV_results.qs"))
results2 <- qread(paste0(pathsaveThisVer, "FD_SubsampleAgeGenderCRCoV_results.qs"))
# results1[[ii]][[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]]
# cl: c("LiangZeger", "satterthwaite", "wildclusterboot")
# at k=4: program is added to covariates
# ii=2, jj = 1 is zEp.2002, dd = 2 is level interactions
# results2[[ii]][[ge]][[dd]][[m]][[j]][[gg]][[ag]][[cl]][[k]]
## for results1, 
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")[1] 
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999", "zYp.1999")[c(1, 3)]
samples <- c("main", "placebo")
z234 <- c("z2", "z3", "z4")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")[1]
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999")[c(1, 3)]
EstGen <- NR <- Enr <- NULL
results <- results1
for (ii in 1:2) {
  zSobj <- get(zsobj[[ii]])
  for (jj in 1:length(zSobj)) {
    thisdata <- zSobj[[jj]]
    for (dd in 1:2) {
      for (s in 1:3) {
        for (j in 1:3) {
          for (ge in 1:3) {
            for (m in 1:4) {
              for (clnum in 1:2) {
                # cl: 1: LZ, 2: satterthwaite
                estGen1 <- results[[ii]][[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]]
                if (all(unlist(lapply(estGen1, is.null)))) next
                estGen <- lapply(estGen1, "[[", "ci")
                estGen <- lapply(estGen, data.table)
                estGen <- lapply(1:length(estGen), function(i) estGen[[i]][, reg := i])
                estGen <- rbindlist(estGen, use.names = T, fill = T)
                # if clnum == 1, estGen only contain CIs
                if (clnum == 1) {
                  esp <- lapply(estGen1, "[[", "est")
                  esp <- lapply(esp, as.matrix)
                  esprn <- unlist(lapply(esp, rownames))
                  esp <- lapply(esp, function(x) as.data.table(x[, ]))
                  dfs <- lapply(lapply(estGen1, "[[", "est"), function(x) attributes(x)$df)
                  esp <- lapply(1:length(esp), function(i) esp[[i]][, df := dfs[[i]]])
                  esp <- rbindlist(esp, use.names = T, fill = T)
                  if (any(grepl("z value", colnames(esp)))) esp[, "z value" := NULL]
                  estGen <- cbind(Coef = esprn, esp, estGen)
                  setnames(estGen,  c("Coef", "beta", "SE", "t", "p_val", "df", "CI_L", "CI_U", "reg"))
                  estGen[, t := NULL]
                }
                estGen[, p_val := round(p_val, 6)]
                estGen[, SE := round(SE, 8)]
                estGen[, inference := c("LZ", "BRL")[clnum]]
                estGen[, gender := genderitems[ge]]
                estGen[, agdef := aghh.defs[m]]
                estGen[, agelb := c(10:12)[s]]
                estGen[, HHtype := c("all", "direct", "exonly")[j]]
                estGen[, data := thisdata]
                estGen[, demean := c("demeaned", "undemeaned")[dd]]
                estGen[, objective := c("main", "placebo")[ii]]
                setcolorder(estGen,  c("objective", "data", "gender", "agdef", "agelb", "HHtype", 
                  "demean", "Coef", "beta", "SE", "df", "p_val", "CI_L", "CI_U", "reg", "inference"))
                EstGen <- rbindlist(list(EstGen, estGen), use.names = T, fill = T)
                # n and R2
                nR <- lapply(lapply(estGen1, "[[", "reg"), 
                  function(x) t(c(length(summary(x)$res), summary(x)$r.sq)))
                nR <- lapply(nR, data.table)
                nR <- lapply(1:length(nR), function(i) nR[[i]][, spec := i])
                nR <- rbindlist(nR, use.names = T, fill = T)
                nR[, gender := genderitems[ge]]
                setnames(nR, c("n", "R", "spec", "gender"))
                nR[, n := formatC(n, digits = 0, format = "f")]
                nR[, R := formatC(R, digits = 4, format = "f")]
                # number of agHHs
                nR2 <- unique(unlist(lapply(lapply(estGen1, "[[", "diff.data"), 
                  function(x) sum(x[, agHH]>0))))
                nR[, Yes := formatC(nR2, digits = 0, format = "f")]
                nR[, agdef := aghh.defs[m]]
                nR[, agelb := c(10:12)[s]]
                nR[, HHtype := c("all", "direct", "exonly")[j]]
                nR[, data := thisdata]
                nR[, demean := c("demeaned", "undemeaned")[dd]]
                nR[, objective := c("main", "placebo")[ii]]
                nR[, inference := c("LZ", "BRL")[clnum]]
                NR <- rbind(NR, nR, use.names = T, fill = T)
                # treated and control means
                zid <- lapply(estGen1, "[[", "level.data")
                zidd <- lapply(estGen1, "[[", "diff.data")
                zid <- lapply(1:length(zid), function(i) zid[[i]][uniquid %in% zidd[[i]][, uniquid], ])
                zid <- lapply(zid, function(x) x[eval(parse(text=grepout("agHH$", colnames(x)))) > 0, 
                          agHH := 1L])
                zid <- lapply(zid, function(x) x[eval(parse(text=grepout("agHH$", colnames(x)))) < 0, 
                          agHH := 0L])
                zid <- lapply(zid, function(x) x[, tee := 1:.N, by = uniquid])
                if (any(grepl("Enrolled", colnames(zid[[1]]))))
                  lapply(zid, function(x) setnames(x, "Enrolled", "schoolp"))
                enr <- lapply(zid, function(x) x[, .(EnRate = mean(schoolp), Num = .N), by = .(agHH, tee)])
                enr <- lapply(1:length(enr), function(i) enr[[i]][, spec := i])
                enr <- rbindlist(enr, use.names = T, fill = T)
                enr[, gender := genderitems[ge]]
                enr[, agdef := aghh.defs[m]]
                enr <- unique(enr[, spec := NULL])
                enr[, agelb := c(10:12)[s]]
                enr[, HHtype := c("all", "direct", "exonly")[j]]
                enr[, data := thisdata]
                enr[, demean := c("demeaned", "undemeaned")[dd]]
                enr[, objective := c("main", "placebo")[ii]]
                enr[, inference := c("LZ", "BRL")[clnum]]
                Enr <- rbind(Enr, enr, use.names = T, fill = T)
              } # clnum
            } # m
          } # ge
        } # j
      } # s
    } # dd
  } # jj
} # ii
#EstGen[grepl("m", objective) & grepl("Em", data) & grepl("b.*g", gender) & agelb == 10 & 
#  HHtype == "all" & grepl("^agHH.yr2$", Coef) & reg == 3 & grepl("B", inference), ]
setnames(EstGen, "p_val", "p")
EstGen[, coeff := as.character(NA)]
EstGen[grepl("^agHH.yr.$", Coef), coeff := "main"]
EstGen[grepl("SibF.*H", Coef), coeff := "older female siblings"]
EstGen[grepl("SibM.*H", Coef), coeff := "older male siblings"]
EstGen[, coeff := factor(coeff)]
EstGen[, Coef := factor(Coef)]
EstGen[, inference := factor(inference)]
EstGen[, objective := factor(objective)]
EstGen[, data := factor(data)]
EstGen[, agdef := factor(agdef)]
EstGen[, gender := factor(gender)]
EstGen[, HHtype := factor(HHtype)]
EstGen[, gender := factor(gender, levels = genderitems)]
EstGen[, demean := factor(demean)]
qsave(EstGen, paste0(pathsaveThisVer, "TabulatedMainResults1.qs"))
qsave(Enr, paste0(pathsaveThisVer, "TabulatedMainResultsEnr1.qs"))
qsave(NR, paste0(pathsaveThisVer, "TabulatedMainResultsNR1.qs"))
<<rbind tabulated main and agewise results>>=
Res1 <- qread(paste0(pathsaveThisVer, "TabulatedMainResults1.qs"))
Enr1 <- qread(paste0(pathsaveThisVer, "TabulatedMainResultsEnr1.qs"))
NR1 <- qread(paste0(pathsaveThisVer, "TabulatedMainResultsNR1.qs"))
Res2 <- qread(paste0(pathsaveThisVer, "TabulatedMainResults2.qs"))
Enr2 <- qread(paste0(pathsaveThisVer, "TabulatedMainResultsEnr2.qs"))
NR2 <- qread(paste0(pathsaveThisVer, "TabulatedMainResultsNR2.qs"))
Res <- rbindlist(list(Res1, Res2), use.names = T, fill = T)
Res[, gender := factor(gender, levels = genderitems)]
Res[, reg := as.integer(unlist(reg))]
setnames(Res, "stat", "SattDoF", skip_absent = T)
Res[grepl("F.*H", Coef), coeff := "older female siblings"]
Res[grepl("M.*H", Coef), coeff := "older male siblings"]
Enr <- rbindlist(list(Enr1, Enr2), use.names = T, fill = T)
NR <- rbindlist(list(NR1, NR2), use.names = T, fill = T)
NR[, objective := factor(objective)]
NR[, data := factor(data)]
NR[, agdef := factor(agdef)]
NR[, gender := factor(gender, levels = genderitems)]
NR[, HHtype := factor(HHtype)]
NR[, demean := factor(demean)]
NR[, inference := factor(inference)]
NR[, group := factor(group)]
NR[, agegroup := factor(agegroup)]
setnames(NR, "spec", "reg")
Enr[, objective := factor(objective)]
Enr[, data := factor(data)]
Enr[, agdef := factor(agdef)]
Enr[, gender := factor(gender, levels = genderitems)]
Enr[, HHtype := factor(HHtype)]
Enr[, demean := factor(demean)]
Enr[, inference := factor(inference)]
Enr[, group := factor(group)]
Enr[, agegroup := factor(agegroup)]
qsave(Res, paste0(pathsaveThisVer, "TabulatedAllResults.qs"))
qsave(Enr, paste0(pathsaveThisVer, "TabulatedAllResultsEnr.qs"))
qsave(NR, paste0(pathsaveThisVer, "TabulatedAllResultsNR.qs"))
@



\begin{figure}
\hfil\textsc{\footnotesize Figure \refstepcounter{figure}\thefigure: Impacts by gender 1999-2002\label{ImpactsByGenderByDemeanAgelb10.zEp.1999}}\\
%\hfil \includegraphics[width=.75\paperwidth]{\Sexpr{
#  paste0(pathsaveThisVer, "MainImpactsByGenderByDemeanAgelb10.pdf")
}}\\

\renewcommand{\arraystretch}{1}
\hfil\begin{tabular}{>{\hfill\scriptsize}p{1cm}<{}>{\scriptsize}p{12cm}<{\hfill}}
Source:& Compiled from IFPRI data. \\[-1ex]
Notes:& 1. Coefficients on agricultural HH dummy $\times$ year 2002 dummy. \textsf{all-1} indicates specification 1 of all children sample, \textsf{direct-1} indicates specification 1 of direct offspring sample.\\[-1ex]
& 2. Error bars use cluster robust standard errors at thana level with Satterthwaite correction for degree of freedom.
\end{tabular}
\end{figure}


\begin{figure}
\hfil\textsc{\footnotesize Figure \refstepcounter{figure}\thefigure: Impacts by gender 2002-2006 (placebo), 1999 cohorts\label{PlaceboImpactsByGenderByDemeanAgelb10.zEp.1999}}\\
%\hfil \includegraphics[width=.75\paperwidth]{\Sexpr{
#paste0(pathsaveThisVer, "PlaceboImpactsByGenderByDemeanAgelb10.pdf")
}}\\

\renewcommand{\arraystretch}{1}
\hfil\begin{tabular}{>{\hfill\scriptsize}p{1cm}<{}>{\scriptsize}p{12cm}<{\hfill}}
Source:& Compiled from IFPRI data. \\[-1ex]
Notes:& 1. Coefficients on agricultural HH dummy $\times$ year 2002 dummy. \textsf{all-1} indicates specification 1 of all children sample, \textsf{direct-1} indicates specification 1 of direct offspring sample.\\[-1ex]
& 2. Error bars use cluster robust standard errors at thana level with Satterthwaite correction for degree of freedom.
\end{tabular}
\end{figure}

\begin{figure}
\hfil\textsc{\footnotesize Figure \refstepcounter{figure}\thefigure: Impacts by gender 2002-2006 (placebo), 2002 cohorts\label{Placebo2ImpactsByGenderByDemeanAgelb10.zEp.1999}}\\
%\hfil \includegraphics[width=.75\paperwidth]{\Sexpr{
#paste0(pathsaveThisVer, "Placebo2ImpactsByGenderByDemeanAgelb10.pdf")
}}\\

\renewcommand{\arraystretch}{1}
\hfil\begin{tabular}{>{\hfill\scriptsize}p{1cm}<{}>{\scriptsize}p{12cm}<{\hfill}}
Source:& Compiled from IFPRI data. \\[-1ex]
Notes:& 1. Coefficients on agricultural HH dummy $\times$ year 2002 dummy. \textsf{all-1} indicates specification 1 of all children sample, \textsf{direct-1} indicates specification 1 of direct offspring sample.\\[-1ex]
& 2. Error bars use cluster robust standard errors at thana level with Satterthwaite correction for degree of freedom.
\end{tabular}
\end{figure}



FD and raw DID are numerically identical in a two-period panel. If we add covariates, FD automatically controls for individual FEs while DID needs explicit inclusion of individual dummy variables. Without including individual dummy variables, correlations of individual FEs with other covariates affect the value of estimates thus FD and DID estimates will differ. Unfortunately, adding FEs at the individual level, with the order of hundreds to thousands, is practically infeasible to implement in estimation. So most econometric and statistical programs use FE implementation. 
\begin{quote}
In practice, with many individuals it is typically not feasible to estimate
the individual dummy variables in equation (3) directly. Instead, the model
is either estimated by differencing out the fixed effect or by taking deviations from means. \\
\hfill \href{https://econ.lse.ac.uk/staff/spischke/ec524/evaluation3.pdf}{Stephen Pischke} (p.13)
\end{quote}
<<main DID BRL, eval = F, cache = F>>=
knitr::opts_current$get()$label
@
uniquid == 4059.03
<<main DID BRL2, eval = F, cache = F>>=
library(clubSandwich)
clusterlevel <- "thana"
regressors.list <- list(
  main = regressorsD
)
UseSmallClusterCorrection <- "satterthwaite" # use bias reduced linearlization of CRSE
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zEm.1999[, yr2 := as.numeric(1:.N>1), by = uniquid]
cohort.years.list <- list(# year age is defined
  main = rep(1999, 4), # main: use 1999 age to set age range
  placebo = c(rep(2002, 2), rep(1999, 2))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
InterYearsList <- list(main = rep(2002, 4), placebo = rep(c(2006, 2002), each = 2))
variables.always.use <- "schoolp|Enrolled|^yr2$|^agHH$|^agHH.yr2|^thana$|uniqu"
# create ownwater*agHH*yr2 interaction terms
zEm.1999[, ownwater.agHH0.yr2 := ownwater*agHH0.yr2]
zEm.1999[, kutchalatrine.agHH0.yr2 := kutchalatrine*agHH0.yr2]

yrXs <- c("yr2", "yr3")
main.reorder.DID = c("^.Inter|agHH$|^yr.$|age2$|sex$|yield|^(any)?prog|rain|^high|^low|Std|hd.*y$|sp.*y$|asset$|land$|water$|rine$|",
    "^agHH.yr\\d$|^sex.yr\\d$|^...e.*y.yr\\d$|hd.?sex.yr\\d$|Sib..yr\\d$|^pc.*yr.$|water.yr.$|rine.yr.$|",
    "^sex.ag.*yr\\d$|^...e.*y.ag.*yr\\d$|hd.?sex.ag.*yr\\d$|Sib.*H.*\\d$|^pc.*ag.*yr.$|water.ag.*yr.$|rine.ag.*yr.$")
mix.reorder <- function(x, y=main.reorder.DID) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.DID) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = paste0(main.reorder.DID, collapse = "")
  , placebo = paste0(main.reorder.DID, collapse = "")
)
samples <- c("main", "placebo")
z23 <- c("z2", "z3")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999")
boxWidth <- 4
centerWidth <- 1.3
Enr.DID <- Enrchg.DID <- NULL
results <- resultsN <- NULL # ii
ii <- jj <- s <- m <- 1
j <- 2 # nuclear
zSobj <- get(zsobj[ii])
regressorsS <-  regressors.list[[ii]]
cohort.years <- cohort.years.list[[ii]]
cutout.year <- cutout.years[ii]
InterYears <- InterYearsList[[ii]]
var.always.use <- gsub("yr2", yrXs[ii], variables.always.use)
reorder <- reorder.list[[ii]]
regsnd <- rep("schoolp", length(regressorsS))
est <- res <- vector("list", length = length(regressorsS)) # k, specification
results0 <- resultsN0 <- resul <- res
tabextend <- c("yes", "", "yes", "")
tabcohortdemeaned <- c("", "yes", "", "yes")
z1 <- changehyphen(get(zSobj[jj]))
s0 <- (10:12)[s]
i <- paste0("older", s0)
# latter panel: s <= age <= maxAge in 1999/2002
iiid <- unique(z1[
  s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
  eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= 18 
  #maxAge
  , uniquid])
# Keep only former complete panel and respective years.
z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
z2[, grepout("exist|In", colnames(z2)) := NULL]
z2 <- dropunbalanced(z2, returnDT = T)
# nuclear family
z3 <- z2[sd == 1, ]
z3 <- dropunbalanced(z3, returnDT = T)
cat("\n\nage cutoff:", i, "\n\n")
print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
cat("dimension of original z1:", dim(z1), "\n")
cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
cat("dimension of z2 after keeping only balanced portion:", 
dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
cat("number of individuals in the panel:")
print(table(table(z2[, uniquid])))
cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
cat("first-diffference estimator\n")
zz0 = copy(get(z23[j]))
setkey(zz0, uniquid, survey)
zz0[, survey := NULL]
# FE operations: Not demeaned: 
# To purge demeaned covariates, rename level covariates with UD
allcovariates <- grepout(paste(regressorsD, collapse = "|"), colnames(zz0))
levelcovariates <- c(grepout(weather.variables1, colnames(zz0)), 
  "yield", "program", "age2", "pcland", "pcnlasset")
# drop all time invariant covariates
zz0[, allcovariates[!(allcovariates %in% c("sex", levelcovariates))] := NULL]
zz0[, program := as.numeric(program)]
# demean time variant level covariates UDx
zz0[, (levelcovariates) := lapply(.SD, function(x) as.numeric(x) - mean(as.numeric(x), na.rm = T)), 
  by = uniquid, .SDcols = levelcovariates]
zz = copy(zz0)
# Use a particular agHH definition.
# change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
setnames(zz, 
  grepout(aghh.defs[m], colnames(zz))
  ,
  gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
)
# drop other ag HH definition
zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
# Demean dummies (head and spouse variables are already demeaned)
demeanedcols <- c("yr2", "agHH")
zz[, (demeanedcols) := lapply(.SD, function(x) x - mean(x)), .SDcols = demeanedcols]
zz[, agHH.yr2 := agHH*yr2]
zz[, sex.yr2 := sex*yr2]
zz[, sex.agHH.yr2 := sex*agHH*yr2]
zz[, sex := as.numeric(sex>0)]
ns <- resul <- NULL
# First run: Estimation loop for getting N (number of obs) and first-differenced data.
for (k in 1:length(regressorsS))
{
  if (s0 == 10 & j == 1 & m == 1) {
    cat(paste0("(", k, ")\n"))
    print0(paste0("+ ", 
      grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
  }
  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
  # pick covariates for k-th regression: 
  #  paste " ..|.." & "..|.." with collapse = "|"
  #  then use it in grepout
  covariates <- grepout(
    paste(var.always.use, regrsr, sep = "|", collapse = "|")
    , colnames(zz))
  zr <- zz[, covariates, with = F]
  formDID <- paste(regsnd[k], "~", 
    paste(covariates[!grepl("^uniquid$|^thana$|schoolp", covariates)], collapse = "+"))
  formDID <- as.formula(formDID)
  rs <- lm(data=data.frame(zr), formDID)
  de <- zr[, .(enroll = mean(schoolp)), by = .(yr2, agHH)]
  de[, .(diff = diff(enroll), mean = mean(enroll)), by = agHH]
  if (length(rs$na.action) > 0) 
    zrdata <- zz[-(rs$na.action), c("uniquid", covariates), with = F] else
    zrdata <- zz[, c("uniquid", covariates), with = F]
  resul[[k]] <- list(level.data = zrdata, est = rs$coeff)
  est[[k]] <- round(summary(rs)$coeff[, -3], 5)
  ns <- c(ns, nrow(rs$model))
}
# resultsN0: raw results (not under same obs)
resultsN0 <- resul
# First run estimation data is stored in resul.
# Pick the last item of data list which has the least num of obs. 
# (This is data to use for all specifications.)
# zidd: Differenced data of the last item in resul.
# zid: Level data only to get agHH (because agHH is not included in zidd).
# Merge zidd with zid to attach agHH to zidd.
zid <- lapply(resul, "[[", "level.data")
zz2 <- leveldata <- zid[[length(zid)]]
# For an expositional purpose, do not demean.
# Demeaning makes reg coeffs  in 1st specification not matching with raw means.
zz2[, yr2 := as.numeric(yr2>0)]
zz2[, agHH := as.numeric(agHH>0)]
zz2[, agHH.yr2 := agHH*yr2]
rs <- lm(data=zz2, schoolp ~ agHH + yr2 + agHH.yr2)
rsco <- as.numeric(rs$co)
# FD estimation
diffcols <- c("schoolp", "yr2", "agHH.yr2")
dzz <- zz2[, lapply(.SD, diff), by = uniquid, .SDcols = diffcols]
rs <- lm(data=dzz, schoolp ~ agHH.yr2)
rsco <- as.numeric(rs$co)
print(de <- zz2[, .(enroll = mean(schoolp)), by = .(yr2, agHH)])
print(c(rsco[1]+rsco[2], sum(rsco), rsco[1], rsco[1]+rsco[3]))
print(c(agHHdiff = sum(rsco), nonagHHdiff = rsco[1], agHH.yr2 = rsco[2]))
print(de[, .(diff = diff(enroll)), by = agHH])
enrr <- zz2[, .(EnRate = mean(schoolp), Num = .N), by = .(agHH, yr2)]
Enr.DID <- rbind(Enr.DID, 
  cbind(zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
    s0, enrr),
  use.names = F
)
# Save mean enrollment rate changes
# x: agHH, y: nonagHH
ttestE <- t.test(
  zz2[agHH == 1, .(diff=diff(schoolp)), by = uniquid][, diff], 
  zz2[agHH == 0, .(diff=diff(schoolp)), by = uniquid][, diff])
Enrchg.DID <- rbind(Enrchg.DID, 
  cbind(
      zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
      s0, round(-diff(unlist(ttestE["estimate"])), 5), # -diff = -(y - x) = AgHH - nonagHH
      t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
      )
    )
demeanedcols <- c("yr2", "agHH")
zz2[, (demeanedcols) := lapply(.SD, function(x) x - mean(x)), .SDcols = demeanedcols]
zz2[, agHH.yr2 := agHH*yr2]
var.always.use <- paste0(var.always.use, "|^LHS$")
Rs <- ns <- NULL
for (k in 1:length(regressorsS))
{
  if (s0 == 10 & j == 1 & m == 1) {
    cat(paste0("(", k, ")\n"))
    print0(paste0("+ ", 
      grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz2))))
  }
  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
  # pick covariates for k-th regression: 
  #  paste " ..|.." & "..|.." with collapse = "|"
  #  then use it in grepout
  covariates <- grepout(
    paste(var.always.use, regrsr, sep = "|", collapse = "|")
    , colnames(zz2))
  zr <- zz2[, covariates, with = F]
  formDID <- paste(regsnd[k], "~", 
    paste(covariates[!grepl("^uniquid$|^thana$|schoolp", covariates)], collapse = "+"))
  formDID <- as.formula(formDID)
  rs <- lm(data=data.frame(zr), formDID)
  require(clubSandwich)
  estres <- clubSandwich::coef_test(rs, vcov = "CR2", 
    cluster = as.numeric(zr[, thana]), test = "Satterthwaite")
  estres <- as.data.frame(estres)
  estres <- estres[, -1]
  colnames(estres)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
  resul[[k]] <- 
    list(est = rsl$est, ci = rsl$CI,
      df = rs$df.residual, reg = rs,
      level.data = zr)
  est[[k]] <- round(estres[, -3], 5)
  Rs <- c(Rs, summary(rs)$adj.r)
  ns <- c(ns, nrow(rs$model))
}
results0 <- resul
# Drop df (satterthwaite) column of clubSandwich outputs
# est <- lapply(est, function(x) x[, -3])
assign(paste0("addthis", j),
   rbind("\\hspace{.5em}thana dummies" = 
      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
     "n" = ns,
     "control mean at baseline" = 
       rep(formatC(enrr[yr2 == 0 & agHH == 0, EnRate], 
         digits = 4, format = "f"), length(regressorsS)),
     "control mean at follow up" = 
       rep(formatC(enrr[yr2 == 1 & agHH == 0, EnRate], 
         digits = 4, format = "f"), length(regressorsS)),
     "control raw mean difference" = 
       rep(formatC(enrr[yr2 == 1 & agHH == 0, EnRate]-enrr[yr2 == 0 & agHH == 0, EnRate], 
         digits = 4, format = "f"), length(regressorsS)),
     "treated mean at baseline" =
       rep(formatC(enrr[yr2 == 0 & agHH == 1, EnRate], 
         digits = 4, format = "f"), length(regressorsS)),
     "treated mean at follow up" = 
       rep(formatC(enrr[yr2 == 1 & agHH == 1, EnRate], 
         digits = 4, format = "f"), length(regressorsS)),
     "treated raw mean difference" = 
       rep(formatC(enrr[yr2 == 1 & agHH == 1, EnRate]-enrr[yr2 == 0 & agHH == 1, EnRate], 
         digits = 4, format = "f"), length(regressorsS))
   )
)
#tbest <- tabulate.est(est, reorder, output.in.list = T,
#  LastLineVariables = c("^r.*Y$|^l.*Y", "latrine.yr.$"),
#  InterWithTexts = paste0(cohort.years[jj], c("", "*agricultural household")),
#  addbottom = get(paste0("addthis", j)), subst.table = sbt)
# saveEstTable is in functions.R 
# source("C:/seiro/settings/Rsetting/functions.R", echo=F)
# source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
# reorder is main.reorder.DID
tbest <- Tab.Est(est, reorder, output.in.list = T,
  TableFormat = "satt",
  LastLineVariables = c("atrine$", "kut.*e.yr.$"),
  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
  DeleteRowStrings = "^p\\$|^CI\\$|^DoF\\$",
  addbottom = get(paste0("addthis", j)), subst.table = sbt)
# saveEstTable is in source("C:/seiro/settings/Rsetting/functions.R", echo=F)
iispace <- which(
  grepl(".", tbest[[1]]) & 
  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
  )
iispace2 <- iispace[seq(2, length(iispace), 2)]
# Split a table in to 2 tables
tbest11 <- tbest[[1]][1:(grep("inter.*2002.*ag", tbest[[1]])-3)]
tbest12 <- tbest[[2]][1:(grep("inter.*2002.*ag", tbest[[1]])-3), ]
tbest21 <- tbest[[1]][grep("inter.*2002.*ag", tbest[[1]]):length(tbest[[1]])]
tbest22 <- tbest[[2]][grep("inter.*2002.*ag", tbest[[1]]):length(tbest[[1]]), ]
iispace11 <- which(
  grepl(".", tbest11) & 
  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
  )
iispace12 <- iispace11[seq(2, length(iispace11), 2)]
iispace21 <- which(
  grepl(".", tbest21) & 
  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
  )
# drop last rows of tbest2 to shrink row space
iispace21 <- iispace21[iispace21 < grep("nonland", tbest21)]
iispace22 <- iispace21[seq(2, length(iispace21), 2)]
tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
  hleft = "\\hfil\\scriptsize$", hright = "$", 
  hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
  delimiterline = NULL, adjustlineskip = "-0.7ex", 
  adjlskiprows = c(iispace11, iispace11+1),
  alternatecolorManual = c(iispace12, iispace12+1, iispace12+2),
  alternatecolorManualColor = "gray80")
tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
  estimationspacelast = grep("thana dummi", tbest21),
  hleft = "\\hfil\\scriptsize$", hright = "$", 
  hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
  delimiterline = NULL, adjustlineskip = "-0.7ex", 
  adjlskiprows = c(iispace21, iispace21+1),
  alternatecolorManual = c(iispace22, iispace22+1, iispace22+2),
  alternatecolorManualColor = "gray80")
# Modify "interaction with ..." lines to use multicolumn
InterRows1 <- grep("nteract.*\\d", tbl1)
InterRows2 <- grep("nteract.*\\d", tbl2)
for (ir in InterRows1)
  if (any(grepl("rowcolor", tbl1[ir])))
    tbl1[ir] <- 
      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
      # For rows with rowcolor command at the end
      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
        gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
        )
        ) else
      # For rows without rowcolor command at the end
    tbl1[ir] <- 
      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
        gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
        )
        )
for (ir in InterRows2)
  if (any(grepl("rowcolor", tbl2[ir])))
    tbl2[ir] <- 
      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
      # For rows with rowcolor command at the end
      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
        gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
        )
        ) else
      # For rows without rowcolor command at the end
    tbl2[ir] <- 
      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
        gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
        )
        )
pathtosavedtable1 <- TabFilePathF(
  FolderPath = pathsaveThisVer, 
  Sample = gsub("\\.", "", zSobj[jj]), 
  Estimator = "DID",
  AgeCutoff = paste0("Older", (10:12)[s]),
  HHType = c("", "Nuclear")[j],
  AgHHDef = c("", "Is", "Hd", "Occ")[m],
  CRSEMethod = "Satterthwaite1"
)
pathtosavedtable2 <- TabFilePathF(
  FolderPath = pathsaveThisVer, 
  Sample = gsub("\\.", "", zSobj[jj]), 
  Estimator = "DID",
  AgeCutoff = paste0("Older", (10:12)[s]),
  HHType = c("", "Nuclear")[j],
  AgHHDef = c("", "Is", "Hd", "Occ")[m],
  CRSEMethod = "Satterthwaite2"
)
write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
cat("Table saved as", pathtosavedtable1, "\n")
cat("Table saved as", pathtosavedtable2, "\n")
results[[ii]] <- results0
resultsN[[ii]] <- resultsN0
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
library(qs)
qsave(results, paste0(pathsaveThisVer, "FD_DIDCRCoV_results.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "FD_N_DIDCRCoV_results.qs"))
Enr.DID <- data.table(Enr.DID)
Enrchg.DID <- data.table(Enrchg.DID)
setnames(Enrchg.DID, c("sample", "HHtype", "agHHdef", "age", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(Enr.DID, c("sample", "HHtype", "agHHdef", "age", "agHH", "tee", "rate", "Obs"))
qsave(Enr.DID, paste0(pathsaveThisVer, "Enr.DID.qs"))
qsave(Enrchg.DID, paste0(pathsaveThisVer, "Enrchg.DID.qs"))
@

<<main FD estimation of DID equivalent, eval = F, results = 'hide', cache = F>>=
library(clubSandwich)
clusterlevel <- "thana"
DivInto2Tables <- T
source(paste0(pathprogram0, "TabGeneric.R"))
regressors.list <- list(
  main = c("^\\(Interce", "age2", 
    paste(yield, weather.variables1, sep = "|"), "^sex.yr2|^sex.agHH.yr2")
)
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds")) 
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
# non ag HHs have no siblings in agriculture...this is how we defined ag HHs.
zEm.1999[survey==1999 & age>=10 & age<=18, 
  .(AgSibM=mean(UDOldAgSibM, na.rm= T), SibM=mean(UDOldSibM)), by = agHH0]
samples <- c("main", "placebo")
z234 <- c("z2", "z3", "z4")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999") 
zmobj <- "zEm.1999"
# jj: 1,2 = 10-18 in 2002, 3,4 = 10-18 in 1999, 5 = 6-9 in 1999
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999", "zYp.1999")[c(1, 3)]
cohort.years.list <- list(# year age is defined
  main = rep(1999, 2), # main: use 1999 age to set age range
  placebo = c(rep(2002, 1), rep(1999, 1))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
# Used in "interaction with year InterYears" in results table
InterYearsList <- list(main = rep(2002, 2), placebo = rep(2006, 2))
variables.always.use <- "schoolp|Enrolled|^agHH.yr2|^agHH$|^thana$|uniqu|^UDnon|^UDfl|^UD.*Sib|^UDhds|^pcland$|^pcnlasset$"
yrXs <- c("yr2", "yr3")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
  , main.agewise = mix.reorder("^agHH$|^agH.*2$|^D.*yA.*agHH.yr2$|^D.*yA.*\\.1\\d\\.yr2$|")
  , main.classwise = mix.reorder("^agHH$|^agH.*2$|^D.*yA.*agHH.yr2$|^D.*yA.*\\.1\\d\\.yr2$|^Du.*Ed.*|")
  , placebo.young = mix.reorder("^agHH$|^agHH.yr3$|^hdagHH.yr3$|")
  , placebo.agewise = mix.reorder("^agHH$|^agH.*3$|^D.*yA.*agHH.yr3$|^D.*yA.*\\.1\\d\\.yr3$|")
)
boxWidth <- 4
centerWidth <- 1.3
Enr.Base <- Enrchg.Base <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
names(results) <- names(resultsN) <- samples
ii <- jj <-  m <- s <- 1
j <- 2
SkipLowerBound <- 50
  zSobj <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  yrX <- yrXs[ii]
  var.always.use <- gsub("yr2", yrX, variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("schoolp", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  res <- list(demeaned = res, undemeaned = res) # dd, demeaned/level interactions
  # res[[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  names(results0) <- names(resultsN0) <- zSobj
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    for (dd in 1:2) {
      z1 = copy(z01)
      if (dd == 2) {
        ## Restore undemeaned interactions: Start 
        # 1. Drop demeaned interactions
        iiyr <- grepout("\\.yr", colnames(z1))
        iiyr <- gsub("\\.yr.", "", iiyr)
        iiyr <- unique(gsub("\\...agHH|\\.agHH0", "", iiyr))
        # interactions
        iiyrX <- paste0(iiyr, ".", yrX)
        iiagHHyrX <- 
          paste0(rep(iiyr, each = length(aghh.defs)), ".", rep(aghh.defs, length(iiyr)), ".", yrX)
        # drop demeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NULL]
        # 2. Form undemeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NA]
        z1[, (yrX) := as.integer(1:.N-1), by = uniquid]
        # restore demeaned agHH def terms as binary variables
        for (mm in aghh.defs) {
          set(z1, i = which(z1[[mm]] > 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 1L)
          set(z1, i = which(z1[[mm]] <= 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 0L)
        }
        # restore demeaned covariates: copy from corresponding UDX (undemeaned X)
        for (kk in iiyr)
          set(z1, j = grep(kk, colnames(z1)), value = z1[[paste0("UD", kk)]])
        # form level interactions
        # X.yrx
        for (i in 1:length(iiyr))
          set(z1, j = grep(paste0("^", iiyrX[i]), colnames(z1)), value = z1[[iiyr[i]]]*z1[[yrX]])
        # X.agHH.yrx
        for (kk in iiyr)
          for (mm in aghh.defs)
            set(z1, j = grep(paste0("^", kk, ".", mm, ".", yrX),  colnames(z1)), 
              value = z1[[kk]]*z1[[mm]]*z1[[yrX]])
        ## Restore undemeaned interactions: End 
      } # end: if dd == 2
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      tabextend <- c("yes", "", "yes", "")
      tabcohortdemeaned <- c("", "yes", "", "yes")
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      if (ii == 2 & jj == 5) smax <- 1 else smax <- 3
        s0 <- (10:12)[s]
        if (ii == 2 & jj == 5) {
          s0 <- 6
          MaxAge <- 9
        } else {
          MaxAge <- 18
        }
        i <- paste0("older", s0)
        # latter panel: s <= age < maxAge in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
          #maxAge
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        z4 <- z2[sd != 1, ]
        z4 <- dropunbalanced(z4, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
          zz00 <- get(z234[j])
          setkey(zz00, uniquid, survey)
          zz00[, survey := NULL]
            if (ge == 1) {
              zz0 = copy(zz00[sex <= 0, ]) 
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else  if (ge == 2){
              zz0 = copy(zz00[sex > 0, ])
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else zz0 = copy(zz00)
            if (nrow(zz0) < SkipLowerBound) {
              cat("Skipped due to small number of obs:", nrow(zz0), "\n")
              next
            }
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              ns <- NULL
              resul <- est <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                # pick covariates for k-th regression: 
                #  paste " ..|.." & "..|.." with collapse = "|"
                #  then use it in grepout
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                # if (ii == 2 & jj == 1)
                #if (grepl("zEp.2|zSp", zSobj[jj]))
                # zEp.2002: UDOldSibF is all 0, UDOldSibM is all 0 but 2 obs, so drop them (and interactions).
                #  covariates <- covariates[!grepl("OldSib", covariates)]
                covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)] # drop real valued level variables
                zr <- zz[, covariates, with = F]
                # source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$|^UD|^pc.*[dt]$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   # opposite.time.order: set to F to get t-(t-1) difference. 
                   # (to be used in DID2 in the later chunk)
                   # Under F, diff(LHS) = -1 if schoolp 1 (1999) -> 0 (2002).
                   # agHH.yr2 is demeaned interaction (of agHH and yr2=1999 dummies), 
                   #   275 of obs (agHH==0) =  .59 because   -.39  (1999)  ->  .20 (2002)
                   #   407 of obs (agHH==1) = -.401 because  .266 (1999) -> -.135 (2002)
                   # In diff data, ag HH who dropped out: LHS = -1, agHH.yr2 = -.4 => OLS estimate > 0.
                   # A larger drop in LHS (more negative) for agHH == 1 dummy 
                   # needs agHH.yr2 to be defined as a positive value.
                   # Similarly, sex (female) == 1 gives diff(sex.yr2) < 0 for females in t-(t-1) diff. 
                   # X.yr2 needs to be defind as positive. To do so, in DID2, 
                   # one needs to set opposite.time.order = F & all time variant covariates
                   # to be X.yr2 := -1 * X.yr2 [so diff(agHH.yr2) > 0].
                   opposite.time.order = F, # Use t - (t-1) diff
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                #jj: zF, zE, zS
                #s: age cutoff
                #j: nuclear or extended
                #m: agHH def
                #k: specification
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              if (!any(grepl("latrine.agHH.yr|water.agHH.yr", rownames(est[[k]])))) {
                cat(zSobj[jj], "agelb", s0, z234[j], c("boys", "girls", "boys+girls")[ge], 
                  c("demeaned", "undemeaned")[dd], aghh.defs[m], "\n")
                cat("Skipped, some covariates cannot be used due to too small number of obs:", nrow(zr), "\n\n")
                next
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[dd]][[s]][[j]][[ge]][[m]] <- resul
              # First run estimation data is stored in resul.
              # Pick the last item of data list which has the least num of obs. 
              # (This is data to use for all specifications.)
              # zidd: Differenced data of the last item in resul.
              # zid2: Level data to reconstruct and demean interaction terms of covariates.
              if (dd == 1) 
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) else {
                zidd <- lapply(resul, "[[", "diff.data")
                zidd <- zidd[[length(zidd)]]
                zid = copy(z2[uniquid %in% zidd[, uniquid], ])
                # drop other agHH defs and their interactions
                if (length(iiothag <- 
                  grep(paste0(gsub("\\\\\\.", "", aghh.defs.regexpr[-m]), collapse = "|"), colnames(zid))) > 0)
                  zid[, (iiothag) := NULL]
                # change agHH def name to "agHH"
                setnames(zid, 
                  grepout(aghh.defs[m], colnames(zid))
                  ,
                  gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zid)))
                )
                zid[, Enrolled := schoolp]
              }
              zidd[, tee := 1]
              enrr <- zid[, .(EnRate = mean(Enrolled), Num = .N), by = .(agHH, tee)]
              Enr.Base <- rbind(Enr.Base, 
                cbind(zSobj[jj], c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m], 
                  c("demeaned", "level")[dd], s0, enrr),
                use.names = F
              )
              # Save mean enrollment rate changes
              # x: agHH, y: nonagHH
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "Enrolled")
              ttestE <- t.test(zidd[agHH == 1, Enrolled], zidd[agHH == 0, Enrolled])
              Enrchg.Base <- rbind(Enrchg.Base, 
                cbind(
                    zSobj[jj], c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m], 
                    c("demeaned", "level")[dd], s0, -diff(unlist(ttestE["estimate"])), # -diff = -(y - x) = AgHH - nonagHH
                    t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                    )
                  )
              #for (cl in c("LiangZeger", "satterthwaite", "wildclusterboot")) 
              for (cl in c("LiangZeger", "satterthwaite")) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl
                cat("\n\n###", cl, "###\n\n")
                #if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl) & any(grepl("Sib", colnames(zidd)))) {
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  # Julia fails for specification 6 in zEm.1999, zEp.1999, zEp.2002
                  if (grepl("wild", cl) & k == 6) next
                  #if (ii == 1 & grepl("S", zSobj[jj]) & s >= 1 & m == 4 & k >= 5 & grepl("wild", cl)) 
                  #zSm1999FDOlder10Occ
                  #  next
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  # var.always.use has level variables used only for destat purpose, so drop them
                  covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)]
                  # Commented out: Aug 2, 2023 Start
                  #if (grepl("zEp|zSp", zSobj[jj]))
                  #  covariates <- covariates[!grepl("OldSib", covariates)]
                  # Commented out: Aug 2, 2023 End
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "Enrolled", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  results0[[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                    list(est = rsl$est, ci = rsl$CI,
                      df = rsl$reg$df, reg = rsl$reg,
                      #level.data = leveldata[, gsub("Enrolled", "LHS", covariates), with = F], 
                      level.data = zid, 
                      diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  # Sign reversion is done before DID2. Below is redundant.
                  # Take19992002Diff is set to F in "read data chunk" at the beginning
                  # If (t-1) - t difference (opposite time order), signs of yrX cross terms are inverted.
                  #if (Take19992002Diff) est[[k]][grepout("Inter|yr.$", rownames(est[[k]])), c(1, 3)] <- 
                  #  -1 * est[[k]][grepout("Inter|yr.$", rownames(est[[k]])), c(1, 3)]
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean at baseline" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "control mean at follow up" = 
                       rep(formatC(enrr[tee == 2 & agHH == 0, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at baseline" =
                       rep(formatC(enrr[tee == 1 & agHH == 1, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at follow up" =
                       rep(formatC(enrr[tee == 2 & agHH == 1, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "raw DID" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1, EnRate] - enrr[tee == 1 & agHH == 1, EnRate] 
                       -(enrr[tee == 2 & agHH == 0, EnRate] - enrr[tee == 1 & agHH == 0, EnRate]), 
                         digits = 2, format = "f"), length(regressorsS))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "epc"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source(paste0(pathprogram, "tabulate_est.R"))
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, 
                  CIInTinySize = T, 
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$",
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                  # Split a table in to 2 tables
                if (DivInto2Tables) {
                  # Split a table in to 2 tables
                  if (grepl("e[ps]$", OUTformat)) 
                    NumRowsAfterEst <- 2 else 
                    NumRowsAfterEst <- 3
                  tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                  tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                  tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                  tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                  iispace11 <- which(
                    grepl(".", tbest11) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                    )
                  iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                  iispace21 <- which(
                    grepl(".", tbest21) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                    )
                  # drop last rows of tbest2 to shrink row space
                  iispace21 <- iispace21[iispace21 < grep("toilet|water", tbest21)]
                  iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                  if (grepl("e[ps]$", OUTformat)) {
                  # ep, es: 2 rows per estimate
                    AdjustLineSkipRows1 <- iispace11
                    AltColorRows1 <- c(iispace12, iispace12+1)
                    AdjustLineSkipRows2 <- iispace21
                    AltColorRows2 <- c(iispace22, iispace22+1)
                  } else {
                  # epc, esc, satt: 3 rows per estimate
                    AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                    AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                    AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                    AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                  }
                 #source("c:/seiro/settings/Rsetting/functions.R")
                  tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows1,
                    alternatecolorManual = AltColorRows1,
                    alternatecolorManualColor = "gray80")
                  tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest21),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows2,
                    alternatecolorManual = AltColorRows2,
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows1 <- grep("nteract.*\\d", tbl1)
                  InterRows2 <- grep("nteract.*\\d", tbl2)
                  for (ir in InterRows1) {
                    if (any(grepl("rowcolor", tbl1[ir])))
                      tbl1[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl1[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          )
                    # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                    # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                    tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                    tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                    tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                  }
                  for (ir in InterRows2) {
                    if (any(grepl("rowcolor", tbl2[ir])))
                      tbl2[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl2[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          )
                    tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                    tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                    tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                  }
                  clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                  # file path to saved table
                  pathtosavedtable1 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]), 
                    AgeCutoff = paste0("Older", (10:12)[s]),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 1)
                    )
                  pathtosavedtable2 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]), 
                    AgeCutoff = paste0("Older", (10:12)[s]),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 2)
                    )
                  write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable1, "\n")
                  cat("Table saved as", pathtosavedtable2, "\n")
                } else {
                  # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                  iispace <- which(
                    # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                    grepl(".", tbest[[1]]) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                    )
                  iispace2 <- iispace[seq(2, length(iispace), 2)]
                  # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                  # adjlskiprows = c(iispace, iispace+1)
                  # saveEstTable is in functions.R
                  # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                  tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest[[1]]),
                    hleft = "\\hfil\\tiny$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.5ex", 
                    adjlskiprows = c(iispace, iispace+1),
                    alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                    alternatecolorManualColor = "gray80")
                  if (grepl("Liang", cl))
                    tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                      estimationspacelast = grep("thana dummi", tbest[[1]]),
                      hleft = "\\hfil\\tiny$", hright = "$", 
                      hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                      delimiterline = NULL, adjustlineskip = "-0.5ex", 
                      adjlskiprows = c(iispace),
                      alternatecolorManual = c(iispace2, iispace2+1),
                      alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows <- grep("nteract.*\\d", tbl)
                  for (ir in InterRows)
                    if (any(grepl("rowcolor", tbl[ir])))
                      tbl[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          ) else
                        # rows without rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          )
                  pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]), 
                    AgeCutoff = paste0("Older", (10:12)[s]),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                  write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable, "\n")
                } # if end: DivInto2Tables
              } # cl: SE clustering option
    }  # dd: demeaned/level interaction
  results[[ii]] <- results0
  resultsN[[ii]] <- resultsN0
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
library(qs)
qsave(results, paste0(pathsaveThisVer, "FD_MainCRCoV_results.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "FD_N_MainCRCoV_results.qs"))
# results <- qread(paste0(pathsaveThisVer, "FD_MainCRCoV_results.qs"))
Enr.Base <- data.table(Enr.Base)
Enrchg.Base <- data.table(Enrchg.Base)
setnames(Enrchg.Base, c("sample", "HHtype", "agHHdef", "demean", "age", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(Enr.Base, c("sample", "HHtype", "agHHdef", "demean", "age", "agHH", "tee", "rate", "Obs"))
qsave(Enr.Base, paste0(pathsaveThisVer, "Enr.Base.qs"))
qsave(Enrchg.Base, paste0(pathsaveThisVer, "Enrchg.Base.qs"))
@


<<main DID BRL3, eval = F, cache = F>>=
library(clubSandwich)
clusterlevel <- "thana"
UseSmallClusterCorrection <- "satterthwaite" # use bias reduced linearlization of CRSE
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zEm.1999[, yr2 := as.numeric(1:.N>1), by = uniquid]
cohort.years.list <- list(# year age is defined
  main = rep(1999, 4), # main: use 1999 age to set age range
  placebo = c(rep(2002, 2), rep(1999, 2))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
InterYearsList <- list(main = rep(2002, 4), placebo = rep(c(2006, 2002), each = 2))
regressors.list <- list(
  main = regressorsD,
  placebo = regressorsM2002
)
variables.always.use <- "schoolp|Enrolled|^yr2$|^agHH$|^agHH.yr2|^thana$|uniqu"
# create ownwater*agHH*yr2 interaction terms
zEm.1999[, ownwater.agHH0.yr2 := ownwater*agHH0.yr2]
zEm.1999[, kutchalatrine.agHH0.yr2 := kutchalatrine*agHH0.yr2]

yrXs <- c("yr2", "yr3")
main.reorder.DID = c("^.Inter|agHH$|^yr.$|age2$|sex$|yield|^(any)?prog|rain|^high|^low|Std|hd.*y$|sp.*y$|asset$|land$|water$|rine$|",
    "^agHH.yr\\d$|^sex.yr\\d$|^...e.*y.yr\\d$|hd.?sex.yr\\d$|Sib..yr\\d$|^pc.*yr.$|water.yr.$|rine.yr.$|",
    "^sex.ag.*yr\\d$|^...e.*y.ag.*yr\\d$|hd.?sex.ag.*yr\\d$|Sib.*H.*\\d$|^pc.*ag.*yr.$|water.ag.*yr.$|rine.ag.*yr.$")
mix.reorder <- function(x, y=main.reorder.DID) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.DID) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = paste0(main.reorder.DID, collapse = "")
  , placebo = paste0(main.reorder.DID, collapse = "")
  , main.agewise = mix.reorder("^agHH$|^agH.*2$|^D.*yA.*agHH.yr2$|^D.*yA.*\\.1\\d\\.yr2$|")
  , main.classwise = mix.reorder("^agHH$|^agH.*2$|^D.*yA.*agHH.yr2$|^D.*yA.*\\.1\\d\\.yr2$|^Du.*Ed.*|")
  , placebo.young = mix.reorder("^agHH$|^agHH.yr3$|^hdagHH.yr3$|")
  , placebo.agewise = mix.reorder("^agHH$|^agH.*3$|^D.*yA.*agHH.yr3$|^D.*yA.*\\.1\\d\\.yr3$|")
)
samples <- c("main", "placebo")
z23 <- c("z2", "z3")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999")
boxWidth <- 4
centerWidth <- 1.3
Enr.DID <- Enrchg.DID <- NULL
results <- resultsN <- NULL # ii
ii <- jj <- s <- m <- 1
j <- 2 # nuclear
zSobj <- get(zsobj[ii])
regressorsS <-  regressors.list[[ii]]
cohort.years <- cohort.years.list[[ii]]
cutout.year <- cutout.years[ii]
InterYears <- InterYearsList[[ii]]
var.always.use <- gsub("yr2", yrXs[ii], variables.always.use)
reorder <- reorder.list[[ii]]
regsnd <- rep("schoolp", length(regressorsS))
est <- res <- vector("list", length = length(regressorsS)) # k, specification
results0 <- resultsN0 <- resul <- res
tabextend <- c("yes", "", "yes", "")
tabcohortdemeaned <- c("", "yes", "", "yes")
z1 <- changehyphen(get(zSobj[jj]))
s0 <- (10:12)[s]
i <- paste0("older", s0)
# latter panel: s <= age <= maxAge in 1999/2002
iiid <- unique(z1[
  s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
  eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= 18 
  #maxAge
  , uniquid])
# Keep only former complete panel and respective years.
z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
z2[, grepout("exist|In", colnames(z2)) := NULL]
z2 <- dropunbalanced(z2, returnDT = T)
# nuclear family
z3 <- z2[sd == 1, ]
z3 <- dropunbalanced(z3, returnDT = T)
cat("\n\nage cutoff:", i, "\n\n")
print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
cat("dimension of original z1:", dim(z1), "\n")
cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
cat("dimension of z2 after keeping only balanced portion:", 
dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
cat("number of individuals in the panel:")
print(table(table(z2[, uniquid])))
cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
cat("first-diffference estimator\n")
zz0 <- get(z23[j])
setkey(zz0, uniquid, survey)
zz0[, survey := NULL]
zz = copy(zz0)
# Use a particular agHH definition.
# change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
setnames(zz, 
  grepout(aghh.defs[m], colnames(zz))
  ,
  gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
)
# drop other ag HH definition
zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
# Demean dummies (head and spouse variables are already demeaned)
demeanedcols <- c("yr2", "agHH")
zz[, (demeanedcols) := lapply(.SD, function(x) x - mean(x)), .SDcols = demeanedcols]
zz[, agHH.yr2 := agHH*yr2]
ns <- resul <- NULL
# First run: Estimation loop for getting N (number of obs) and first-differenced data.
for (k in 1:length(regressorsS))
{
  if (s0 == 10 & j == 1 & m == 1) {
    cat(paste0("(", k, ")\n"))
    print0(paste0("+ ", 
      grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
  }
  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
  # pick covariates for k-th regression: 
  #  paste " ..|.." & "..|.." with collapse = "|"
  #  then use it in grepout
  covariates <- grepout(
    paste(var.always.use, regrsr, sep = "|", collapse = "|")
    , colnames(zz))
  zr <- zz[, covariates, with = F]
  formDID <- paste(regsnd[k], "~", 
    paste(covariates[!grepl("^uniquid$|^thana$|schoolp", covariates)], collapse = "+"))
  formDID <- as.formula(formDID)
  rs <- lm(data=data.frame(zr), formDID)
  de <- zr[, .(enroll = mean(schoolp)), by = .(yr2, agHH)]
  de[, .(diff = diff(enroll), mean = mean(enroll)), by = agHH]
  if (length(rs$na.action) > 0) 
    zrdata <- zz[-(rs$na.action), c("uniquid", covariates), with = F] else
    zrdata <- zz[, c("uniquid", covariates), with = F]
  resul[[k]] <- list(level.data = zrdata, est = rs$coeff)
  est[[k]] <- round(summary(rs)$coeff[, -3], 5)
  ns <- c(ns, nrow(rs$model))
}
# resultsN0: raw results (not under same obs)
resultsN0 <- resul
# First run estimation data is stored in resul.
# Pick the last item of data list which has the least num of obs. 
# (This is data to use for all specifications.)
# zidd: Differenced data of the last item in resul.
# zid: Level data only to get agHH (because agHH is not included in zidd).
# Merge zidd with zid to attach agHH to zidd.
zid <- lapply(resul, "[[", "level.data")
zz2 <- leveldata <- zid[[length(zid)]]
# For an expositional purpose, do not demean.
# Demeaning makes reg coeffs  in 1st specification not matching with raw means.
zz2[, yr2 := as.numeric(yr2>0)]
zz2[, agHH := as.numeric(agHH>0)]
zz2[, agHH.yr2 := agHH*yr2]
rs <- lm(data=zz2, schoolp ~ agHH + yr2 + agHH.yr2)
rsco <- as.numeric(rs$co)
# FD estimation
diffcols <- c("schoolp", "yr2", "agHH.yr2")
dzz <- zz2[, lapply(.SD, diff), by = uniquid, .SDcols = diffcols]
rs <- lm(data=dzz, schoolp ~ agHH.yr2)
rsco <- as.numeric(rs$co)
print(de <- zz2[, .(enroll = mean(schoolp)), by = .(yr2, agHH)])
print(c(rsco[1]+rsco[2], sum(rsco), rsco[1], rsco[1]+rsco[3]))
print(c(agHHdiff = sum(rsco), nonagHHdiff = rsco[1], agHH.yr2 = rsco[2]))
print(de[, .(diff = diff(enroll)), by = agHH])
enrr <- zz2[, .(EnRate = round(mean(schoolp), 3), Num = .N), by = .(agHH, yr2)]
Enr.DID <- rbind(Enr.DID, 
  cbind(zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
    s0, enrr),
  use.names = F
)
# Save mean enrollment rate changes
# x: agHH, y: nonagHH
ttestE <- t.test(
  zz2[agHH == 1, .(diff=diff(schoolp)), by = uniquid][, diff], 
  zz2[agHH == 0, .(diff=diff(schoolp)), by = uniquid][, diff])
Enrchg.DID <- rbind(Enrchg.DID, 
  cbind(
      zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
      s0, round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
      t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
      )
    )
demeanedcols <- c("yr2", "agHH")
zz2[, (demeanedcols) := lapply(.SD, function(x) x - mean(x)), .SDcols = demeanedcols]
zz2[, agHH.yr2 := agHH*yr2]
var.always.use <- paste0(var.always.use, "|^LHS$")
Rs <- ns <- NULL
for (k in 1:length(regressorsS))
{
  if (s0 == 10 & j == 1 & m == 1) {
    cat(paste0("(", k, ")\n"))
    print0(paste0("+ ", 
      grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz2))))
  }
  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
  # pick covariates for k-th regression: 
  #  paste " ..|.." & "..|.." with collapse = "|"
  #  then use it in grepout
  covariates <- grepout(
    paste(var.always.use, regrsr, sep = "|", collapse = "|")
    , colnames(zz2))
  zr <- zz2[, covariates, with = F]
  formDID <- paste(regsnd[k], "~", 
    paste(covariates[!grepl("^uniquid$|^thana$|schoolp", covariates)], collapse = "+"))
  formDID <- as.formula(formDID)
  rs <- lm(data=data.frame(zr), formDID)
  require(clubSandwich)
  estres <- clubSandwich::coef_test(rs, vcov = "CR2", 
    cluster = as.numeric(zr[, thana]), test = "Satterthwaite")
  estres <- as.data.frame(estres)
  estres <- estres[, -1]
  colnames(estres)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
  resul[[k]] <- 
    list(est = rsl$est, ci = rsl$CI,
      df = rs$df.residual, reg = rs,
      level.data = zr)
  est[[k]] <- round(estres[, -3], 5)
  Rs <- c(Rs, summary(rs)$adj.r)
  ns <- c(ns, nrow(rs$model))
}
results0 <- resul
# Drop df (satterthwaite) column of clubSandwich outputs
# est <- lapply(est, function(x) x[, -3])
assign(paste0("addthis", j),
   rbind("\\hspace{.5em}thana dummies" = 
      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
     "n" = ns,
     "control mean at baseline" = 
       rep(formatC(enrr[yr2 == 0 & agHH == 0, EnRate], 
         digits = 2, format = "f"), length(regressorsS)),
     "control mean at follow up" = 
       rep(formatC(enrr[yr2 == 1 & agHH == 0, EnRate], 
         digits = 2, format = "f"), length(regressorsS)),
     "control raw mean difference" = 
       rep(formatC(enrr[yr2 == 1 & agHH == 0, EnRate]-enrr[yr2 == 0 & agHH == 0, EnRate], 
         digits = 2, format = "f"), length(regressorsS)),
     "treated mean at baseline" =
       rep(formatC(enrr[yr2 == 0 & agHH == 1, EnRate], 
         digits = 2, format = "f"), length(regressorsS)),
     "treated mean at follow up" = 
       rep(formatC(enrr[yr2 == 1 & agHH == 1, EnRate], 
         digits = 2, format = "f"), length(regressorsS)),
     "treated raw mean difference" = 
       rep(formatC(enrr[yr2 == 1 & agHH == 1, EnRate]-enrr[yr2 == 0 & agHH == 1, EnRate], 
         digits = 2, format = "f"), length(regressorsS))
   )
)
#tbest <- tabulate.est(est, reorder, output.in.list = T,
#  LastLineVariables = c("^r.*Y$|^l.*Y", "latrine.yr.$"),
#  InterWithTexts = paste0(cohort.years[jj], c("", "*agricultural household")),
#  addbottom = get(paste0("addthis", j)), subst.table = sbt)
# saveEstTable is in functions.R 
# source("C:/seiro/settings/Rsetting/functions.R", echo=F)
# source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
# reorder is main.reorder.DID
tbest <- Tab.Est(est, reorder, output.in.list = T,
  TableFormat = "satt",
  LastLineVariables = c("atrine$", "kut.*e.yr.$"),
  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
  DeleteRowStrings = "^p\\$|^CI\\$|^DoF\\$",
  addbottom = get(paste0("addthis", j)), subst.table = sbt)
# saveEstTable is in source("C:/seiro/settings/Rsetting/functions.R", echo=F)
iispace <- which(
  grepl(".", tbest[[1]]) & 
  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
  )
iispace2 <- iispace[seq(2, length(iispace), 2)]
# Split a table in to 2 tables
tbest11 <- tbest[[1]][1:(grep("inter.*2002.*ag", tbest[[1]])-3)]
tbest12 <- tbest[[2]][1:(grep("inter.*2002.*ag", tbest[[1]])-3), ]
tbest21 <- tbest[[1]][grep("inter.*2002.*ag", tbest[[1]]):length(tbest[[1]])]
tbest22 <- tbest[[2]][grep("inter.*2002.*ag", tbest[[1]]):length(tbest[[1]]), ]
iispace11 <- which(
  grepl(".", tbest11) & 
  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
  )
iispace12 <- iispace11[seq(2, length(iispace11), 2)]
iispace21 <- which(
  grepl(".", tbest21) & 
  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
  )
# drop last rows of tbest2 to shrink row space
iispace21 <- iispace21[iispace21 < grep("nonland", tbest21)]
iispace22 <- iispace21[seq(2, length(iispace21), 2)]
tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
  hleft = "\\hfil\\tiny$", hright = "$", 
  hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
  delimiterline = NULL, adjustlineskip = "-0.5ex", 
  adjlskiprows = c(iispace11, iispace11+1),
  alternatecolorManual = c(iispace12, iispace12+1, iispace12+2),
  alternatecolorManualColor = "gray80")
tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
  estimationspacelast = grep("thana dummi", tbest21),
  hleft = "\\hfil\\tiny$", hright = "$", 
  hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
  delimiterline = NULL, adjustlineskip = "-0.5ex", 
  adjlskiprows = c(iispace21, iispace21+1),
  alternatecolorManual = c(iispace22, iispace22+1, iispace22+2),
  alternatecolorManualColor = "gray80")
# Modify "interaction with ..." lines to use multicolumn
InterRows1 <- grep("nteract.*\\d", tbl1)
InterRows2 <- grep("nteract.*\\d", tbl2)
for (ir in InterRows1)
  if (any(grepl("rowcolor", tbl1[ir])))
    tbl1[ir] <- 
      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
      # For rows with rowcolor command at the end
      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
        gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
        )
        ) else
      # For rows without rowcolor command at the end
    tbl1[ir] <- 
      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
        gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
        )
        )
for (ir in InterRows2)
  if (any(grepl("rowcolor", tbl2[ir])))
    tbl2[ir] <- 
      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
      # For rows with rowcolor command at the end
      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
        gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
        )
        ) else
      # For rows without rowcolor command at the end
    tbl2[ir] <- 
      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
        gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
        )
        )
pathtosavedtable1 <- TabFilePathF(
  FolderPath = pathsaveThisVer, 
  Sample = gsub("\\.", "", zSobj[jj]), 
  Estimator = "DID",
  AgeCutoff = paste0("Older", (10:12)[s]),
  HHType = c("", "Nuclear")[j],
  AgHHDef = c("", "Is", "Hd", "Occ")[m],
  CRSEMethod = "Satterthwaite1"
)
pathtosavedtable2 <- TabFilePathF(
  FolderPath = pathsaveThisVer, 
  Sample = gsub("\\.", "", zSobj[jj]), 
  Estimator = "DID",
  AgeCutoff = paste0("Older", (10:12)[s]),
  HHType = c("", "Nuclear")[j],
  AgHHDef = c("", "Is", "Hd", "Occ")[m],
  CRSEMethod = "Satterthwaite2"
)
write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
cat("Table saved as", pathtosavedtable1, "\n")
cat("Table saved as", pathtosavedtable2, "\n")
results[[ii]] <- results0
resultsN[[ii]] <- resultsN0
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
library(qs)
qsave(results, paste0(pathsaveThisVer, "FD_DIDCRCoV_results.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "FD_N_DIDCRCoV_results.qs"))
Enr.DID <- data.table(Enr.DID)
Enrchg.DID <- data.table(Enrchg.DID)
setnames(Enrchg.DID, c("sample", "HHtype", "agHHdef", "age", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(Enr.DID, c("sample", "HHtype", "agHHdef", "age", "agHH", "tee", "rate", "Obs"))
qsave(Enr.DID, paste0(pathsaveThisVer, "Enr.DID.qs"))
qsave(Enrchg.DID, paste0(pathsaveThisVer, "Enrchg.DID.qs"))
@
<<>>=
library(qs)
Enr.DID <- qread(paste0(pathsaveThisVer, "Enr.DID.qs"))
Enrchg.DID <- qread(paste0(pathsaveThisVer, "Enrchg.DID.qs"))
@

<<main and placebo TSCB, eval = F, results = 'hide', cache = F>>=
clusterlevel <- "thana"
UseSmallClusterCorrection <- F # will use two-stage cluster bootstrap for CRSE
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zSm.1999 <- readRDS(paste0(pathsaveThisVer, "zSm1999.rds"))
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zSp.1999 <- readRDS(paste0(pathsaveThisVer, "zSp1999.rds"))
zSp.2002 <- readRDS(paste0(pathsaveThisVer, "zSp2002.rds"))
zYp.1999 <- readRDS(paste0(pathsaveThisVer, "zYp1999.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
zSp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
# level dat
LevelCovariates <- c("thana", "uniquid", "sd", "survey", 
  "highMeanY", "lowMeanY", "yield", "program", "anyprog", 
  "dummyAailjhar", "dummyChokoria", "dummyHaziganj", "dummyKalia", 
  "dummyModhupur", "dummyMohadebpur", "dummyNilphamarysadar", 
  "dummySherpursadar", 
  "agHH0", "isagHH", "hdagHH", "ocagHH",  
  "hd.edulevel.primary", "hd.edulevel.secondary", 
  "sp.edulevel.primary", "sp.edulevel.secondary", 
  "pcland", "pcnlasset", "ownwater", "kutchalatrine", 
  "HH.type", "age2", "schoolp", "sex", "sp.sex")
LC1999 <- c(LevelCovariates, "agHH0.yr2", "sex.yr2")
LC2002 <- gsub("r2", "r3", LC1999)
zem99 <- zEm.1999[, LC1999, with = F]
zsm99 <- zSm.1999[, LC1999, with = F]
zep99 <- zEp.1999[, LC2002, with = F]
zsp99 <- zSp.1999[, LC2002, with = F]
zyp99 <- zYp.1999[, LC2002, with = F]
zep02 <- zEp.2002[, LC2002, with = F]
zsp02 <- zSp.2002[, LC2002, with = F]
# demeaned thana dummies to 0, 1
# demeaned agHH dummies to 0, 1
# demeaned sex, ownwater, kutchalatrine dummies to 0, 1
# demeaned edulevel dummies to 0, 1
Dvariables <- grepout("^dummy", colnames(zem99))
Dvariables <- c(Dvariables, grepout("agHH0?$", colnames(zem99)))
Dvariables <- c(Dvariables, grepout("sex$|water|latrine|edulevel", colnames(zem99)))
for (levelobj in c("zem99", "zsm99","zep99", "zsp99", "zyp99", "zep02", "zsp02")) {
  lo <- get(levelobj)
  lo[, (Dvariables) := lapply(.SD, function(x) as.integer(as.numeric(x>0))), .SDcols = Dvariables]
  assign(levelobj, lo)
}
samples <- c("main", "placebo")
z23 <- c("z2", "z3")
lev23 <- c("lev2", "lev3")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999")
levsobj <- c("levmobj", "levpobj")
levmobj <- c("zem99", "zsm99")
levpobj <- c("zep02", "zsp02", "zep99", "zsp99")

cohort.years.list <- list(# year age is defined
  main = rep(1999, 4), # main: use 1999 age to set age range
  placebo = c(rep(2002, 2), rep(1999, 2))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
InterYearsList <- list(main = rep(2002, 4), placebo = rep(c(2006, 2002), each = 2))
regressors.list <- list(
  main = regressorsM,
  placebo = regressors
)
variables.always.use <- "schoolp|Enrolled|LHS$|^agHH.yr2|^agHH$|^thana$|uniqu"
yrXs <- c("yr2", "yr3")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = main.reorder.JHR, 
  , placebo = main.reorder.JHR, 
  , main.agewise = mix.reorder("^agHH$|^agH.*2$|^D.*yA.*agHH.yr2$|^D.*yA.*\\.1\\d\\.yr2$|")
  , main.classwise = mix.reorder("^agHH$|^agH.*2$|^D.*yA.*agHH.yr2$|^D.*yA.*\\.1\\d\\.yr2$|^Du.*Ed.*|")
  , placebo.young = mix.reorder("^agHH$|^agHH.yr3$|^hdagHH.yr3$|")
  , placebo.agewise = mix.reorder("^agHH$|^agH.*3$|^D.*yA.*agHH.yr3$|^D.*yA.*\\.1\\d\\.yr3$|")
)
boxWidth <- 4
centerWidth <- 1.3
EnrTSCB <- EnrTSCBchg <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
ii <- jj <- s <- m <- 1
ii <- 2; m <- 2
qk <- 10/495 # 10 thanas selected out of 495, 2 thanas dropped in 2002 round
qk <- 8/495
# 60 villages, 600 HHs, 3326 individuals in 1999
# 48 villages, 480 HHs, 2598 individuals in 2002
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  levobj <- get(levsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  var.always.use <- gsub("yr2", yrXs[ii], variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("schoolp", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list(m1 = res, m2 = res, m3 = res, m4 = res) # m, agHH definition
  res <- list(z2 = res, z3 = res) # j, nuclear or extended HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  for (jj in 1:length(zSobj)) {
    results0[[jj]] <- resultsN0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z1 <- changehyphen(get(zSobj[jj]))
    lev1 <- get(levobj[jj])
    tabextend <- c("yes", "", "yes", "")
    tabcohortdemeaned <- c("", "yes", "", "yes")
    for (s in 1:3)
    #  choice of age cutoff
    {
      s0 <- (10:12)[s]
      i <- paste0("older", s0)
      # latter panel: s <= age < maxAge in 1999/2002
      iiid <- unique(z1[
        s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
        eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= 18 
        #maxAge
        , uniquid])
      # Keep only former complete panel and respective years.
      z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
      z2[, grepout("exist|In", colnames(z2)) := NULL]
      z2 <- dropunbalanced(z2, returnDT = T)
      # z3: nuclear family
      z3 <- z2[sd == 1, ]
      z3 <- dropunbalanced(z3, returnDT = T)
      cat("\n\nage cutoff:", i, "\n\n")
      print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
      cat("dimension of original z1:", dim(z1), "\n")
      cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
      dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
      cat("dimension of z2 after keeping only balanced portion:", 
      dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
      cat("number of individuals in the panel:")
      print(table(table(z2[, uniquid])))
      cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
      cat("first-diffference estimator\n")
      for (j in 1:length(z23))
      {
        zz0 <- get(z23[j])
        lev0 <- lev1[uniquid %in% zz0[, uniquid], ]
        setnames(lev0, "schoolp", "LHS")
        setkey(zz0, uniquid, survey)
        zz0[, survey := NULL]
        for (m in 1:length(aghh.defs))
        {
          zz = copy(zz0)
          lev = copy(lev0)
          # Use a particular agHH definition.
          # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
          setnames(zz, 
            grepout(aghh.defs[m], colnames(zz))
            ,
            gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
          )
          # drop other ag HH definition
          zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
          zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
          # do the same for level data
          setnames(lev, 
            grepout(aghh.defs[m], colnames(lev))
            ,
            gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(lev)))
          )
          lev[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(lev)) := NULL]
          lev[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(lev)) := NULL]
          ns <- NULL
          resul <- vector("list", length = length(regressorsS))
          # First run: Estimation loop for getting N (number of obs) and first-differenced data.
          for (k in 1:length(regressorsS))
          {
            if (s0 == 10 & j == 1 & m == 1) {
              cat(paste0("(", k, ")\n"))
              print0(paste0("+ ", 
                grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
            }
            regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
            # pick covariates for k-th regression: 
            #  paste " ..|.." & "..|.." with collapse = "|"
            #  then use it in grepout
            covariates <- grepout(
              paste(var.always.use, regrsr, sep = "|", collapse = "|")
              , colnames(zz))
            zr <- zz[, covariates, with = F]
            rs <- DID1(data.frame(zr), regressand = regsnd[k], 
               clusterstring = clusterlevel, group = "^uniquid$", 
               NotToBeDifferenced = "^agHH$",
               intercept = T, 
               TimeVariant = "program|age2|meanY",
               PeriodToDropForLC = 2, 
               # opposite.time.order: set to F to get t-(t-1) difference. 
               # (to be used in DID2 in the later chunk)
               # Under F, diff(LHS) = -1 if schoolp 1 (1999) -> 0 (2002).
               # agHH.yr2 is demeaned interaction (of agHH and yr2=1999 dummies), 
               #   275 of obs (agHH==0) =  .59 because   -.39  (1999)  ->  .20 (2002)
               #   407 of obs (agHH==1) = -.401 because  .266 (1999) -> -.135 (2002)
               # In diff data, ag HH who dropped out: LHS = -1, agHH.yr2 = -.4 => OLS estimate > 0.
               # A larger drop in LHS (more negative) for agHH == 1 dummy 
               # needs agHH.yr2 to be defined as a positive value.
               # Similarly, sex (female) == 1 gives diff(sex.yr2) < 0 for females in t-(t-1) diff. 
               # X.yr2 needs to be defind as positive. To do so, in DID2, 
               # one needs to set opposite.time.order = F & all time variant covariates
               # to be X.yr2 := -1 * X.yr2 [so diff(agHH.yr2) > 0].
               opposite.time.order = F,
               TurnFactorToNumeric = T, returnV = T, print.messages = F)
            resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
            #jj: zF, zE, zS
            #s: age cutoff
            #j: nuclear or extended
            #m: agHH def
            #k: specification
            est[[k]] <- round(rs$est[, -3], 5)
            ns <- c(ns, rs$N)
          }
          # resultsN0: raw results (not under same obs)
          resultsN0[[jj]][[s]][[j]][[m]] <- resul
          # First run estimation data is stored in resul.
          # Pick the last item of data list which has the least num of obs. 
          # (This is data to use for all specifications.)
          # zidd: Differenced data of the last item in resul.
          # zid: Level data only to get agHH (because agHH is not included in zidd).
          # Merge zidd with zid to attach agHH to zidd.
          zid <- lapply(resul, "[[", "level.data")
          zid <- leveldata <- zid[[length(zid)]]
          zidd <- lapply(resul, "[[", "diff.data")
          zidd <- zidd[[length(zidd)]]
          # one needs to set opposite.time.order = F & all time variant covariates
          # to be X.yr2 := -1 * X.yr2 [so diff(agHH.yr2) > 0].
          TimeVariant <- grepout("program|age2|meanY|\\.yr\\d$", colnames(zidd))
          zidd[, (TimeVariant) := lapply(.SD, function(x) x * -1), .SDcols = TimeVariant]
          zid <- zid[uniquid %in% zidd[, uniquid], ]
          # Reconstruct agHH (it was demeaned)
          if (is.numeric(zid[,agHH])) {
            zid[eval(parse(text=grepout("agHH$", colnames(zid)))) > 0, 
              agHH := 1L]
            zid[eval(parse(text=grepout("agHH$", colnames(zid)))) <= 0, 
              agHH := 0L]
          }
          zid[, tee := 1:.N, by = uniquid]
          setkey(zid, uniquid, tee)
          zid2 <- unique(zid[, .(uniquid, agHH)])
          # Drop agHH if it is in regression data
          if (any(grepl("^agHH$", colnames(zidd)))) zidd[, agHH := NULL]
          # Merge zid2 (uniquid, agHH) with zidd
          setkey(zid2, uniquid)
          setkey(zidd, uniquid)
          zidd <- zid2[zidd]
          # get level data
          levd <- lev[uniquid %in% zidd[, uniquid], ]
          if (length(unique(levd[, uniquid])) != length(unique(zidd[, uniquid]))) 
            message("length of uniquid differ between level and reg data.")
          # Save mean enrollment rates
          enrr <- zid[, .(EnRate = round(mean(LHS), 3), Num = .N), by = .(agHH, tee)]
          EnrTSCB <- rbind(EnrTSCB, 
            cbind(zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
              s0, enrr),
            use.names = F
          )
          # Save mean enrollment rate changes
          # x: agHH, y: nonagHH
          ttestE <- t.test(zidd[agHH == 1, LHS], zidd[agHH == 0, LHS])
          EnrTSCBchg <- rbind(EnrTSCBchg, 
            cbind(
                zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                s0, round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                )
              )
          zidd[, tee := 1]
          Rs <- ns <- NULL
          est <- vector("list", length(regressorsS))
          # Second run: This will be saved as the results.
          for (k in 1:length(regressorsS))
          {
            regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
            covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
              colnames(zidd))
            zr <- zidd[, c(covariates, "tee"), with = F]
            source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
            rsl <- DID2(dX0 = zr, Regressand = "LHS", 
                     Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                     TimeVariant = "program|age2|meanY|yield",
                     opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                     SmallClusterCorrection = UseSmallClusterCorrection,
                     return.V = T, print.messages = T)
            UsedData <- zid[, colnames(rsl$nonrobust$model), with = F]
            Group = "^uniquid$|^id$"; TimeVar = "tee"; idvar <- "uniquid"; clustervar <- "m"
            Cluster = "^m$|^thana$"; Exclude = "^agHH$|^rnd$|^Time$"; timevar <- TimeVar
            intercept = T
            TimeVariant <- colnames(UsedData)[-grep(
                  paste0(c("LH", Group, Cluster, TimeVar, Exclude, "Tee"), collapse = "|")
                  , colnames(UsedData))]
            TimeVariant <- gsub("^agHH.yr.$", "bt.w", TimeVariant)
            #TimeVariant <- gsub("^w$", "bt.w", TimeVariant)
            # Get data except for interaction terms
            #   Interaction terms are redefined in TSCB function
            #   according to bootstrapped treatment assignment.
            allcn <- colnames(rsl$nonrobust$model)
            levelcn <- allcn[!grepl("yr.$", allcn)]
            intcnYr <- allcn[grepl("[^H].yr.$", allcn)]
            intcnLevel <- gsub(".yr.", "", intcnYr)
            dat <- data.table(zid[, .(thana, uniquid, tee)], 
              levd[, c(unique(c(levelcn, intcnLevel)), "agHH"), with = F])
            setnames(dat, c("agHH", "thana"), c("w", "m"), skip_absent = T)
            # Change interaction strings in covariate names in formulae: 
            #   yr2/yr3 => yrX, agHH.yr? => bt.w
            TimeVariant <- gsub("agHH.*", "bt.w", TimeVariant)
            TimeVariant <- gsub("yr.$", "yrX", TimeVariant)
            if (intercept) form0 <- "LHS ~" else form0 <- "LHS ~ -1 + "
            form0 <- paste(form0, paste(TimeVariant, collapse = " + "))
            if (intercept) form1 <- "d.LHS ~" else form1 <- "d.LHS ~ -1 + "
            form1 <- paste(form1, paste(paste0("d.", TimeVariant), collapse = " + "))
            form2 <- gsub("^d\\.", "D.", form1)
            form2 <- gsub(" d\\.", " D.", form2)
            form2 <- gsub("D.bt.w", "bt.w", form2)
            diffvars <- c(TimeVariant, "LHS")
            if (any(grepl("yrX|\\.bt.w", form2))) 
              InterTermsInput <-  paste("^", intcnLevel, "$", sep = "", collapse = "|") else
              InterTermsInput <- NULL
            sds <- TSCB(dat, qk = .25, 
               clustervar = "m", idvar = "uniquid", timevar = "tee",
               formulaOLS = form0, formulaFE = form1, formulaFD = form2, 
               diffvars = diffvars, InterTerms = InterTermsInput,
               B = 1000, 
               seedval = 20230316 + 10000*ii + 10000*jj + 1000*s + 1000*m
               )
            # select FD standard error
            estTSCB <- data.table(Estimates = rsl$est[, "Estimate"], Std.Error = sds$fdsd)
            estTSCB[, "t value" := abs(Estimates/Std.Error)]
            estTSCB[, "Pr(>|t|)" := 1-pt(abs(Estimates/Std.Error), nrow(dat)/2-length(diffvars))]
            cnTSCB <- colnames(estTSCB)
            estTSCB <- data.frame(estTSCB)
            dimnames(estTSCB) <- list(rownames(rsl$est), cnTSCB)
           # results0: results under same obs
            results0[[jj]][[s]][[j]][[m]][[k]] <- list(est = estTSCB, 
              df = rsl$reg$df, reg = rsl$reg,
              level.data = dat, diff.data = rsl$data)
            est[[k]] <- round(estTSCB, 5)
            if (Take19992002Diff) est[[k]][, 1] <- -1 * est[[k]][, 1]
            Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
            ns <- c(ns, rsl$N)
          }
          assign(paste0("addthis", j),
             rbind("\\hspace{.5em}thana dummies" = 
                paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
               "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
               "n" = ns,
               "control mean at baseline" = 
                 rep(formatC(enrr[tee == 1 & agHH == 0, EnRate], 
                   digits = 2, format = "f"), length(regressorsS)),
               "treated mean at baseline" =
                 rep(formatC(enrr[tee == 1 & agHH == 1, EnRate], 
                   digits = 2, format = "f"), length(regressorsS))
             )
          )
          # drop t value column
          est3 <- lapply(est, function(x) x[, -3])
          tbest <- tabulate.est(est3, reorder, output.in.list = T,
            LastLineVariables = c("^r.*Y$|^l.*Y", "latrine.yr.$"),
            InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
            addbottom = get(paste0("addthis", j)), subst.table = sbt)
          tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
            estimationspacelast = grep("thana dummi", tbest[[1]]),
            hleft = "\\hfil\\scriptsize$", hright = "$", 
            hcenter = c(boxWidth, rep(centerWidth, ncol(tbest[[2]]))), 
            delimiterline = NULL, adjustlineskip = "-0.5ex", 
            alternatecolor2 = "gray80")
          # Modify "interaction with ..." lines to use multicolumn
          InterRows <- grep("nteract.*\\d", tbl)
          for (ir in InterRows)
            if (any(grepl("rowcolor", tbl[ir])))
              tbl[ir] <- 
                # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                # rows with rowcolor command at the end
                paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                  gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir])))
                  ) else
                # rows without rowcolor command at the end
                paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                  gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                  gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                  )
                  )
          pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
            Sample = gsub("\\.", "", zSobj[jj]), 
            AgeCutoff = paste0("Older", (10:12)[s]),
            HHType = c("", "Nuclear")[j],
            AgHHDef = c("", "is", "hd", "occ")[m],
            CRSEMethod = "TSCB")
          write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
          cat("Table saved as", pathtosavedtable, "\n")
        }  # m: ag HH definitions
      }  # j: z2 (incl. extended) or z3 (nuclear)
    }  # s: lowerbound age cutoffs (10, 11, 12)
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with TSCB (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
saveRDS(results, paste0(pathsaveThisVer, "FD_sameN_TSCB_results.rds"))
saveRDS(resultsN, paste0(pathsaveThisVer, "FD_N_TSCB_results.rds"))
EnrTSCB <- data.table(EnrTSCB)
EnrTSCBchg <- data.table(EnrTSCBchg)
setnames(EnrTSCBchg, c("sample", "HHtype", "agHHdef", "age", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(EnrTSCB, c("sample", "HHtype", "agHHdef", "age", "agHH", "tee", "rate", "Obs"))
clusterlevel <- "district"
@

	\subsection{Other outcomes}

We find enrollment is affected. Enrollment is divided into normal progression and repetition. However, we cannot analyse impacts on normal progression and repetition, both binary variables, because they are defined only between two time points and have single values in a two-period panel (that cancel out in FD/FE estimation). Instead, we analyse the number of added grades between rounds 1 and 2. We only estimate ``main'' impacts. Placebo estimation is not feasible because there are many cases of enrolled grade information in 2006 is inconsistent with 2002 enrolled grade information (being less than 2000 achieved grades, or more than 4 grades higher). 

DID of number of added grades \textsf{NumGrades} requires a stronger assumption than DID of enrolled status. This is because a common trend in the number of added grades needs entry, progression, repetition and dropout to be in particular combinations to sum to the same mean added grades, while the enrolled status holds if entry and dropout rates are similar (regardless of being in normal progression or repetition). 

\subsubsection{Progression (number of added grades)}

Number of added grades is a difference between class in 2002 and 1999 for individuals who are not classfied as not-in-school. Not-in-school is defined as individuals who have schooling only up to nursery in both 1999 and 2002, or who report non-enrollment in both 1999 and 2002, or who have zero grade progression between 2002 and 1999. 

<<num grades by gender impacts, eval = F, results = 'hide', cache = F>>=
library(clubSandwich)
DivInto2Tables <- T
clusterlevel <- "thana"
regressors.list <- list(
  main = regressorsNumGrades,
  placebo = regressorsNumGrades2002
)
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
samples <- "main"
z234 <- c("z2", "z3", "z4")
zsobj <- "zmobjOther"
zmobjOther <- "zEm.1999"
cohort.years.list <- list(# year age is defined
  main = rep(1999, 1), # main: use 1999 age to set age range
  placebo = c(rep(2002, 1), rep(1999, 1))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
# Used in "interaction with year InterYears" in results table
InterYearsList <- list(main = rep(2002, 1), placebo = rep(c(2006, 2002), each = 1))
variables.always.use <- "NumGrades|^agHH.yr2|^agHH$|^thana$|uniqu"
yrXs <- c("yr2", "yr3")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
)
boxWidth <- 4
centerWidth <- 1.3
SkipLowerBound <- 50
NumGrades <- NumGradeschg <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  yrX <- yrXs[ii]
  var.always.use <- gsub("yr2", yrX, variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("NumGrades", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  res <- list(demeaned = res, undemeaned = res) # dd, demeaned/level interactions
  # res[[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  for (jj in 1:length(zSobj)) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    for (dd in 1:2) {
      z1 = copy(z01)
      if (dd == 2) {
        ## Restore undemeaned interactions: Start 
        # 1. Drop demeaned interactions
        iiyr <- grepout("\\.yr", colnames(z1))
        iiyr <- gsub("\\.yr.", "", iiyr)
        iiyr <- unique(gsub("\\...agHH|\\.agHH0", "", iiyr))
        # interactions
        iiyrX <- paste0(iiyr, ".", yrX)
        iiagHHyrX <- 
          paste0(rep(iiyr, each = length(aghh.defs)), ".", rep(aghh.defs, length(iiyr)), ".", yrX)
        # drop demeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NULL]
        # 2. Form undemeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NA]
        z1[, (yrX) := as.integer(1:.N-1), by = uniquid]
        # restore demeaned agHH def terms as binary variables
        for (mm in aghh.defs) {
          set(z1, i = which(z1[[mm]] > 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 1L)
          set(z1, i = which(z1[[mm]] <= 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 0L)
        }
        # restore demeaned covariates: copy from corresponding UDX (undemeaned X)
        for (kk in iiyr)
          set(z1, j = grep(kk, colnames(z1)), value = z1[[paste0("UD", kk)]])
        # form level interactions
        # X.yrx
        for (i in 1:length(iiyr))
          set(z1, j = grep(paste0("^", iiyrX[i]), colnames(z1)), value = z1[[iiyr[i]]]*z1[[yrX]])
        # X.agHH.yrx
        for (kk in iiyr)
          for (mm in aghh.defs)
            set(z1, j = grep(paste0("^", kk, ".", mm, ".", yrX),  colnames(z1)), 
              value = z1[[kk]]*z1[[mm]]*z1[[yrX]])
        ## Restore undemeaned interactions: End 
      } # end: if dd == 2
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      tabextend <- c("yes", "", "yes", "")
      tabcohortdemeaned <- c("", "yes", "", "yes")
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      if (ii == 2 & jj == 5) smax <- 1 else smax <- 3
      for (s in 1:3)
      #  choice of age cutoff
      {
        if (ii == 2 & jj == 5) {
          s0 <- 6
          MaxAge <- 9
        } else {
          MaxAge <- 18
        }
        i <- paste0("older", s0)
        s0 <- (10:12)[s]
        i <- paste0("older", s0)
        # latter panel: s <= age < maxAge in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
          #maxAge
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
        for (j in 1:length(z23))
        {
          zz00 = copy(get(z234[j]))
          setkey(zz00, uniquid, survey)
          for (ge in 1:3)
          {
            if (ge == 1) {
              zz0 = copy(zz00[sex <= 0, ]) 
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else  if (ge == 2){
              zz0 = copy(zz00[sex > 0, ])
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else zz0 = copy(zz00)
            if (nrow(zz0) < SkipLowerBound) {
              cat("Skipped due to small number of obs:", nrow(zz0), "\n")
              next
            }
            setkey(zz0, uniquid, survey)
            zz0[, survey := NULL]
            for (m in 1:length(aghh.defs))
            {
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              ns <- NULL
              resul <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                zr <- zz[, covariates, with = F]
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   # opposite.time.order: set to F to get t-(t-1) difference. 
                   # (to be used in DID2 in the later chunk)
                   # Under F, diff(LHS) = -1 if schoolp 1 (1999) -> 0 (2002).
                   # agHH.yr2 is demeaned interaction (of agHH and yr2=1999 dummies), 
                   #   275 of obs (agHH==0) =  .59 because   -.39  (1999)  ->  .20 (2002)
                   #   407 of obs (agHH==1) = -.401 because  .266 (1999) -> -.135 (2002)
                   # In diff data, ag HH who dropped out: LHS = -1, agHH.yr2 = -.4 => OLS estimate > 0.
                   # A larger drop in LHS (more negative) for agHH == 1 dummy 
                   # needs agHH.yr2 to be defined as a positive value.
                   # Similarly, sex (female) == 1 gives diff(sex.yr2) < 0 for females in t-(t-1) diff. 
                   # X.yr2 needs to be defind as positive. To do so, in DID2, 
                   # one needs to set opposite.time.order = F & all time variant covariates
                   # to be X.yr2 := -1 * X.yr2 [so diff(agHH.yr2) > 0].
                   opposite.time.order = F,
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                #ii: main, placebo
                #jj: zE, zS
                #s: age cutoff
                #j: nuclear or extended
                #m: agHH def
                #k: specification
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[dd]][[s]][[j]][[ge]][[m]] <- resul
              if (dd == 1) 
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) else {
                zidd <- lapply(resul, "[[", "diff.data")
                zidd <- zidd[[length(zidd)]]
                zid = copy(z2[uniquid %in% zidd[, uniquid], ])
                # drop other agHH defs and their interactions
                if (length(iiothag <- 
                  grep(paste0(gsub("\\\\\\.", "", aghh.defs.regexpr[-m]), collapse = "|"), colnames(zid))) > 0)
                  zid[, (iiothag) := NULL]
                # change agHH def name to "agHH"
                setnames(zid, 
                  grepout(aghh.defs[m], colnames(zid))
                  ,
                  gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zid)))
                )
                zid[, Enrolled := schoolp]
              }
              zidd[, tee := 1]
              zid[, tee := 1:.N, by = uniquid]
              if (any(grepl("NumGrades", colnames(zidd)))) setnames(zidd, "NumGrades", "LHS")
              if (any(grepl("NumGrades", colnames(zid)))) setnames(zid, "NumGrades", "LHS")
              # Save mean number of grades
              enrr <- zid[, .(MeanNumGrades = mean(LHS), Num = .N), by = .(agHH, tee)]
              NumGrades <- rbind(NumGrades, 
                cbind(zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                  c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], s0, enrr),
                use.names = F
              )
              # Save mean progression rate changes
              # x: agHH, y: nonagHH
              ttestE <- t.test(zidd[agHH == 1, LHS], zidd[agHH == 0, LHS])
              NumGradeschg <- rbind(NumGradeschg, 
                cbind(
                    zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                    c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], 
                    s0, round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                    t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                    )
                  )
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "NumGrades")
              for (cl in c("LiangZeger", "satterthwaite"))#, "wildclusterboot")) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl 
                cat("\n\n###", cl, "###\n\n")
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "NumGrades", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (!is.logical(UseSmallClusterCorrection) && grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (!is.logical(UseSmallClusterCorrection) && grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    #   estimate, Std.Error, statistic, Pr(>|t|), ci.lb, ci.ub
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    #   Estimate, Std. Error, t-value, Pr(>|t|)
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  results0[[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                    list(est = rsl$est, ci = rsl$CI,
                      df = rsl$reg$df, reg = rsl$reg,
                      level.data = zid2[, covariates, with = F], 
                      diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean at baseline" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "control mean at follow up" = 
                       rep(formatC(enrr[tee == 2 & agHH == 0, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at baseline" =
                       rep(formatC(enrr[tee == 1 & agHH == 1, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at follow up" =
                       rep(formatC(enrr[tee == 2 & agHH == 1, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "raw DID" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1, MeanNumGrades] - enrr[tee == 1 & agHH == 1, MeanNumGrades] 
                       -(enrr[tee == 2 & agHH == 0, MeanNumGrades] - enrr[tee == 1 & agHH == 0, MeanNumGrades]), 
                         digits = 2, format = "f"), length(regressorsS))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source(paste0(pathprogram, "tabulate_est.R"))
                # source("c:/seiro/settings/Rsetting/functions.R")
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, #TableFormat = tabformat,
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$", 
                  CIInTinySize = T, 
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                if (DivInto2Tables) {
                  # Split a table in to 2 tables
                  if (grepl("Lian", cl)) 
                    NumRowsAfterEst <- 2 else 
                    NumRowsAfterEst <- 3
                  tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                  tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                  tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                  tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                  iispace11 <- which(
                    grepl(".", tbest11) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                    )
                  iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                  iispace21 <- which(
                    grepl(".", tbest21) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                    )
                  # drop last rows of tbest2 to shrink row space
                  iispace21 <- iispace21[iispace21 < max(grep("toilet|water", tbest21))]
                  #iispace21 <- iispace21[iispace21 < grep("nonland", tbest21)]
                  iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                  if (grepl("Lian|^e[ps]$", cl)) {
                  # ep: 2 rows per estimate
                    AdjustLineSkipRows1 <- iispace11
                    AltColorRows1 <- c(iispace12, iispace12+1)
                    AdjustLineSkipRows2 <- iispace21
                    AltColorRows2 <- c(iispace22, iispace22+1)
                  } else {
                  # epc, satt: 3 rows per estimate
                    AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                    AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                    AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                    AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                  }
                  # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                  tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-.7ex", 
                    adjlskiprows = AdjustLineSkipRows1,
                    AddTopStripSpace = "1.0ex",
                    alternatecolorManual = AltColorRows1,
                    alternatecolorManualColor = "gray80")
                  tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest21),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-.7ex", 
                    adjlskiprows = AdjustLineSkipRows2,
                    alternatecolorManual = AltColorRows2,
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows1 <- grep("nteract.*\\d", tbl1)
                  InterRows2 <- grep("nteract.*\\d", tbl2)
                  for (ir in InterRows1) {
                    if (any(grepl("rowcolor", tbl1[ir])))
                      tbl1[ir] <- 
                        # \makbox[XXcm]{inter with A} &&&& \\
                        #  => \multicolumn{5}{l}{\makebox[10cm]{inter with A}} \\
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl1[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          )
                      # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                      # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                      tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                      tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                      tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                  }
                  for (ir in InterRows2) {
                    if (any(grepl("rowcolor", tbl2[ir])))
                      tbl2[ir] <- 
                        # For rows with rowcolor command at the end
                        paste0("[1ex]\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl2[ir] <- 
                        paste0("[1ex]\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          )
                      tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                      tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                      tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                  }
                  clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                  # file path to saved table
                  pathtosavedtable1 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("NumGradesOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 1)
                    )
                  pathtosavedtable2 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("NumGradesOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 2)
                    )
                  write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable1, "\n")
                  cat("Table saved as", pathtosavedtable2, "\n")
                } else {
                # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                iispace <- which(
                  # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                  grepl(".", tbest[[1]]) & 
                  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                  )
                iispace2 <- iispace[seq(2, length(iispace), 2)]
                # adjlskiprows = c(iispace, iispace+1)
                # saveEstTable is in functions.R
                # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                  estimationspacelast = grep("thana dummi", tbest[[1]]),
                  hleft = "\\hfil\\tiny$", hright = "$", 
                  hcenter = c(boxWidth, rep(centerWidth-.15, ncol(tbest[[2]]))), 
                  delimiterline = NULL, adjustlineskip = "-0.5ex", 
                  adjlskiprows = c(iispace, iispace+1),
                  alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                  alternatecolorManualColor = "gray80")
                # Modify "interaction with ..." lines to use multicolumn
                InterRows <- grep("nteract.*\\d", tbl)
                for (ir in InterRows)
                  if (any(grepl("rowcolor", tbl[ir])))
                    tbl[ir] <- 
                      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                      # rows with rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                        )
                        ) else
                      # rows without rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                        )
                        )
                  # file path to saved table
                  pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("NumGradesOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                  write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable, "\n")
                } # If: DivInto2Tables ends
              } # cl: SE clustering option
            }  # m: ag HH definitions
          } # ge: gender
        }  # j: z2 (incl. extended) or z3 (nuclear)
      }  # s: lowerbound age cutoffs (10, 11, 12)
    }# dd
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0 # [[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]]
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
library(qs)
qsave(results, paste0(pathsaveThisVer, "FD_NumGradesGenderCRCoV_results.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "FD_N_NumGradesGenderCRCoV_results.qs"))
NumGrades <- data.table(NumGrades)
NumGradeschg <- data.table(NumGradeschg)
setnames(NumGradeschg, c("sample", "HHtype", "agHHdef", "demean", "gender", "agelb", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(NumGrades, c("sample", "HHtype", "agHHdef", "demean", "gendr", 
  "agelb", "agHH", "tee", "rate", "Obs"))
qsave(NumGrades, paste0(pathsaveThisVer, "NumGradesGender.qs"))
qsave(NumGradeschg, paste0(pathsaveThisVer, "NumGradeschgGender.qs"))
@

<<num grades of enrollers by gender impacts, eval = F, results = 'hide', cache = F>>=
library(clubSandwich)
DivInto2Tables <- T
clusterlevel <- "thana"
regressors.list <- list(
  main = regressorsNumGrades,
  placebo = regressorsNumGrades2002
)
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
samples <- "main"
z234 <- c("z2", "z3", "z4")
zsobj <- "zmobjOther"
zmobjOther <- "zEm.1999"
cohort.years.list <- list(# year age is defined
  main = rep(1999, 1), # main: use 1999 age to set age range
  placebo = c(rep(2002, 1), rep(1999, 1))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
# Used in "interaction with year InterYears" in results table
InterYearsList <- list(main = rep(2002, 1), placebo = rep(c(2006, 2002), each = 1))
variables.always.use <- "NumGrades|^agHH.yr2|^agHH$|^thana$|uniqu"
yrXs <- c("yr2", "yr3")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
)
boxWidth <- 4
centerWidth <- 1.3
SkipLowerBound <- 50
NumGrades <- NumGradeschg <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  yrX <- yrXs[ii]
  var.always.use <- gsub("yr2", yrX, variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("NumGrades", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  res <- list(demeaned = res, undemeaned = res) # dd, demeaned/level interactions
  # res[[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  for (jj in 1:length(zSobj)) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    # ss == 2: enrolled in 1999 and 2002. Number of grade progression?
    z01[, ss := cumsum(schoolp), by = uniquid]
    z01[, ss := ss[2], by = uniquid]
    z02 <- z01[ss==2, ]
    for (dd in 1:2) {
      z1 = copy(z02)
      if (dd == 2) {
        ## Restore undemeaned interactions: Start 
        # 1. Drop demeaned interactions
        iiyr <- grepout("\\.yr", colnames(z1))
        iiyr <- gsub("\\.yr.", "", iiyr)
        iiyr <- unique(gsub("\\...agHH|\\.agHH0", "", iiyr))
        # interactions
        iiyrX <- paste0(iiyr, ".", yrX)
        iiagHHyrX <- 
          paste0(rep(iiyr, each = length(aghh.defs)), ".", rep(aghh.defs, length(iiyr)), ".", yrX)
        # drop demeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NULL]
        # 2. Form undemeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NA]
        z1[, (yrX) := as.integer(1:.N-1), by = uniquid]
        # restore demeaned agHH def terms as binary variables
        for (mm in aghh.defs) {
          set(z1, i = which(z1[[mm]] > 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 1L)
          set(z1, i = which(z1[[mm]] <= 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 0L)
        }
        # restore demeaned covariates: copy from corresponding UDX (undemeaned X)
        for (kk in iiyr)
          set(z1, j = grep(kk, colnames(z1)), value = z1[[paste0("UD", kk)]])
        # form level interactions
        # X.yrx
        for (i in 1:length(iiyr))
          set(z1, j = grep(paste0("^", iiyrX[i]), colnames(z1)), value = z1[[iiyr[i]]]*z1[[yrX]])
        # X.agHH.yrx
        for (kk in iiyr)
          for (mm in aghh.defs)
            set(z1, j = grep(paste0("^", kk, ".", mm, ".", yrX),  colnames(z1)), 
              value = z1[[kk]]*z1[[mm]]*z1[[yrX]])
        ## Restore undemeaned interactions: End 
      } # end: if dd == 2
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      tabextend <- c("yes", "", "yes", "")
      tabcohortdemeaned <- c("", "yes", "", "yes")
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      if (ii == 2 & jj == 5) smax <- 1 else smax <- 3
      for (s in 1:3)
      #  choice of age cutoff
      {
        if (ii == 2 & jj == 5) {
          s0 <- 6
          MaxAge <- 9
        } else {
          MaxAge <- 18
        }
        i <- paste0("older", s0)
        s0 <- (10:12)[s]
        i <- paste0("older", s0)
        # latter panel: s <= age < maxAge in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
          #maxAge
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
        for (j in 1:length(z23))
        {
          zz00 = copy(get(z234[j]))
          setkey(zz00, uniquid, survey)
          for (ge in 1:3)
          {
            if (ge == 1) {
              zz0 = copy(zz00[sex <= 0, ]) 
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else  if (ge == 2){
              zz0 = copy(zz00[sex > 0, ])
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else zz0 = copy(zz00)
            if (nrow(zz0) < SkipLowerBound) {
              cat("Skipped due to small number of obs:", nrow(zz0), "\n")
              next
            }
            setkey(zz0, uniquid, survey)
            zz0[, survey := NULL]
            for (m in 1:length(aghh.defs))
            {
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              ns <- NULL
              resul <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                zr <- zz[, covariates, with = F]
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   opposite.time.order = F,
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[dd]][[s]][[j]][[ge]][[m]] <- resul
              if (dd == 1) 
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) else {
                zidd <- lapply(resul, "[[", "diff.data")
                zidd <- zidd[[length(zidd)]]
                zid = copy(z2[uniquid %in% zidd[, uniquid], ])
                # drop other agHH defs and their interactions
                if (length(iiothag <- 
                  grep(paste0(gsub("\\\\\\.", "", aghh.defs.regexpr[-m]), collapse = "|"), colnames(zid))) > 0)
                  zid[, (iiothag) := NULL]
                # change agHH def name to "agHH"
                setnames(zid, 
                  grepout(aghh.defs[m], colnames(zid))
                  ,
                  gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zid)))
                )
                zid[, Enrolled := schoolp]
              }
              zidd[, tee := 1]
              zid[, tee := 1:.N, by = uniquid]
              if (any(grepl("NumGrades", colnames(zidd)))) setnames(zidd, "NumGrades", "LHS")
              if (any(grepl("NumGrades", colnames(zid)))) setnames(zid, "NumGrades", "LHS")
              # Save mean number of grades
              enrr <- zid[, .(MeanNumGrades = mean(LHS), Num = .N), by = .(agHH, tee)]
              NumGrades <- rbind(NumGrades, 
                cbind(zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                  c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], s0, enrr),
                use.names = F
              )
              # Save mean progression rate changes
              # x: agHH, y: nonagHH
              ttestE <- t.test(zidd[agHH == 1, LHS], zidd[agHH == 0, LHS])
              NumGradeschg <- rbind(NumGradeschg, 
                cbind(
                    zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                    c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], 
                    s0, round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                    t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                    )
                  )
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "NumGrades")
              for (cl in c("LiangZeger", "satterthwaite"))#, "wildclusterboot")) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl 
                cat("\n\n###", cl, "###\n\n")
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "NumGrades", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (!is.logical(UseSmallClusterCorrection) && grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (!is.logical(UseSmallClusterCorrection) && grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    #   estimate, Std.Error, statistic, Pr(>|t|), ci.lb, ci.ub
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    #   Estimate, Std. Error, t-value, Pr(>|t|)
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  results0[[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                    list(est = rsl$est, ci = rsl$CI,
                      df = rsl$reg$df, reg = rsl$reg,
                      level.data = zid2[, covariates, with = F], 
                      diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean at baseline" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "control mean at follow up" = 
                       rep(formatC(enrr[tee == 2 & agHH == 0, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at baseline" =
                       rep(formatC(enrr[tee == 1 & agHH == 1, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at follow up" =
                       rep(formatC(enrr[tee == 2 & agHH == 1, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "raw DID" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1, MeanNumGrades] - enrr[tee == 1 & agHH == 1, MeanNumGrades] 
                       -(enrr[tee == 2 & agHH == 0, MeanNumGrades] - enrr[tee == 1 & agHH == 0, MeanNumGrades]), 
                         digits = 2, format = "f"), length(regressorsS))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source(paste0(pathprogram, "tabulate_est.R"))
                # source("c:/seiro/settings/Rsetting/functions.R")
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, #TableFormat = tabformat,
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$", 
                  CIInTinySize = T, 
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                if (DivInto2Tables) {
                  # Split a table in to 2 tables
                  if (grepl("Lian", cl)) 
                    NumRowsAfterEst <- 2 else 
                    NumRowsAfterEst <- 3
                  tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                  tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                  tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                  tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                  iispace11 <- which(
                    grepl(".", tbest11) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                    )
                  iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                  iispace21 <- which(
                    grepl(".", tbest21) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                    )
                  # drop last rows of tbest2 to shrink row space
                  iispace21 <- iispace21[iispace21 < max(grep("toilet|water|nonla", tbest21))]
                  iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                  if (grepl("Lian|^e[ps]$", cl)) {
                  # ep: 2 rows per estimate
                    AdjustLineSkipRows1 <- iispace11
                    AltColorRows1 <- c(iispace12, iispace12+1)
                    AdjustLineSkipRows2 <- iispace21
                    AltColorRows2 <- c(iispace22, iispace22+1)
                  } else {
                  # epc, satt: 3 rows per estimate
                    AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                    AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                    AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                    AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                  }
                  # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                  tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-.7ex", 
                    adjlskiprows = AdjustLineSkipRows1,
                    AddTopStripSpace = "1.0ex",
                    alternatecolorManual = AltColorRows1,
                    alternatecolorManualColor = "gray80")
                  tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest21),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-.7ex", 
                    adjlskiprows = AdjustLineSkipRows2,
                    alternatecolorManual = AltColorRows2,
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows1 <- grep("nteract.*\\d", tbl1)
                  InterRows2 <- grep("nteract.*\\d", tbl2)
                  for (ir in InterRows1) {
                    if (any(grepl("rowcolor", tbl1[ir])))
                      tbl1[ir] <- 
                        # \makbox[XXcm]{inter with A} &&&& \\
                        #  => \multicolumn{5}{l}{\makebox[10cm]{inter with A}} \\
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl1[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          )
                      # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                      # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                      tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                      tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                      tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                  }
                  for (ir in InterRows2) {
                    if (any(grepl("rowcolor", tbl2[ir])))
                      tbl2[ir] <- 
                        # For rows with rowcolor command at the end
                        paste0("[1ex]\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl2[ir] <- 
                        paste0("[1ex]\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          )
                      tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                      tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                      tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                  }
                  clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                  # file path to saved table
                  pathtosavedtable1 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("NumGradesEnrollersOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 1)
                    )
                  pathtosavedtable2 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("NumGradesEnrollersOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 2)
                    )
                  write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable1, "\n")
                  cat("Table saved as", pathtosavedtable2, "\n")
                } else {
                # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                iispace <- which(
                  # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                  grepl(".", tbest[[1]]) & 
                  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                  )
                iispace2 <- iispace[seq(2, length(iispace), 2)]
                # adjlskiprows = c(iispace, iispace+1)
                # saveEstTable is in functions.R
                # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                  estimationspacelast = grep("thana dummi", tbest[[1]]),
                  hleft = "\\hfil\\tiny$", hright = "$", 
                  hcenter = c(boxWidth, rep(centerWidth-.15, ncol(tbest[[2]]))), 
                  delimiterline = NULL, adjustlineskip = "-0.5ex", 
                  adjlskiprows = c(iispace, iispace+1),
                  alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                  alternatecolorManualColor = "gray80")
                # Modify "interaction with ..." lines to use multicolumn
                InterRows <- grep("nteract.*\\d", tbl)
                for (ir in InterRows)
                  if (any(grepl("rowcolor", tbl[ir])))
                    tbl[ir] <- 
                      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                      # rows with rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                        )
                        ) else
                      # rows without rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                        )
                        )
                  # file path to saved table
                  pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("NumGradesEnrollersOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                  write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable, "\n")
                } # If: DivInto2Tables ends
              } # cl: SE clustering option
            }  # m: ag HH definitions
          } # ge: gender
        }  # j: z2 (incl. extended) or z3 (nuclear)
      }  # s: lowerbound age cutoffs (10, 11, 12)
    }# dd
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0 # [[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]]
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
library(qs)
qsave(results, paste0(pathsaveThisVer, "FD_NumGradesEnrollersGenderCRCoV_results.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "FD_N_NumGradesEnrollersGenderCRCoV_results.qs"))
NumGrades <- data.table(NumGrades)
NumGradeschg <- data.table(NumGradeschg)
setnames(NumGradeschg, c("sample", "HHtype", "agHHdef", "demean", "gender", "agelb", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(NumGrades, c("sample", "HHtype", "agHHdef", "demean", "gendr", 
  "agelb", "agHH", "tee", "rate", "Obs"))
qsave(NumGrades, paste0(pathsaveThisVer, "NumGradesEnrollersGender.qs"))
qsave(NumGradeschg, paste0(pathsaveThisVer, "NumGradeschgEnrollersGender.qs"))
@

<<num grades of initial enrollers by gender impacts, eval = F, results = 'hide', cache = F>>=
library(clubSandwich)
DivInto2Tables <- T
clusterlevel <- "thana"
regressors.list <- list(
  main = regressorsNumGrades,
  placebo = regressorsNumGrades2002
)
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
samples <- "main"
z234 <- c("z2", "z3", "z4")
zsobj <- "zmobjOther"
zmobjOther <- "zEm.1999"
cohort.years.list <- list(# year age is defined
  main = rep(1999, 1), # main: use 1999 age to set age range
  placebo = c(rep(2002, 1), rep(1999, 1))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
# Used in "interaction with year InterYears" in results table
InterYearsList <- list(main = rep(2002, 1), placebo = rep(c(2006, 2002), each = 1))
variables.always.use <- "NumGrades|^agHH.yr2|^agHH$|^thana$|uniqu"
yrXs <- c("yr2", "yr3")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
)
boxWidth <- 4
centerWidth <- 1.3
SkipLowerBound <- 50
NumGrades <- NumGradeschg <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  yrX <- yrXs[ii]
  var.always.use <- gsub("yr2", yrX, variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("NumGrades", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  res <- list(demeaned = res, undemeaned = res) # dd, demeaned/level interactions
  # res[[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  for (jj in 1:length(zSobj)) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    # ss == 1: enrolled in 1999. Number of grade progression?
    z01[, ss := schoolp[1], by = uniquid]
    z02 <- z01[ss==1, ]
    for (dd in 1:2) {
      z1 = copy(z02)
      if (dd == 2) {
        ## Restore undemeaned interactions: Start 
        # 1. Drop demeaned interactions
        iiyr <- grepout("\\.yr", colnames(z1))
        iiyr <- gsub("\\.yr.", "", iiyr)
        iiyr <- unique(gsub("\\...agHH|\\.agHH0", "", iiyr))
        # interactions
        iiyrX <- paste0(iiyr, ".", yrX)
        iiagHHyrX <- 
          paste0(rep(iiyr, each = length(aghh.defs)), ".", rep(aghh.defs, length(iiyr)), ".", yrX)
        # drop demeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NULL]
        # 2. Form undemeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NA]
        z1[, (yrX) := as.integer(1:.N-1), by = uniquid]
        # restore demeaned agHH def terms as binary variables
        for (mm in aghh.defs) {
          set(z1, i = which(z1[[mm]] > 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 1L)
          set(z1, i = which(z1[[mm]] <= 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 0L)
        }
        # restore demeaned covariates: copy from corresponding UDX (undemeaned X)
        for (kk in iiyr)
          set(z1, j = grep(kk, colnames(z1)), value = z1[[paste0("UD", kk)]])
        # form level interactions
        # X.yrx
        for (i in 1:length(iiyr))
          set(z1, j = grep(paste0("^", iiyrX[i]), colnames(z1)), value = z1[[iiyr[i]]]*z1[[yrX]])
        # X.agHH.yrx
        for (kk in iiyr)
          for (mm in aghh.defs)
            set(z1, j = grep(paste0("^", kk, ".", mm, ".", yrX),  colnames(z1)), 
              value = z1[[kk]]*z1[[mm]]*z1[[yrX]])
        ## Restore undemeaned interactions: End 
      } # end: if dd == 2
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      tabextend <- c("yes", "", "yes", "")
      tabcohortdemeaned <- c("", "yes", "", "yes")
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      if (ii == 2 & jj == 5) smax <- 1 else smax <- 3
      for (s in 1:3)
      #  choice of age cutoff
      {
        if (ii == 2 & jj == 5) {
          s0 <- 6
          MaxAge <- 9
        } else {
          MaxAge <- 18
        }
        i <- paste0("older", s0)
        s0 <- (10:12)[s]
        i <- paste0("older", s0)
        # latter panel: s <= age < maxAge in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
          #maxAge
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
        for (j in 1:length(z23))
        {
          zz00 = copy(get(z234[j]))
          setkey(zz00, uniquid, survey)
          for (ge in 1:3)
          {
            if (ge == 1) {
              zz0 = copy(zz00[sex <= 0, ]) 
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else  if (ge == 2){
              zz0 = copy(zz00[sex > 0, ])
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else zz0 = copy(zz00)
            if (nrow(zz0) < SkipLowerBound) {
              cat("Skipped due to small number of obs:", nrow(zz0), "\n")
              next
            }
            setkey(zz0, uniquid, survey)
            zz0[, survey := NULL]
            for (m in 1:length(aghh.defs))
            {
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              ns <- NULL
              resul <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                zr <- zz[, covariates, with = F]
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   opposite.time.order = F,
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[dd]][[s]][[j]][[ge]][[m]] <- resul
              if (dd == 1) 
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) else {
                zidd <- lapply(resul, "[[", "diff.data")
                zidd <- zidd[[length(zidd)]]
                zid = copy(z2[uniquid %in% zidd[, uniquid], ])
                # drop other agHH defs and their interactions
                if (length(iiothag <- 
                  grep(paste0(gsub("\\\\\\.", "", aghh.defs.regexpr[-m]), collapse = "|"), colnames(zid))) > 0)
                  zid[, (iiothag) := NULL]
                # change agHH def name to "agHH"
                setnames(zid, 
                  grepout(aghh.defs[m], colnames(zid))
                  ,
                  gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zid)))
                )
                zid[, Enrolled := schoolp]
              }
              zidd[, tee := 1]
              zid[, tee := 1:.N, by = uniquid]
              if (any(grepl("NumGrades", colnames(zidd)))) setnames(zidd, "NumGrades", "LHS")
              if (any(grepl("NumGrades", colnames(zid)))) setnames(zid, "NumGrades", "LHS")
              # Save mean number of grades
              enrr <- zid[, .(MeanNumGrades = mean(LHS), Num = .N), by = .(agHH, tee)]
              NumGrades <- rbind(NumGrades, 
                cbind(zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                  c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], s0, enrr),
                use.names = F
              )
              # Save mean progression rate changes
              # x: agHH, y: nonagHH
              ttestE <- t.test(zidd[agHH == 1, LHS], zidd[agHH == 0, LHS])
              NumGradeschg <- rbind(NumGradeschg, 
                cbind(
                    zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                    c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], 
                    s0, round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                    t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                    )
                  )
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "NumGrades")
              for (cl in c("LiangZeger", "satterthwaite"))#, "wildclusterboot")) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl 
                cat("\n\n###", cl, "###\n\n")
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "NumGrades", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (!is.logical(UseSmallClusterCorrection) && grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (!is.logical(UseSmallClusterCorrection) && grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    #   estimate, Std.Error, statistic, Pr(>|t|), ci.lb, ci.ub
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    #   Estimate, Std. Error, t-value, Pr(>|t|)
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  results0[[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                    list(est = rsl$est, ci = rsl$CI,
                      df = rsl$reg$df, reg = rsl$reg,
                      level.data = zid2[, covariates, with = F], 
                      diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean at baseline" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "control mean at follow up" = 
                       rep(formatC(enrr[tee == 2 & agHH == 0, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at baseline" =
                       rep(formatC(enrr[tee == 1 & agHH == 1, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at follow up" =
                       rep(formatC(enrr[tee == 2 & agHH == 1, MeanNumGrades], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "raw DID" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1, MeanNumGrades] - enrr[tee == 1 & agHH == 1, MeanNumGrades] 
                       -(enrr[tee == 2 & agHH == 0, MeanNumGrades] - enrr[tee == 1 & agHH == 0, MeanNumGrades]), 
                         digits = 2, format = "f"), length(regressorsS))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source(paste0(pathprogram, "tabulate_est.R"))
                # source("c:/seiro/settings/Rsetting/functions.R")
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, #TableFormat = tabformat,
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$", 
                  CIInTinySize = T, 
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                if (DivInto2Tables) {
                  # Split a table in to 2 tables
                  if (grepl("Lian", cl)) 
                    NumRowsAfterEst <- 2 else 
                    NumRowsAfterEst <- 3
                  tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                  tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                  tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                  tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                  iispace11 <- which(
                    grepl(".", tbest11) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                    )
                  iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                  iispace21 <- which(
                    grepl(".", tbest21) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                    )
                  # drop last rows of tbest2 to shrink row space
                  iispace21 <- iispace21[iispace21 < max(grep("toilet|water|nonla", tbest21))]
                  iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                  if (grepl("Lian|^e[ps]$", cl)) {
                  # ep: 2 rows per estimate
                    AdjustLineSkipRows1 <- iispace11
                    AltColorRows1 <- c(iispace12, iispace12+1)
                    AdjustLineSkipRows2 <- iispace21
                    AltColorRows2 <- c(iispace22, iispace22+1)
                  } else {
                  # epc, satt: 3 rows per estimate
                    AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                    AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                    AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                    AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                  }
                  # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                  tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-.7ex", 
                    adjlskiprows = AdjustLineSkipRows1,
                    AddTopStripSpace = "1.0ex",
                    alternatecolorManual = AltColorRows1,
                    alternatecolorManualColor = "gray80")
                  tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest21),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-.7ex", 
                    adjlskiprows = AdjustLineSkipRows2,
                    alternatecolorManual = AltColorRows2,
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows1 <- grep("nteract.*\\d", tbl1)
                  InterRows2 <- grep("nteract.*\\d", tbl2)
                  for (ir in InterRows1) {
                    if (any(grepl("rowcolor", tbl1[ir])))
                      tbl1[ir] <- 
                        # \makbox[XXcm]{inter with A} &&&& \\
                        #  => \multicolumn{5}{l}{\makebox[10cm]{inter with A}} \\
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl1[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          )
                      # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                      # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                      tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                      tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                      tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                  }
                  for (ir in InterRows2) {
                    if (any(grepl("rowcolor", tbl2[ir])))
                      tbl2[ir] <- 
                        # For rows with rowcolor command at the end
                        paste0("[1ex]\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl2[ir] <- 
                        paste0("[1ex]\\multicolumn{", ncol(tbest[[2]])+1, "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          )
                      tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                      tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                      tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                  }
                  clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                  # file path to saved table
                  pathtosavedtable1 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("NumGradesInitialEnrollersOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 1)
                    )
                  pathtosavedtable2 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("NumGradesInitialEnrollersOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 2)
                    )
                  write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable1, "\n")
                  cat("Table saved as", pathtosavedtable2, "\n")
                } else {
                # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                iispace <- which(
                  # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                  grepl(".", tbest[[1]]) & 
                  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                  )
                iispace2 <- iispace[seq(2, length(iispace), 2)]
                # adjlskiprows = c(iispace, iispace+1)
                # saveEstTable is in functions.R
                # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                  estimationspacelast = grep("thana dummi", tbest[[1]]),
                  hleft = "\\hfil\\tiny$", hright = "$", 
                  hcenter = c(boxWidth, rep(centerWidth-.15, ncol(tbest[[2]]))), 
                  delimiterline = NULL, adjustlineskip = "-0.5ex", 
                  adjlskiprows = c(iispace, iispace+1),
                  alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                  alternatecolorManualColor = "gray80")
                # Modify "interaction with ..." lines to use multicolumn
                InterRows <- grep("nteract.*\\d", tbl)
                for (ir in InterRows)
                  if (any(grepl("rowcolor", tbl[ir])))
                    tbl[ir] <- 
                      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                      # rows with rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                        )
                        ) else
                      # rows without rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                        )
                        )
                  # file path to saved table
                  pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("NumGradesInitialEnrollersOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                  write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable, "\n")
                } # If: DivInto2Tables ends
              } # cl: SE clustering option
            }  # m: ag HH definitions
          } # ge: gender
        }  # j: z2 (incl. extended) or z3 (nuclear)
      }  # s: lowerbound age cutoffs (10, 11, 12)
    }# dd
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0 # [[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]]
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
library(qs)
qsave(results, paste0(pathsaveThisVer, "FD_NumGradesInitialEnrollersGenderCRCoV_results.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "FD_N_NumGradesInigtialEnrollersGenderCRCoV_results.qs"))
NumGrades <- data.table(NumGrades)
NumGradeschg <- data.table(NumGradeschg)
setnames(NumGradeschg, c("sample", "HHtype", "agHHdef", "demean", "gender", "agelb", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(NumGrades, c("sample", "HHtype", "agHHdef", "demean", "gendr", 
  "agelb", "agHH", "tee", "rate", "Obs"))
qsave(NumGrades, paste0(pathsaveThisVer, "NumGradesInitialEnrollersGender.qs"))
qsave(NumGradeschg, paste0(pathsaveThisVer, "NumGradeschgInitialEnrollersGender.qs"))
@

\subsubsection{Days absent in June-August}

Days absent is mean number of days per month absent from school between June-August (2000, Table A.2.A 3 [\textsf{seca2a\_6.dta} \textsf{sabsl3}]) and July and August (2003, Table 1B 5, 6 [\textsf{hh01b\_005.dta} \textsf{q1b05, q1b06}]). For ``all children'' results, I use 0 for non-enrollers. This is misleading. Absent days can only be defined for enrollers. One needs to use the sample of all-time enrollers.

<<days absent by gender impacts, eval = F, results = 'hide', cache = F>>=
library(clubSandwich)
clusterlevel <- "thana"
DivInto2Tables <- T
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
samples <- "main"
z23 <- c("z2", "z3")
zsobj <- c("zmobjDays", "zpobjDays")
zmobjDays <- c("zEm.1999", "zSm.1999")
zpobjDays <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999")
cohort.years.list <- list(# year age is defined
  main = rep(1999, 2), # main: use 1999 age to set age range
  placebo = c(rep(2002, 2), rep(1999, 2))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(rep(2006, 2), rep(1999, 2), rep(2006, 2)) # year to drop in data, main = 2006, placebo 1999
# Used in "interaction with year InterYears" in results table
InterYearsList <- list(main = rep(2002, 2), placebo = rep(c(2006, 2002), each = 2))
regressors.list <- list(
  main = regressorsM,
  placebo = regressorsM2002
)
variables.always.use <- "^DaysAbsent$|^agHH.yr2|^agHH$|^thana$|uniqu"
yrXs <- c("yr2", "yr3")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
)
boxWidth <- 4
centerWidth <- 1.3
DaysAbsent <- DaysAbsentchg <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  var.always.use <- gsub("yr2", yrXs[ii], variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("DaysAbsent", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  # Use satterthwaite only.
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  res <- list(demeaned = res, undemeaned = res) # dd, demeaned/level interactions
  # res[[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  for (jj in 1:length(zSobj)) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    for (dd in 1:2) {
      z1 = copy(z01)
      if (dd == 2) {
        ## Restore undemeaned interactions: Start 
        # 1. Drop demeaned interactions
        iiyr <- grepout("\\.yr", colnames(z1))
        iiyr <- gsub("\\.yr.", "", iiyr)
        iiyr <- unique(gsub("\\...agHH|\\.agHH0", "", iiyr))
        # interactions
        iiyrX <- paste0(iiyr, ".", yrX)
        iiagHHyrX <- 
          paste0(rep(iiyr, each = length(aghh.defs)), ".", rep(aghh.defs, length(iiyr)), ".", yrX)
        # drop demeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NULL]
        # 2. Form undemeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NA]
        z1[, (yrX) := as.integer(1:.N-1), by = uniquid]
        # restore demeaned agHH def terms as binary variables
        for (mm in aghh.defs) {
          set(z1, i = which(z1[[mm]] > 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 1L)
          set(z1, i = which(z1[[mm]] <= 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 0L)
        }
        # restore demeaned covariates: copy from corresponding UDX (undemeaned X)
        for (kk in iiyr)
          set(z1, j = grep(kk, colnames(z1)), value = z1[[paste0("UD", kk)]])
        # form level interactions
        # X.yrx
        for (i in 1:length(iiyr))
          set(z1, j = grep(paste0("^", iiyrX[i]), colnames(z1)), value = z1[[iiyr[i]]]*z1[[yrX]])
        # X.agHH.yrx
        for (kk in iiyr)
          for (mm in aghh.defs)
            set(z1, j = grep(paste0("^", kk, ".", mm, ".", yrX),  colnames(z1)), 
              value = z1[[kk]]*z1[[mm]]*z1[[yrX]])
        ## Restore undemeaned interactions: End 
      } # end: if dd == 2
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      tabextend <- c("yes", "", "yes", "")
      tabcohortdemeaned <- c("", "yes", "", "yes")
      for (s in 1:3)
      #  choice of age cutoff
      {
        s0 <- (10:12)[s]
        if (ii == 2 & jj == 5) {
          s0 <- 6
          MaxAge <- 9
        } else {
          MaxAge <- 18
        }
        i <- paste0("older", s0)
        # latter panel: 5 <= age < s0 in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
          #maxAge
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
        for (j in 1:length(z23))
        {
          zz00 = copy(get(z23[j]))
          for (ge in 1:3)
          {
            if (ge == 1) {
              zz0 = copy(zz00[sex <= 0, ]) 
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else  if (ge == 2){
              zz0 = copy(zz00[sex > 0, ])
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else zz0 = copy(zz00)
            if (nrow(zz0) < SkipLowerBound) {
              cat("Skipped due to small number of obs:", nrow(zz0), "\n")
              next
            }
            setkey(zz0, uniquid, survey)
            zz0[, survey := NULL]
            for (m in 1:length(aghh.defs))
            {
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              ns <- NULL
              resul <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                zr <- zz[, covariates, with = F]
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   opposite.time.order = F,
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[dd]][[s]][[j]][[ge]][[m]] <- resul
              if (dd == 1) 
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) else {
                zidd <- lapply(resul, "[[", "diff.data")
                zidd <- zidd[[length(zidd)]]
                zid = copy(z2[uniquid %in% zidd[, uniquid], ])
                # drop other agHH defs and their interactions
                if (length(iiothag <- 
                  grep(paste0(gsub("\\\\\\.", "", aghh.defs.regexpr[-m]), collapse = "|"), colnames(zid))) > 0)
                  zid[, (iiothag) := NULL]
                # change agHH def name to "agHH"
                setnames(zid, 
                  grepout(aghh.defs[m], colnames(zid))
                  ,
                  gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zid)))
                )
              }
              zidd[, tee := 1]
              zid[, tee := 1:.N, by = uniquid]
              if (any(grepl("DaysAbsent", colnames(zidd)))) setnames(zidd, "DaysAbsent", "LHS")
              if (any(grepl("DaysAbsent", colnames(zid)))) setnames(zid, "DaysAbsent", "LHS")
              # Save mean days of absence
              enrr <- zid[, .(MeanDaysAbsent = mean(LHS), Num = .N), by = .(agHH, tee)]
              DaysAbsent <- rbind(DaysAbsent, 
                cbind(zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                  c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge],
                  s0, enrr),
                use.names = F
              )
              # Save mean progression rate changes
              # x: agHH, y: nonagHH
              ttestE <- t.test(zidd[agHH == 1, LHS], zidd[agHH == 0, LHS])
              DaysAbsentchg <- rbind(DaysAbsentchg, 
                cbind(
                    zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                    c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge],
                    s0, round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                    t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                    )
                  )
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "DaysAbsent")
              zidd[, tee := 1]
              for (cl in c("LiangZeger", "satterthwaite", "wildclusterboot")[-3]) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl 
                cat("\n\n###", cl, "###\n\n")
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "DaysAbsent", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (!is.logical(UseSmallClusterCorrection) && grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (!is.logical(UseSmallClusterCorrection) && grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  results0[[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                    list(est = rsl$est, ci = rsl$CI,
                      df = rsl$reg$df, reg = rsl$reg,
                      level.data = zid2[, covariates, with = F], 
                      diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean at baseline" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0, MeanDaysAbsent], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "control mean at follow up" = 
                       rep(formatC(enrr[tee == 2 & agHH == 0, MeanDaysAbsent], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at baseline" =
                       rep(formatC(enrr[tee == 1 & agHH == 1, MeanDaysAbsent], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at follow up" =
                       rep(formatC(enrr[tee == 2 & agHH == 1, MeanDaysAbsent], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "raw DID" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1, MeanDaysAbsent] - enrr[tee == 1 & agHH == 1, MeanDaysAbsent] 
                       -(enrr[tee == 2 & agHH == 0, MeanDaysAbsent] - enrr[tee == 1 & agHH == 0, MeanDaysAbsent]), 
                         digits = 2, format = "f"), length(regressorsS))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "satt"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source(paste0(pathprogram, "tabulate_est.R"))
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, #TableFormat = tabformat,
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$",
                  CIInTinySize = T, 
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                if (DivInto2Tables) {
                  # Split a table in to 2 tables
                  if (grepl("Lian", cl)) 
                    NumRowsAfterEst <- 2 else 
                    NumRowsAfterEst <- 3
                  tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                  tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                  tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                  tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                  iispace11 <- which(
                    grepl(".", tbest11) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                    )
                  iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                  iispace21 <- which(
                    grepl(".", tbest21) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                    )
                  # drop last rows of tbest2 to shrink row space
                  iispace21 <- iispace21[iispace21 < max(grep("toilet|water|nonla", tbest21))]
                  iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                  if (grepl("Lian", cl)) {
                  # ep: 2 rows per estimate
                    AdjustLineSkipRows1 <- iispace11
                    AltColorRows1 <- c(iispace12, iispace12+1)
                    AdjustLineSkipRows2 <- iispace21
                    AltColorRows2 <- c(iispace22, iispace22+1)
                  } else {
                  # epc, satt: 3 rows per estimate
                    AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                    AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                    AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                    AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                  }
                  tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows1,
                    alternatecolorManual = AltColorRows1,
                    alternatecolorManualColor = "gray80")
                  tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest21),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows2,
                    alternatecolorManual = AltColorRows2,
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows1 <- grep("nteract.*\\d", tbl1)
                  InterRows2 <- grep("nteract.*\\d", tbl2)
                  for (ir in InterRows1) {
                    if (any(grepl("rowcolor", tbl1[ir])))
                      tbl1[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl1[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          )
                      # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                      # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                      tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                      tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                      tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                  }
                  for (ir in InterRows2) {
                    if (any(grepl("rowcolor", tbl2[ir])))
                      tbl2[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl2[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          )
                      tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                      tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                      tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                  }
                  # file path to saved table
                  pathtosavedtable1 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("DaysAbsentOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 1)
                    )
                  pathtosavedtable2 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("DaysAbsentOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 2)
                    )
                  write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable1, "\n")
                  cat("Table saved as", pathtosavedtable2, "\n")
                } else {
                  # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                  # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                  iispace <- which(
                    # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                    grepl(".", tbest[[1]]) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                    )
                  iispace2 <- iispace[seq(2, length(iispace), 2)]
                  # adjlskiprows = c(iispace, iispace+1)
                  # saveEstTable is in functions.R
                  # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                  tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest[[1]]),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth-.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = c(iispace, iispace+1),
                    alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows <- grep("nteract.*\\d", tbl)
                  for (ir in InterRows)
                    if (any(grepl("rowcolor", tbl[ir])))
                      tbl[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          ) else
                        # rows without rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          )
                  # file path to saved table
                  pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("DaysAbsentOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                  write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable, "\n")
                } # If: DivInto2Tables ends
              } # cl: SE clustering choice ends
            }  # m: ag HH definitions
          } # ge: gender
        }  # j: z2 (incl. extended) or z3 (nuclear)
      }  # s: upperbound age cutoffs (10, 15)
    } # dd
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
library(qs)
qsave(results, paste0(pathsaveThisVer, "FD_DaysAbsentGenderCRCoV_results.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "FD_N_DaysAbsentGenderCRCoV_results.qs"))
DaysAbsent <- data.table(DaysAbsent)
DaysAbsentchg <- data.table(DaysAbsentchg)
setnames(DaysAbsentchg, c("sample", "HHtype", "agHHdef", "demean", "gender", "agelb", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(DaysAbsent, c("sample", "HHtype", "agHHdef", "demean", "gender", "agelb",
   "agHH", "tee", "rate", "Obs"))
qsave(DaysAbsent, paste0(pathsaveThisVer, "DaysAbsentGender.qs"))
qsave(DaysAbsentchg, paste0(pathsaveThisVer, "DaysAbsentchgGender.qs"))
@

<<days absent of enrollers by gender impacts, eval = F, results = 'hide', cache = F>>=
library(clubSandwich)
clusterlevel <- "thana"
DivInto2Tables <- T
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
samples <- "main"
z23 <- c("z2", "z3")
zsobj <- c("zmobjDays", "zpobjDays")
zmobjDays <- c("zEm.1999", "zSm.1999")[1]
zpobjDays <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999")[c(1, 3)]
cohort.years.list <- list(# year age is defined
  main = rep(1999, 2), 
  placebo = c(rep(2002, 1), rep(1999, 1))
  )
cutout.years<- c(rep(2006, 1), rep(1999, 1), rep(2006, 1)) # year to drop in data, main = 2006, placebo 1999
# Used in "interaction with year InterYears" in results table
InterYearsList <- list(main = rep(2002, 1), placebo = rep(c(2006, 2002), each = 2))
regressors.list <- list(
  main = regressorsM,
  placebo = regressorsM2002
)
variables.always.use <- "^DaysAbsent$|^agHH.yr2|^agHH$|^thana$|uniqu"
yrXs <- c("yr2", "yr3")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
)
boxWidth <- 4
centerWidth <- 1.3
DaysAbsent <- DaysAbsentchg <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  var.always.use <- gsub("yr2", yrXs[ii], variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("DaysAbsent", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  # Use satterthwaite only.
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  res <- list(demeaned = res, undemeaned = res) # dd, demeaned/level interactions
  # res[[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  for (jj in 1:length(zSobj)) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    # ss == 2: enrolled in 1999 and 2002. Number of grade progression?
    z01[, ss := cumsum(schoolp), by = uniquid]
    z01[, ss := ss[2], by = uniquid]
    z02 <- z01[ss==2, ]
    for (dd in 1:2) {
      z1 = copy(z02)
      if (dd == 2) {
        ## Restore undemeaned interactions: Start 
        # 1. Drop demeaned interactions
        iiyr <- grepout("\\.yr", colnames(z1))
        iiyr <- gsub("\\.yr.", "", iiyr)
        iiyr <- unique(gsub("\\...agHH|\\.agHH0", "", iiyr))
        # interactions
        iiyrX <- paste0(iiyr, ".", yrX)
        iiagHHyrX <- 
          paste0(rep(iiyr, each = length(aghh.defs)), ".", rep(aghh.defs, length(iiyr)), ".", yrX)
        # drop demeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NULL]
        # 2. Form undemeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NA]
        z1[, (yrX) := as.integer(1:.N-1), by = uniquid]
        # restore demeaned agHH def terms as binary variables
        for (mm in aghh.defs) {
          set(z1, i = which(z1[[mm]] > 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 1L)
          set(z1, i = which(z1[[mm]] <= 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 0L)
        }
        # restore demeaned covariates: copy from corresponding UDX (undemeaned X)
        for (kk in iiyr)
          set(z1, j = grep(kk, colnames(z1)), value = z1[[paste0("UD", kk)]])
        # form level interactions
        # X.yrx
        for (i in 1:length(iiyr))
          set(z1, j = grep(paste0("^", iiyrX[i]), colnames(z1)), value = z1[[iiyr[i]]]*z1[[yrX]])
        # X.agHH.yrx
        for (kk in iiyr)
          for (mm in aghh.defs)
            set(z1, j = grep(paste0("^", kk, ".", mm, ".", yrX),  colnames(z1)), 
              value = z1[[kk]]*z1[[mm]]*z1[[yrX]])
        ## Restore undemeaned interactions: End 
      } # end: if dd == 2
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      tabextend <- c("yes", "", "yes", "")
      tabcohortdemeaned <- c("", "yes", "", "yes")
      for (s in 1:3)
      #  choice of age cutoff
      {
        s0 <- (10:12)[s]
        if (ii == 2 & jj == 5) {
          s0 <- 6
          MaxAge <- 9
        } else {
          MaxAge <- 18
        }
        i <- paste0("older", s0)
        # latter panel: 5 <= age < s0 in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
          #maxAge
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
        for (j in 1:length(z23))
        {
          zz00 = copy(get(z23[j]))
          for (ge in 1:3)
          {
            if (ge == 1) {
              zz0 = copy(zz00[sex <= 0, ]) 
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else  if (ge == 2){
              zz0 = copy(zz00[sex > 0, ])
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else zz0 = copy(zz00)
            if (nrow(zz0) < SkipLowerBound) {
              cat("Skipped due to small number of obs:", nrow(zz0), "\n")
              next
            }
            setkey(zz0, uniquid, survey)
            zz0[, survey := NULL]
            for (m in 1:length(aghh.defs))
            {
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              ns <- NULL
              resul <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                zr <- zz[, covariates, with = F]
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   opposite.time.order = F,
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[dd]][[s]][[j]][[ge]][[m]] <- resul
              if (dd == 1) 
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) else {
                zidd <- lapply(resul, "[[", "diff.data")
                zidd <- zidd[[length(zidd)]]
                zid = copy(z2[uniquid %in% zidd[, uniquid], ])
                # drop other agHH defs and their interactions
                if (length(iiothag <- 
                  grep(paste0(gsub("\\\\\\.", "", aghh.defs.regexpr[-m]), collapse = "|"), colnames(zid))) > 0)
                  zid[, (iiothag) := NULL]
                # change agHH def name to "agHH"
                setnames(zid, 
                  grepout(aghh.defs[m], colnames(zid))
                  ,
                  gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zid)))
                )
              }
              zidd[, tee := 1]
              zid[, tee := 1:.N, by = uniquid]
              if (any(grepl("DaysAbsent", colnames(zidd)))) setnames(zidd, "DaysAbsent", "LHS")
              if (any(grepl("DaysAbsent", colnames(zid)))) setnames(zid, "DaysAbsent", "LHS")
              # Save mean days of absence
              enrr <- zid[, .(MeanDaysAbsent = mean(LHS), Num = .N), by = .(agHH, tee)]
              DaysAbsent <- rbind(DaysAbsent, 
                cbind(zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                  c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge],
                  s0, enrr),
                use.names = F
              )
              # Save mean progression rate changes
              # x: agHH, y: nonagHH
              ttestE <- t.test(zidd[agHH == 1, LHS], zidd[agHH == 0, LHS])
              DaysAbsentchg <- rbind(DaysAbsentchg, 
                cbind(
                    zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
                    c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge],
                    s0, round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                    t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                    )
                  )
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "DaysAbsent")
              zidd[, tee := 1]
              for (cl in c("LiangZeger", "satterthwaite", "wildclusterboot")[-3]) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl 
                cat("\n\n###", cl, "###\n\n")
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "DaysAbsent", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (!is.logical(UseSmallClusterCorrection) && grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (!is.logical(UseSmallClusterCorrection) && grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  results0[[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                    list(est = rsl$est, ci = rsl$CI,
                      df = rsl$reg$df, reg = rsl$reg,
                      level.data = zid2[, covariates, with = F], 
                      diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean at baseline" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0, MeanDaysAbsent], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "control mean at follow up" = 
                       rep(formatC(enrr[tee == 2 & agHH == 0, MeanDaysAbsent], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at baseline" =
                       rep(formatC(enrr[tee == 1 & agHH == 1, MeanDaysAbsent], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at follow up" =
                       rep(formatC(enrr[tee == 2 & agHH == 1, MeanDaysAbsent], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "raw DID" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1, MeanDaysAbsent] - enrr[tee == 1 & agHH == 1, MeanDaysAbsent] 
                       -(enrr[tee == 2 & agHH == 0, MeanDaysAbsent] - enrr[tee == 1 & agHH == 0, MeanDaysAbsent]), 
                         digits = 2, format = "f"), length(regressorsS))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "satt"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source(paste0(pathprogram, "tabulate_est.R"))
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, #TableFormat = tabformat,
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$",
                  CIInTinySize = T, 
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                if (DivInto2Tables) {
                  # Split a table in to 2 tables
                  if (grepl("Lian", cl)) 
                    NumRowsAfterEst <- 2 else 
                    NumRowsAfterEst <- 3
                  tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                  tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                  tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                  tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                  iispace11 <- which(
                    grepl(".", tbest11) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                    )
                  iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                  iispace21 <- which(
                    grepl(".", tbest21) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                    )
                  # drop last rows of tbest2 to shrink row space
                  iispace21 <- iispace21[iispace21 < max(grep("toilet|water|nonla", tbest21))]
                  iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                  if (grepl("Lian", cl)) {
                  # ep: 2 rows per estimate
                    AdjustLineSkipRows1 <- iispace11
                    AltColorRows1 <- c(iispace12, iispace12+1)
                    AdjustLineSkipRows2 <- iispace21
                    AltColorRows2 <- c(iispace22, iispace22+1)
                  } else {
                  # epc, satt: 3 rows per estimate
                    AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                    AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                    AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                    AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                  }
                  tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows1,
                    alternatecolorManual = AltColorRows1,
                    alternatecolorManualColor = "gray80")
                  tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest21),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows2,
                    alternatecolorManual = AltColorRows2,
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows1 <- grep("nteract.*\\d", tbl1)
                  InterRows2 <- grep("nteract.*\\d", tbl2)
                  for (ir in InterRows1) {
                    if (any(grepl("rowcolor", tbl1[ir])))
                      tbl1[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl1[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          )
                      # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                      # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                      tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                      tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                      tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                  }
                  for (ir in InterRows2) {
                    if (any(grepl("rowcolor", tbl2[ir])))
                      tbl2[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl2[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          )
                      tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                      tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                      tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                  }
                  # file path to saved table
                  pathtosavedtable1 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("DaysAbsentEnrollersOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 1)
                    )
                  pathtosavedtable2 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("DaysAbsentEnrollersOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 2)
                    )
                  write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable1, "\n")
                  cat("Table saved as", pathtosavedtable2, "\n")
                } else {
                  # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                  # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                  iispace <- which(
                    # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                    grepl(".", tbest[[1]]) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                    )
                  iispace2 <- iispace[seq(2, length(iispace), 2)]
                  # adjlskiprows = c(iispace, iispace+1)
                  # saveEstTable is in functions.R
                  # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                  tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest[[1]]),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth-.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = c(iispace, iispace+1),
                    alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows <- grep("nteract.*\\d", tbl)
                  for (ir in InterRows)
                    if (any(grepl("rowcolor", tbl[ir])))
                      tbl[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          ) else
                        # rows without rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          )
                  # file path to saved table
                  pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]),
                    AgeCutoff = paste0("DaysAbsentEnrollersOlder", (10:12)[s]),
                    HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                  write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable, "\n")
                } # If: DivInto2Tables ends
              } # cl: SE clustering choice ends
            }  # m: ag HH definitions
          } # ge: gender
        }  # j: z2 (incl. extended) or z3 (nuclear)
      }  # s: upperbound age cutoffs (10, 15)
    } # dd
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
library(qs)
qsave(results, paste0(pathsaveThisVer, "FD_DaysAbsentEnrollersGenderCRCoV_results.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "FD_N_DaysAbsentEnrollersGenderCRCoV_results.qs"))
DaysAbsent <- data.table(DaysAbsent)
DaysAbsentchg <- data.table(DaysAbsentchg)
setnames(DaysAbsentchg, c("sample", "HHtype", "agHHdef", "demean", "gender", "agelb", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(DaysAbsent, c("sample", "HHtype", "agHHdef", "demean", "gender", "agelb",
   "agHH", "tee", "rate", "Obs"))
qsave(DaysAbsent, paste0(pathsaveThisVer, "DaysAbsentEnrollersGender.qs"))
qsave(DaysAbsentchg, paste0(pathsaveThisVer, "DaysAbsentchgEnrollersGender.qs"))
@

<<days absent of enrollers cross section, eval = F, results = 'hide', cache = F>>=
library(clubSandwich)
clusterlevel <- "thana"
DivInto2Tables <- T
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
samples <- c("main", "placebo")
z23 <- c("z2", "z3")
zsobj <- c("zmobjDays", "zpobjDays")
zmobjDays <- c("zEm.1999", "zSm.1999")[1]
zpobjDays <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999")[1]
cohort.years.list <- list(# year age is defined
  main = rep(1999, 2), 
  placebo = c(rep(2002, 1), rep(1999, 1))
  )
cutout.years<- c(rep(2006, 1), rep(1999, 1), rep(2006, 1)) # year to drop in data, main = 2006, placebo 1999
# Used in "interaction with year InterYears" in results table
InterYearsList <- list(main = rep(2002, 1), placebo = rep(c(2006, 2002), each = 2))
regressors.list <- list(
  main = regressorsM,
  placebo = regressorsM2002
)
variables.always.use <- "^DaysAbsent$|^agHH$|^thana$|uniqu"
yrXs <- c("yr2", "yr3")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
)
boxWidth <- 4
centerWidth <- 1.3
DaysAbsent <- DaysAbsentchg <- CIs <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  # take away all .yr2$ and .*2 from regressorsS
  regressorsS <-  regressors.list[[ii]]
  regressorsS <- gsub("\\.yr.|\\.\\*yr[23]", "", regressorsS)
  regressorsS <- gsub("\\.\\*[23]", "", regressorsS)
  regressorsS <- gsub("\\$", "", regressorsS)
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  var.always.use <- gsub("yr[23]", yrXs[ii], variables.always.use)
  reorder <- reorder.list[[ii]]
  sampleyears <- list(c(1999, 2002), c(2002, 2006))[[ii]]
  regsnd <- rep("DaysAbsent", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  # Use satterthwaite only.
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  res <- list(demeaned = res, undemeaned = res) # dd, demeaned/level interactions
  res <- list("1999" = res, "2002" = res) # yy, cross section year
  # res[[dd]][[s]][[j]][[ge]][[m]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  for (jj in 1) {
    results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    # ss == 2: enrolled in 1999 and 2002. Number of grade progression?
    z01[, ss := cumsum(schoolp), by = uniquid]
    z01[, ss := ss[2], by = uniquid]
    for (rr in 1:2) {
      # Choose year
      for (yy in 1:2) {
        z02 = copy(z01[survey == sampleyears[yy] & schoolp == 1 & ss>=rr & 
          !is.na(sp.edulevel.primary) & !is.na(sp.edulevel.secondary) & !is.na(pcland), ])
        for (dd in 1) {
          z1 = copy(z02)
          z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
    #       # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
    #       setnames(z1, 
    #         grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
    #         gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
    #       z1[, grepout("^UD", colnames(z1)) := NULL]
    #       setnames(z1, 
    #         grepout("^ud", colnames(z1)),
    #         gsub("ud", "UD", grepout("^ud", colnames(z1))))
          tabextend <- c("yes", "", "yes", "")
          tabcohortdemeaned <- c("", "yes", "", "yes")
          for (s in 1:3)
          #  choice of age cutoff
          {
            s0 <- (10:12)[s]
            if (ii == 2 & jj == 5) {
              s0 <- 6
              MaxAge <- 9
            } else {
              MaxAge <- 18
            }
            i <- paste0("older", s0)
            # latter panel: 5 <= age < s0 in 1999/2002
            iiid <- unique(z1[
              s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
              eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
              #maxAge
              , uniquid])
            # Keep only former complete panel and respective years.
            z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
            z2[, grepout("exist|In", colnames(z2)) := NULL]
            z2 <- dropunbalanced(z2, returnDT = T)
            # z3: nuclear family
            z3 <- z2[sd == 1, ]
            z3 <- dropunbalanced(z3, returnDT = T)
            cat("\n\nage cutoff:", i, "\n\n")
            print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
            cat("dimension of original z1:", dim(z1), "\n")
            cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
            dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
            cat("dimension of z2 after keeping only balanced portion:", 
            dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
            cat("number of individuals in the panel:")
            print(table(table(z2[, uniquid])))
            cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
            cat("first-diffference estimator\n")
            for (j in 2) {
              zz00 = copy(get(z23[j]))
              for (ge in 1:3) {
                if (ge == 1) {
                  zz0 = copy(zz00[UDsex <= 0, ]) 
                  zz0[, grepout("^sex", colnames(zz0)) := NULL]
                } else  if (ge == 2){
                  zz0 = copy(zz00[sex > 0, ])
                  zz0[, grepout("^sex", colnames(zz0)) := NULL]
                } else zz0 = copy(zz00)
                if (nrow(zz0) < SkipLowerBound) {
                  cat("Skipped due to small number of obs:", nrow(zz0), "\n")
                  next
                }
                setkey(zz0, uniquid, survey)
                zz0[, survey := NULL]
                for (m in 1:length(aghh.defs)) {
                  zz = copy(zz0)
                  # Use a particular agHH definition.
                  # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
                  setnames(zz, 
                    grepout(aghh.defs[m], colnames(zz))
                    ,
                    gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
                  )
                  # drop other ag HH definitions
                  zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
                  zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
                  zz[, grepout(paste0("^UD", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
                  # Create X.agHH terms
                  # add sex as covariate for UDTerms to have corresponding DemeanedTerms
                  zz[, sex := UDsex - mean(UDsex)]
                  # 1. Extract interaction terms
                  yrXTerms <- grepout("\\.yr.$", colnames(zz))
                  agIntTerms <- gsub("\\.yr.", "", grepout("\\.ag.*?\\.yr", yrXTerms))
                  agIntHead <- gsub("\\.agHH", "", agIntTerms)
                  UDagIntHead <- paste0("UD", agIntHead)
                  UDagIntTerms <- paste0("UD", agIntTerms)
                  # 2. Create UDagIntTerms (undemeaned interaction) UDX.agHH0 terms
                  zz[, (UDagIntTerms) := NA]
                  # agHH def is already demeaned
                  zz[, agHH := as.integer(agHH>0)]
                  for (v in 1:length(UDagIntTerms))
                    set(zz, j = UDagIntTerms[v], value = zz[[UDagIntHead[v]]]*zz[["agHH"]])
                  # 4. Create demeaned X terms
                  # Restore demeaned terms to form demeaned interactions
                  # (Also demean agHH def which is included in DemeanedTerms)
                  for (v in 1:length(UDagIntHead))
                    set(zz, j = agIntHead[v], 
                      value = zz[[UDagIntHead[v]]]-mean(zz[[UDagIntHead[v]]]))
                  # 4. Create agIntTerms (demeaned X.agHH terms)
                  zz[, (agIntTerms) := NA]
                  for (v in 1:length(agIntTerms))
                    set(zz, j = agIntTerms[v], value = zz[[agIntHead[v]]]*zz[["agHH"]])
                  # drop yrX terms
                  zz[, grepout("\\.yr.$", colnames(zz)) := NULL]
                  ns <- Rs <- NULL
                  resul <- est <- vector("list", length = length(regressorsS))
                  for (k in 1:length(regressorsS)) {
                    if (s0 == 10 & j == 1 & m == 1) {
                      cat(paste0("(", k, ")\n"))
                      print0(paste0("+ ", 
                        grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                    }
                    regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                    covariates <- grepout(
                      paste(var.always.use, regrsr, sep = "|", collapse = "|")
                      , colnames(zz))
                    zr <- zz[, covariates, with = F]
                    RHS <- covariates[!grepl("^uniquid$|^thana$|^DaysAbsent$|^UD", covariates)]
                    form <- as.formula(paste0(regsnd[k], "~", paste(RHS, collapse = "+")))
                    rsl <- lm(data=data.frame(zr), form)
                    estres <- clubSandwich::coef_test(rsl, vcov = "CR2", 
                      cluster = as.numeric(zr[, thana]), test = "Satterthwaite")
                    estres <- as.data.frame(estres)
                    estres <- estres[, -1]
                    estci <- clubSandwich::conf_int(rsl, vcov = "CR2", level = 0.95, 
                      test = "Satterthwaite", cluster = as.numeric(zr[, thana]), coefs = "All", p_values = T)
                    estci <- as.data.frame(estci)
                    colnames(estres)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                    estresLZ <- clx(rsl, cluster = matrix(as.numeric(zr[, thana])), 
                      returnV = T, deviation = F)
                    enrr <- zr[, .(MeanDaysAbsent = mean(DaysAbsent), Num = .N), by = agHH]
                    resul[[k]] <- 
                      list(est = summary(rsl)$coeff, estBRL = estres, ciBRL = estci,
                        estLZ = estresLZ$est, ciLZ = estresLZ$ci,
                        df = rsl$df.residual, reg = rsl, 
                        R = summary(rsl)$adj.r, n = nrow(rsl$model),
                        rate = enrr, level.data = zr)
                    est[[k]] <- round(estres[, -3], 5)
                    Rs <- c(Rs, summary(rsl)$adj.r)
                    ns <- c(ns, nrow(rsl$model))
                  }
                  results0[[jj]][[yy]][[dd]][[s]][[j]][[ge]][[m]] <- resul
                  ciBRL <- lapply(resul, "[[", "ciBRL")
                  ciBRL <- lapply(ciBRL, as.matrix)
                  ciBRL <- lapply(ciBRL, function(x) as.data.table(x[, ]))
                  ciBRL <- lapply(1:length(ciBRL), function(i) ciBRL[[i]][, reg := i])
                  dfs <- lapply(resul, "[[", "df")
                  ciBRL <- lapply(1:length(ciBRL), function(i) ciBRL[[i]][, df := dfs[[i]]])
                  ciBRL <- lapply(1:length(ciBRL), function(i) ciBRL[[i]][, n := ns[i]])
                  ciBRL <- lapply(1:length(ciBRL), function(i) ciBRL[[i]][, R2 := Rs[i]])
                  ciBRL <- rbindlist(ciBRL, use.names = T, fill = T)
                  ciBRL[, inference := "BRL"]
                  setcolorder(ciBRL,  c("reg", "n", "df", "R2", "inference", "Coef", "beta", "SE", "p_val", "CI_L", "CI_U"))
                  esp <- lapply(resul, "[[", "ciLZ")
                  esp <- lapply(esp, as.matrix)
                  esprn <- unlist(lapply(esp, rownames))
                  esp <- lapply(esp, function(x) as.data.table(x[, ]))
                  esp <- lapply(1:length(esp), function(i) esp[[i]][, reg := i])
                  dfs <- lapply(resul, "[[", "df")
                  esp <- lapply(1:length(esp), function(i) esp[[i]][, df := dfs[[i]]])
                  esp <- lapply(1:length(esp), function(i) esp[[i]][, n := ns[i]])
                  esp <- lapply(1:length(esp), function(i) esp[[i]][, R2 := Rs[i]])
                  esp <- rbindlist(esp, use.names = T, fill = T)
                  if (any(grepl("z value", colnames(esp)))) esp[, "z value" := NULL]
                  estlz <- lapply(resul, "[[", "estLZ")
                  estlz <- lapply(estlz, as.matrix)
                  estrn <- unlist(lapply(estlz, rownames))
                  estlz <- lapply(estlz, function(x) as.data.table(x[, ]))
                  estlz <- rbindlist(estlz, use.names = T, fill = T)
                  ciLZ <- cbind(Coef = estrn, estlz, esp)
                  setnames(ciLZ,  c("Coef", "beta", "SE", "t", "p_val", "CI_L", "CI_U", "reg", "df", "n", "R2"))
                  ciLZ[, t := NULL]
                  ciLZ[, inference := "LZ"]
                  cis <- rbindlist(list(ciBRL, ciLZ), use.names = T)
                  cis[, data := zSobj[jj]]
                  cis[, HHtype := c("all", "direct")[j]]
                  cis[, agdef := aghh.defs[m]]
                  cis[, agelb := s0]
                  cis[, year := sampleyears[yy]]
                  cis[, sample := c("contemporaneous", "all time")[rr]]
                  cis[, gender := genderitems[ge]]
                  CIs <- rbind(CIs, cis)
                  enrr <- zr[, .(MeanDaysAbsent = mean(DaysAbsent), Num = .N), by = agHH]
                  DaysAbsent <- rbind(DaysAbsent, 
                    cbind(zSobj[jj], c("all", "nuclear")[j], 
                      sampleyears[yy], c("contemporaneous", "all time")[rr],
                      c("default", aghh.defs[-1])[m], 
                      c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge],
                      s0, enrr),
                    use.names = F
                  )
                  # Save mean progression rate changes
                  # x: agHH, y: nonagHH
                  ttestE <- t.test(zr[agHH == 1L, DaysAbsent], zr[agHH == 0L, DaysAbsent])
                  DaysAbsentchg <- rbind(DaysAbsentchg, 
                    cbind(
                        zSobj[jj], c("all", "nuclear")[j], 
                        sampleyears[yy], c("contemporaneous", "all time")[rr],
                        c("default", aghh.defs[-1])[m], 
                        c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge],
                        s0, round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                        t(as.numeric(unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                        )
                      )
                }  # m: ag HH definitions
              } # ge: gender
            }  # j: z2 (incl. extended) or z3 (nuclear)
          }  # s: upperbound age cutoffs (10, 15)
        } # dd
      } # yy: 1999 or 2002
    } # rr: 1 contemporanesou enroller or 2 all time enroller
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
setcolorder(CIs,  c("data", "sample", "year", "HHtype", "agdef", "agelb", "gender", "reg", "n", "df", "R2", "inference", 
   "Coef", "beta", "SE", "p_val", "CI_L", "CI_U"))
thesecols <- c("n", "df", "R2", "beta", "SE", "p_val", "CI_L", "CI_U")
CIs[, (thesecols) := lapply(.SD, as.numeric), .SDcols = thesecols]
thesecols <- colnames(CIs)[!colnames(CIs) %in% thesecols]
CIs[, (thesecols) := lapply(.SD, as.factor), .SDcols = thesecols]
library(qs)
qsave(results, paste0(pathsaveThisVer, "FD_DaysAbsentCrossSection_results.qs"))
qsave(CIs, paste0(pathsaveThisVer, "FD_DaysAbsentCrossSection_CIs.qs"))

CIs[grepl("Em", data) & grepl("4|5|7", reg) & grepl("^agH", Coef) & grepl("all", sample) & grepl(9, year) &
  agelb == 10 & grepl("B", inference) & grepl("s.g", gender), ]

DaysAbsent <- data.table(DaysAbsent)
DaysAbsentchg <- data.table(DaysAbsentchg)
setnames(DaysAbsentchg, c("data", "HHtype", "year", "sample", "agHHdef", "demean", 
  "gender", "agelb", "AgNonag", "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(DaysAbsent, c("data", "HHtype", "year", "sample", "agHHdef", "demean", "gender", "agelb",
   "agHH",  "rate", "Obs"))
DaysAbsent[, gender := factor(gender, levels=genderitems)]
DaysAbsent[, agHHdef := factor(agHHdef, levels=aghh.defs)]
qsave(DaysAbsent, paste0(pathsaveThisVer, "DaysAbsentCrossSection.qs"))
qsave(DaysAbsentchg, paste0(pathsaveThisVer, "DaysAbsentchgCrossSection.qs"))
@

<<tabulate grade absent by gender results, eval = F>>=
# grades: results[[ii]][[jj]][[ge]][[s]][[j]][[m]][[clnum]][[k]]
resultsG <- qread(paste0(pathsaveThisVer, "FD_NumGradesGenderCRCoV_results.qs"))
resultsGE <- qread(paste0(pathsaveThisVer, "FD_NumGradesEnrollersGenderCRCoV_results.qs"))
resultsGIE <- qread(paste0(pathsaveThisVer, "FD_NumGradesInitialEnrollersGenderCRCoV_results.qs"))
#resultsGN <- qread(paste0(pathsaveThisVer, "FD_N_NumGradesGenderCRCoV_results.qs"))
# days absent: results[[ii]][[jj]][[ge]][[s]][[j]][[m]][[clnum]][[k]]
resultsD <- qread(paste0(pathsaveThisVer, "FD_DaysAbsentGenderCRCoV_results.qs"))
resultsDE <- qread(paste0(pathsaveThisVer, "FD_DaysAbsentEnrollersGenderCRCoV_results.qs"))
#resultsDN <- qread(paste0(pathsaveThisVer, "FD_N_DaysAbsentGenderCRCoV_results.qs"))
# G: 1, D: 2, GE: 3, GIE: 4, DE: 5
zsobj <- c("zmobj", "zpobj")
zmobj <- "zEm.1999"
zpobj <- c("zEp.2002", "zEp.1999")
eGD <- NR <- Enr <- NULL
for (gd in 1:5) {   
  for (ii in 1) {
    zSobj <- get(zsobj[[ii]])
    for (jj in 1:length(zSobj)) {
      thisdata <- zSobj[[jj]]
      for (dd in 1:2) {
        for (s in 1:3) {
          for (j in 1:2) {
            for (ge in 1:3) {
              for (m in 1:4) {
                for (clnum in 1:2) {
                  if (gd == 1)  {
                    # grades
                    #ii <- jj <- s <- m <- 1
                    #j <- clnum <- 2
                    estGDs1 <- resultsG[[ii]][[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]]
                  } else if (gd == 3) {
                    estGDs1 <- resultsGE[[ii]][[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]]
                  } else if (gd == 4) {
                    estGDs1 <- resultsGIE[[ii]][[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]]
                  } else if (gd == 5) {
                    estGDs1 <- resultsDE[[ii]][[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]]
                  } else {
                    # days absent
                    #ii <- jj <- s <- m <- 1
                    #j <- clnum <- 2
                    estGDs1 <- resultsD[[ii]][[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]]
                  }
                  estGDs <- lapply(estGDs1, "[[", "ci")
                  estGDs <- lapply(estGDs, data.table)
                  estGDs <- lapply(1:length(estGDs), function(i) estGDs[[i]][, reg := i])
                  estGDs <- rbindlist(estGDs)
                  # if clnum == 1, estFM only contain CIs
                  if (clnum == 1) {
                    esp <- lapply(estGDs1, "[[", "est")
                    esp <- lapply(esp, as.matrix)
                    esprn <- unlist(lapply(esp, rownames))
                    esp <- lapply(esp, function(x) as.data.table(x[, ]))
                    dfs <- lapply(lapply(estGDs1, "[[", "est"), function(x) attributes(x)$df)
                    esp <- lapply(1:length(esp), function(i) esp[[i]][, df := dfs[[i]]])
                    esp <- rbindlist(esp, use.names = T, fill = T)
                    if (any(grepl("z value", colnames(esp)))) esp[, "z value" := NULL]
                    estGDs <- cbind(Coef = esprn, esp, estGDs)
                    setnames(estGDs,  c("Coef", "beta", "SE", "t", "p_val", "df", "CI_L", "CI_U", "reg"))
                    estGDs[, t := NULL]
                  }
                  setcolorder(estGDs,  c("Coef", "beta", "SE", "df", "p_val", "CI_L", "CI_U", "reg"))
                  estGD <- estGDs
                  estGD[, file := c("grade", "absent", "grade enr", "grade initial enr", "absent enr")[gd]]
                  estGD[, demean := c("demeaned", "undemeaned")[dd]]
                  estGD[, agelb := (10:12)[s]]
                  estGD[, agdef := aghh.defs[m]]
                  estGD[, HHtype := c("all", "direct")[j]]
                  estGD[, inference := c("LZ", "BRL")[clnum]]
                  estGD[, gender := genderitems[ge]]
                  estGD[, data := thisdata]
                  eGD <- rbind(eGD, estGD)
                  # n and R2
                  nR <- lapply(lapply(estGDs1, "[[", "reg"), 
                    function(x) t(c(length(summary(x)$res), summary(x)$r.sq)))
                  nR <- lapply(nR, data.table)
                  nR <- lapply(1:length(nR), function(i) nR[[i]][, reg := i])
                  nR <- rbindlist(nR)
                  nR[, file := c("grade", "absent", "grade enr", "grade initial enr", "absent enr")[gd]]
                  nR[, demean := c("demeaned", "undemeaned")[dd]]
                  nR[, agelb := (10:12)[s]]
                  nR[, agdef := aghh.defs[m]]
                  nR[, HHtype := c("all", "direct")[j]]
                  nR[, gender := genderitems[ge]]
                  nR[, data := thisdata]
                  setnames(nR, paste0("V", 1:2), c("n", "R"))
                  nR[, n := formatC(n, digits = 0, format = "f")]
                  nR[, R := formatC(R, digits = 4, format = "f")]
                  NR <- rbind(NR, nR)
                  # treated and control means
                  zid <- lapply(estGDs1, "[[", "level.data")
                  zidd <- lapply(estGDs1, "[[", "diff.data")
                  zid <- lapply(1:length(zid), function(i) zid[[i]][uniquid %in% zidd[[i]][, uniquid], ])
                  zid <- lapply(zid, function(x) x[eval(parse(text=grepout("agHH$", colnames(x)))) > 0, 
                            agHH := 1L])
                  zid <- lapply(zid, function(x) x[eval(parse(text=grepout("agHH$", colnames(x)))) <= 0, 
                            agHH := 0L])
                  zid <- lapply(zid, function(x) x[, tee := 1:.N, by = uniquid])
                  if (gd %in% c(1, 3, 4)) 
                    lapply(zid, function(x) setnames(x, "NumGrades", "LHS")) else
                    lapply(zid, function(x) setnames(x, "DaysAbsent", "LHS"))
                  enr <- lapply(zid, function(x) x[, .(EnRate = mean(LHS), Num = .N), by = .(agHH, tee)])
                  enr <- lapply(1:length(enr), function(i) enr[[i]][, spec := i])
                  enr <- rbindlist(enr)
                  enr[, demean := c("demeaned", "undemeaned")[dd]]
                  enr[, agelb := (10:12)[s]]
                  enr[, agdef := aghh.defs[m]]
                  enr[, HHtype := c("all", "direct")[j]]
                  enr[, gender := genderitems[ge]]
                  enr[, data := thisdata]
                  enr[, file := c("grade", "absent", "grade enr", "grade initial enr", "absent enr")[gd]]
                  enr <- unique(enr[, spec := NULL])
                  Enr <- rbind(Enr, enr)
                } # clnum
              } # m
            } # ge
          } # j
        } # s
      } # dd
    } # jj
  } # ii
} # gd
qsave(eGD, paste0(pathsaveThisVer, "GenderGradeDaysAbsentTabulated.qs"))
qsave(NR, paste0(pathsaveThisVer, "GenderGradeDaysAbsentTabulatedNR.qs"))
qsave(Enr, paste0(pathsaveThisVer, "GenderGradeDaysAbsentTabulatedEnr.qs"))
@




%\subsubsection{Repetition}



%\subsubsection{Entry age}

\subsection{Subsample estimation: age groups, non Muslims, flood}



\subsubsection{Age wise subsamples}


<<agewise subsample by gender, eval = F, results = 'hide', warning = F, cache = F>>=
library(clubSandwich)
library(fwildclusterboot)
clusterlevel <- "thana"
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zSm.1999 <- readRDS(paste0(pathsaveThisVer, "zSm1999.rds"))
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zSp.1999 <- readRDS(paste0(pathsaveThisVer, "zSp1999.rds"))
zSp.2002 <- readRDS(paste0(pathsaveThisVer, "zSp2002.rds"))
zYp.1999 <- readRDS(paste0(pathsaveThisVer, "zYp1999.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
zSp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
zf <- unique(zEm.1999[, .(uniquid, AgeGroup1999, Agegroup1999)])
zf[, AgeGroup1999 := droplevels(AgeGroup1999)]
zf[, Agegroup1999 := droplevels(Agegroup1999)]
setkey(zf, uniquid)
ze <- unique(zEm.1999[, .(uniquid, Edu1999)])
ze <- ze[!grepl("other", Edu1999), ]
ze[, Edu1999 := droplevels(Edu1999)]
setkey(ze, uniquid)
# Edu1999 is actual class in 1999 which is not defined for outofschool children.
#    6-10: Primary (primary0103, primary0405)
#  11-13: Junior secondary (secondary 0608)
#  14-15: Secondary (secondary0912)
#  16-17: Higher secondary (secondary0912)
# Supposed school age: Class to be enrolled under official school system schedule
# But this is just another labeling of age.
# In class wise regressions, default category becomes Edu1999 = NA and schoolp = 0.
# This is a group of children who are out of school for long period (so they do not
# provide class information). This is not a natural reference category, 
# so we may drop the class wise estimation.
# We can leave class wise regressions in the code for now.
## Age wise agHH.yrX was created in Construct3RoundPanel_JHR.rnw
#  zEm.1999: Main, exist sample.
#  zSm.1999: Main, schooling sample.
#  zEp.1999: Placebo, 2002 shocks on 1999 cohort.
#  zEp.2002: Placebo, 2002 shocks on 2002 cohort.
#  zYp.1999: Placebo, 2002 shocks on young 1999 cohort.
for (zob in c("zEm.1999", "zSm.1999", "zEp.1999", "zEp.2002", "zYp.1999")) {
  zdata <- get(zob)
  for (agstring in aghh.defs) {
    for (aa in 6:maxAge) {
      if (grepl("m", zob)) # zEm.1999, zSm.1999
      {
        zdata[, dumage := as.numeric(eval(parse(text=paste0("Age==", aa, ""))))]
        zdata[, dumage := dumage - mean(dumage, na.rm = T)]
        zdata[, (paste0("DummyAgeIn1999.", putzeroontop(aa, F, 2), ".yr2")) :=
          eval(parse(text="(survey == 1999)*dumage"))] 
        # agHH.yr2 * dumage
        zdata[, (paste0("DummyAgeIn1999.", putzeroontop(aa, F, 2), ".", agstring, ".yr2")) :=
          eval(parse(text=paste0(agstring, ".yr2*dumage")))] 
      } else if (grepl("p.1", zob)) # zEp.1999, zYp.1999
      {
        zdata[, dumage := as.numeric(eval(parse(text=paste0("Age==", aa, ""))))]
        zdata[, dumage := dumage - mean(dumage, na.rm = T)]
        zdata[, (paste0("DummyAgeIn1999.", putzeroontop(aa, F, 2), ".yr3")) :=
          eval(parse(text="(survey == 2002)*dumage"))] 
        zdata[, (paste0("DummyAgeIn1999.", putzeroontop(aa, F, 2), ".", agstring, ".yr3")) :=
          eval(parse(text=paste0(agstring, ".yr3*dumage")))] 
      } else { # zEp.2002
        zdata[, dumage := as.numeric(eval(parse(text=paste0("Age==", aa, ""))))]
        zdata[, dumage := dumage - mean(dumage, na.rm = T)]
        zdata[, (paste0("DummyAgeIn2002.", putzeroontop(aa, F, 2), ".yr3")) :=
          eval(parse(text="(survey == 2002)*dumage"))] 
        zdata[, (paste0("DummyAgeIn2002.", putzeroontop(aa, F, 2), ".", agstring, ".yr3")) :=
          eval(parse(text=paste0(agstring, ".yr3*dumage")))] 
      }
    }
  }
  assign(zob, zdata)
}
zsobj <- c("zEm.1999", "zEp.2002", "zEp.1999", "zYp.1999")
names(zsobj) <- c("main", "placebo2", "placebo9", "placeboY")
# Data vector elements. 
# Except for Y, each has 3 elements because there are 3 age groupings.
# zEm.1999: 1999 shocks on 1999 cohorts (agewise, AgeGroup, Agegroup)
# zEp.2002: 2002 shocks on 2002 cohorts (agewise, AgeGroup, Agegroup)
# zEp.1999: 2002 shocks on 1999 cohorts (agewise, AgeGroup, Agegroup)
# zYp.1999: 2002 shocks on young 1999 cohorts
cohort.years.list <- list(
    main = 1999
  , placebo2 = 2002
  , placebo9 = 1999
  , placeboY = 1999
)
# year to drop from data
cutout.years <- c(2006, 1999, 1999, 1999)
InterYearsList <- list(
    main = 2002
  , placebo2 = 2006
  , placebo9 = 2002
  , placeboY = 2002
)
yrXs <- c("yr2", "yr3", "yr3", "yr3")
ShockYears <- c(1999, 2002, 2002, 2002)
AGEgrouping <- c("agewise", "AgeGroup1", "AgeGroup2", "AgeGroup3")
agewise <- as.list(6:18); names(agewise) <- putzeroontop(6:18)
AgeGroup1 <- list(pri=6:10, jsec=11:13, sec=14:15, hsec=16:17, coll=18)
AgeGroup2 <- list(pri=6:10, sec=11:17, coll=18)
AgeGroup3 <- list(young=6:9, junior=10:15, senior=16:18)
  # agewise = (currently) Not age wise. Same as main. 
  # AgeGroup1 = AgeGroup: 6-10, 11-13, 14-15, 16-17, above17
  # AgeGroup2 = Agegroup: 6-10, 11-17, above17
  # Note: placeboY only have one age group, below 10 in 1999
variables.always.use <- "schoolp|Enrolled|^agHH.yr2|^agHH$|^thana$|uniqu|^UDO|UDhds"
# year to interact with agHH. yr2 is yr1-yr2 diff, yr3 is yr2-yr3 diff.
reorder.list <- list(
    main = main.reorder.JHR
  , placebo = main.reorder.JHR
  , placebo2 = main.reorder.JHR
  , placebo.young = mix.reorder("^agHH$|^agHH.yr3$|^hdagHH.yr3$|")
)
regressors.list <- list(
  main = regressorsM,
  placebo2 = regressorsM2002,
  placebo9 = regressorsM2002,
  placeboY = regressorsM2002
)
# EnrCV.age: enrollment rates by agHH*agegroup*period
# EnrCVchg.age: enrollment rate changes by agHH*agegroup*period
Enr.Agegroup <- Enrchg.Agegroup <- NULL
boxWidth <- 4
centerWidth <- 1.2
old <- F
ii <- jj <- dd <- m <- 1
j <- 2; ge <- 3
results <- vector("list", length(zsobj)) # ii
names(results) <- names(zsobj)
for (ii in 1:length(zsobj)) {
  z001 <- changehyphen(get(zsobj[ii]))
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]] # tested on cohort 1999 or cohort 2002
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  reorder <- reorder.list[[ii]]
  yrxYear <- ShockYears[ii] # Supposed shock year: 1999 or 2002
  yrX <- yrXs[ii]  # Supposed shock year in yrY description: yr2 or yr3
  resge <- list(boys = NULL, girls = NULL, "boys+girls" = NULL) # j
  for (ge in 1:3) {
    if (ge == 1) z01 <- z001[sex <= 0, ] else if (ge == 2) z01 <- z001[sex > 0, ] else z01 <- z001
    resdd <- list(demeaned = NULL, undemeaned = NULL)
    for (dd in 1:2) {
      z1 = copy(z01)
      if (dd == 2) {
        ## Restore undemeaned interactions: Start 
        # 1. Drop demeaned interactions
        iiyr <- grepout("\\.yr", colnames(z1))
        iiyr <- gsub("\\.yr.", "", iiyr)
        iiyr <- unique(gsub("\\...agHH|\\.agHH0", "", iiyr))
        # interactions
        iiyrX <- paste0(iiyr, ".", yrX)
        iiagHHyrX <- 
          paste0(rep(iiyr, each = length(aghh.defs)), ".", rep(aghh.defs, length(iiyr)), ".", yrX)
        # drop demeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NULL]
        # 2. Form undemeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NA]
        z1[, (yrX) := as.integer(1:.N-1), by = uniquid]
        # restore demeaned agHH def terms as binary variables
        for (mm in aghh.defs) {
          set(z1, i = which(z1[[mm]] > 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 1L)
          set(z1, i = which(z1[[mm]] <= 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 0L)
        }
        # restore demeaned covariates: copy from corresponding UDX (undemeaned X)
        for (kk in iiyr)
          set(z1, j = grep(kk, colnames(z1)), value = z1[[paste0("UD", kk)]])
        # form level interactions
        # X.yrx
        for (i in 1:length(iiyr))
          set(z1, j = grep(paste0("^", iiyrX[i]), colnames(z1)), value = z1[[iiyr[i]]]*z1[[yrX]])
        # X.agHH.yrx
        for (kk in iiyr)
          for (mm in aghh.defs)
            set(z1, j = grep(paste0("^", kk, ".", mm, ".", yrX),  colnames(z1)), 
              value = z1[[kk]]*z1[[mm]]*z1[[yrX]])
        ## Restore undemeaned interactions: End 
      } # end: if dd == 2
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      z1[, village := factor(gsub(" ", "", village))]
      #z1[, grepout("exist|^..agHH|\\-\\d$|DummyAge", colnames(z1)) := NULL]
      z1[, grepout("exist|\\-\\d$|DummyAge", colnames(z1)) := NULL]
      resm <- vector("list", length = length(aghh.defs)) # m
      names(resm) <- aghh.defs
      for (m in 1:4) {
        z11 = copy(z1)
        # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
        setnames(z11, 
          grepout(aghh.defs[m], colnames(z1))
          ,
          gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(z11)))
        )
        # drop other ag HH definition
        z11[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(z11)) := NULL]
        # change yr2 => yr3 if placebo, yr3 => yr2 if main
        var.always.use <- variables.always.use
        if (grepl("yr2", yrX)) 
          var.always.use <- gsub("yr3", "yr2", var.always.use) else
          var.always.use <- gsub("yr2", "yr3", var.always.use)
        z2 <- z11[survey != cutout.year, ]
        # Drop yrX other than yrx
        if (any(grepl(unique(yrXs[yrX != yrXs]), colnames(z2))))
          z2[, grepout(unique(yrXs[yrX != yrXs]), colnames(z2)) := NULL]
        # Do not drop agHH.yrX becase we use it as the regressor of reference category
        z2 <- dropunbalanced(z2, returnDT = T)
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        resj <- vector("list", length = 2) # j
        names(resj) <- c("all", "direct")
        regsnd <- rep("schoolp", length(regressorsS))
        for (j in 1:2) {
          zz0 <- get(z23[j])
          setkey(zz0, uniquid, survey)
          zz = copy(zz0)
          resgg <- vector("list", length = length(AGEgrouping)) # gg
          names(resgg) <- AGEgrouping
          for (gg in 1:length(AGEgrouping)) {
            AGEgroup <- get(AGEgrouping[gg])  # agewise, AgeGroup1, AgeGroup2
            aghhvar <- aghh.defs[1]
            ns <- NULL
            cat("\n\n")
            print0(zSobj[gg])
            cat("\n")
            cat(AGEgrouping[gg])
            cat("\n\n")
            print(grepout("agHH\\.|Age", grepout(var.always.use, colnames(z3))))
            resag <- vector("list", length = length(AGEgroup)) # ag
            names(resag) <-  names(AGEgroup)
            for (ag in 1:length(AGEgroup))
            {
              # target ages: minAge - maxAge in cohort.years
              iiid <- unique(z2[eval(parse(text = paste0("AgeIn", cohort.years))) >= min(AGEgroup[[ag]]) 
                & eval(parse(text = paste0("AgeIn", cohort.years))) <= max(AGEgroup[[ag]]), uniquid]) 
              zzg <- zz[uniquid %in% iiid, ]
              if (nrow(zzg) < 40) {
                cat("Skipped due to small number of obs:", nrow(zzg), "\n")
                next
              }
              ns <- NULL
              resul <- est <- vector("list", length = length(regressorsS))
              for (k in 1:length(regressorsS))
              {
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), colnames(zzg))
                print0(paste0("+ ", grepout(regressorsS[k], colnames(z3))))
                zr <- zzg[, covariates, with = F]
                #  source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                    clusterstring = clusterlevel, group = "^uniquid$", 
                    NotToBeDifferenced = "^agHH$|^UD|^pc.*[dt]$",
                    intercept = T, PeriodToDropForLC = 2, 
                    TimeVariant = "program|age2|meanY",
                   # opposite.time.order: set to F to keep regression data in tact 
                   # (to be used in DID2 in the later chunk). Signs of estimates
                   # are oppositte between DID1 and DID2.
                    opposite.time.order = F,
                    TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              if (dd == 1) 
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) else {
                zidd <- lapply(resul, "[[", "diff.data")
                zidd <- zidd[[length(zidd)]]
                zid = copy(z2[uniquid %in% zidd[, uniquid], ])
                # drop other agHH defs and their interactions
                if (length(iiothag <- 
                  grep(paste0(gsub("\\\\\\.", "", aghh.defs.regexpr[-m]), collapse = "|"), colnames(zid))) > 0)
                  zid[, (iiothag) := NULL]
                # change agHH def name to "agHH"
                setnames(zid, 
                  grepout(aghh.defs[m], colnames(zid))
                  ,
                  gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zid)))
                )
              }
              zt = copy(zz) # zz is z2/z3
              if (any(grepl("schoolp", colnames(zt)))) setnames(zt, "schoolp", "Enrolled")
              # save mean enrollment rate changes
              zt[, aghh := 1L]
              zt[agHH <= 0, aghh := 0L]
              zt[, tee := 1]
              zt[survey == max(survey), tee := 2]
              enrr <- zt[, .(EnRate = mean(Enrolled), Obs = .N), 
                by = .(aghh, tee)]
              d0 <- zt[aghh == 0L, .(diff = diff(Enrolled)), by = uniquid][, diff]
              d1 <- zt[aghh == 1L, .(diff = diff(Enrolled)), by = uniquid][, diff]
              ttestE <- t.test(d1, d0)
              Enr.Agegroup <- rbind(Enr.Agegroup, 
                cbind(zSobj[jj], aghh.defs[m],  c("demeaned", "undemeaned")[dd],
                  names(resj)[j], AGEgrouping[gg], names(AGEgroup)[ag], names(resge)[ge],
                  enrr)
                , use.names = T, fill = T)
              Enrchg.Agegroup <- rbind(Enrchg.Agegroup, 
                t(c(zSobj[jj], aghh.defs[m], c("demeaned", "undemeaned")[dd],
                  names(resj)[j], AGEgrouping[gg], names(AGEgroup)[ag], names(resge)[ge],
                  round(-diff(unlist(ttestE["estimate"])), 3),
                  unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
                , use.names = F)
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "Enrolled")
              # Drop covariates not used in 1st run for zYp.1999 data, because they are all zero's.
              # Covariates of: AgeIn1999.06, AgeIn1999.07.
              iiAllZero <- sapply(zidd, function(x) all(x == 0))
              zidd <- zidd[, !iiAllZero, with = F]
              zidd[, tee := 1] # redundant but needed in DID2.
              res <- vector("list", length(ClusteringMethod)) # ii
              names(res) <- names(ClusteringMethod)
              for (cl in ClusteringMethod[-3]) {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl 
                cat("\n\n###", cl, "###\n\n")
                est <- res <- resul <- vector("list", length = length(regressorsS)) # k
                res <- rep(list(res), length(ClusteringMethod)) # cl: 
                names(res) <- ClusteringMethod
                clnum <- 1 
                if (grepl("satt", cl)) clnum <- 2
                # res[[cl]][[k]]: this is stored for each cl in resge[[ag]]
                # resultsN: raw results (not under same obs)
                for (k in 1:length(regressorsS)) {
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  # var.always.use has level variables used only for destat purpose, so drop them
                  covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)]
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                  # DID2 use first-differenced data (zidd from DID1 with opposite.time.order = F) 
                  # zidd took t - (t-1) difference, so schoolp is usually 0 or -1 (1 in 1999, 0 in 2002).
                  # In our estimation, we take (t-1) - t difference.
                  rsl <- DID2(dX0 = zr, Regressand = "Enrolled", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (!is.logical(UseSmallClusterCorrection) && grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (!is.logical(UseSmallClusterCorrection) && grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  res[[clnum]][[k]] <- list(
                    est = rsl$est, ci = rsl$CI,
                    df = rsl$reg$df, reg = rsl$reg,
                    level.data = z2[uniquid %in% zidd[, uniquid], gsub("Enrolled", "schoolp", covariates), with = F], 
                    diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean at baseline" = 
                       rep(formatC(enrr[tee == 1 & aghh == 0, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "control mean at follow up" = 
                       rep(formatC(enrr[tee == 2 & aghh == 0, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at baseline" =
                       rep(formatC(enrr[tee == 1 & aghh == 1, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "treated mean at follow up" =
                       rep(formatC(enrr[tee == 2 & aghh == 1, EnRate], 
                         digits = 2, format = "f"), length(regressorsS)),
                     "raw DID" =
                       rep(formatC(
                       enrr[tee == 2 & aghh == 1, EnRate] - enrr[tee == 1 & aghh == 1, EnRate] 
                       -(enrr[tee == 2 & aghh == 0, EnRate] - enrr[tee == 1 & aghh == 0, EnRate]), 
                         digits = 2, format = "f"), length(regressorsS))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "satt"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source(paste0(pathprogram, "tabulate_est.R"))
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, #TableFormat = tabformat,
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears, c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$",
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                  # If base::":"(from, to) error, check reorder.
                # saveEstTable is in functions.R
                # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                # Split a table in to 2 tables
                tbest11 <- tbest[[1]][1:(grep(paste0("inter.*", InterYears, ".*ag"), tbest[[1]])-3)]
                tbest12 <- tbest[[2]][1:(grep(paste0("inter.*", InterYears, ".*ag"), tbest[[1]])-3), ]
                tbest21 <- tbest[[1]][grep(paste0("inter.*", InterYears, ".*ag"), tbest[[1]]):length(tbest[[1]])]
                tbest22 <- tbest[[2]][grep(paste0("inter.*", InterYears, ".*ag"), tbest[[1]]):length(tbest[[1]]), ]
                iispace11 <- which(
                  grepl(".", tbest11) & 
                  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                  )
                if (nrow(tbest12) == max(iispace11)) iispace11 <- iispace11[iispace11 != max(iispace11)]
                iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                iispace21 <- which(
                  grepl(".", tbest21) & 
                  !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                  )
                if (nrow(tbest22) == max(iispace21)) iispace21 <- iispace21[iispace21 != max(iispace21)]
                # drop last rows of tbest2 to shrink row space
                iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                if (grepl("Lian", cl)) {
                # ep: 2 rows per estimate
                  AdjustLineSkipRows1 <- iispace11
                  AltColorRows1 <- c(iispace12, iispace12+1)
                  AdjustLineSkipRows2 <- iispace21
                  AltColorRows2 <- c(iispace22, iispace22+1)
                } else {
                # epc, satt: 3 rows per estimate
                  AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                  AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                  AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                  AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                }
                tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                  hleft = "\\hfil\\tiny$", hright = "$", 
                  hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                  delimiterline = NULL, adjustlineskip = "-0.7ex", 
                  adjlskiprows = AdjustLineSkipRows1,
                  alternatecolorManual = AltColorRows1,
                  alternatecolorManualColor = "gray80")
                tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                  estimationspacelast = grep("thana dummi", tbest21),
                  hleft = "\\hfil\\tiny$", hright = "$", 
                  hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                  delimiterline = NULL, adjustlineskip = "-0.7ex", 
                  adjlskiprows = AdjustLineSkipRows2,
                  alternatecolorManual = AltColorRows2,
                  alternatecolorManualColor = "gray80")
                # Modify "interaction with ..." lines to use multicolumn
                InterRows1 <- grep("nteract.*\\d", tbl1)
                InterRows2 <- grep("nteract.*\\d", tbl2)
                for (ir in InterRows1) {
                  if (any(grepl("rowcolor", tbl1[ir])))
                    tbl1[ir] <- 
                      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                      # For rows with rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                        )
                        ) else
                      # For rows without rowcolor command at the end
                    tbl1[ir] <- 
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                        )
                        )
                    # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                    # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                    tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                    tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                    tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                }
                for (ir in InterRows2) {
                  if (any(grepl("rowcolor", tbl2[ir])))
                    tbl2[ir] <- 
                      # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                      # For rows with rowcolor command at the end
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                        )
                        ) else
                      # For rows without rowcolor command at the end
                    tbl2[ir] <- 
                      paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                        gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                        #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                        gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                        )
                        )
                    # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                    # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                    tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                    tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                    tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                }
                clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                pathtosavedtable1 <- TabFilePathF(
                  FolderPath = pathsaveThisVer, 
                  Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                    c("", "Undemeaned")[dd]),
                  AgeCutoff = paste0(AGEgrouping[gg], names(AGEgroup)[ag]),
                  HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                  AgHHDef = "",
                  CRSEMethod = paste0(clCap, 1)
                )
                pathtosavedtable2 <- TabFilePathF(
                  FolderPath = pathsaveThisVer, 
                  Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                    c("", "Undemeaned")[dd]),
                  AgeCutoff = paste0(AGEgrouping[gg], names(AGEgroup)[ag]),
                  HHType = paste0(c("", "Nuclear")[j], c("Boys", "Girls", "")[ge]),
                  AgHHDef = "",
                  CRSEMethod = paste0(clCap, 2)
                )
                write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                cat("Table saved as", pathtosavedtable1, "\n")
                cat("Table saved as", pathtosavedtable2, "\n")
              } # cl: SE clustering option
              # res has [[clnum]][[k]] levels for each ag.
              # resag has [[ag]][[clnum]][[k]] levels.
              resag[[ag]] <- res
            } # ag: age group
            # resgg has [[gg]][[ag]][[clnum]][[k]] levels.
            resgg[[gg]] <- resag
          } # gg: AGEgrouping
          # resj has [[j]][[gg]][[ag]][[clnum]][[k]] levels.
          resj[[j]] <- resgg
        } # j: household type
        # resm has [[m]][[j]][[gg]][[ag]][[clnum]][[k]] levels.
        resm[[m]] <- resj
      } # m: agHH def
      resdd[[dd]] <- resm
    } # dd: demean/level interactions
    # resge has [[ge]][[dd]][[j]][[gg]][[ag]][[clnum]][[k]] levels.
    resge[[ge]] <- resdd
  } # ge: gender: 1 = boys, 2 = girls, 3 = boys+girls
  # results has [[ii]][[ge]][[dd]][[m]][[j]][[gg]][[ag]][[clnum]][[k]] levels.
  results[[ii]] <- resge
} # ii: main/placebo
library(qs)
qsave(results, paste0(pathsaveThisVer, "FD_SubsampleAgeGenderCRCoV_results.qs"))
#qsave(resultsN, paste0(pathsaveThisVer, "FD_N_SubsampleAgeGenderCRCoV_results.qs"))
Enr.Agegroup <- data.table(Enr.Agegroup)
Enrchg.Agegroup <- data.table(Enrchg.Agegroup)
setnames(Enrchg.Agegroup, c("sample", "agdef", "demean", "HHtype", 
  "AgeGrouping", "ages", "gender",
  "AgNonag", "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(Enr.Agegroup, c("sample", "agdef", "demean", "HHtype", "AgeGrouping", 
  "ages", "gender", "agHH", "survey", "rate", "Obs"))
Enr.Agegroup[, gender := factor(gender, levels = genderitems)]
Enr.Agegroup[, ages := factor(ages)]
Enr.Agegroup[, AgeGrouping := factor(AgeGrouping)]
Enr.Agegroup[, HHtype := factor(HHtype)]
Enr.Agegroup[, agdef := factor(agdef)]
Enr.Agegroup[, sample := factor(sample)]
qsave(Enr.Agegroup, paste0(pathsaveThisVer, "Enr.AgegroupGender.qs"))
qsave(Enrchg.Agegroup, paste0(pathsaveThisVer, "Enrchg.AgegroupGender.qs"))
Enr.Agegroup <- qread(paste0(pathsaveThisVer, "Enr.AgegroupGender.qs"))
<<>>=
ThisTheme <- theme(
   axis.text.x = element_text(size = 12, angle = 0, vjust = 1, hjust = .5), 
   axis.text.y = element_text(size = 12), 
   axis.title = element_text(size = 10), 
   strip.text.x = element_text(color = "blue", size = 8, 
     margin = margin(0, 1.25, 0, 1.25, "cm")), 
   strip.text.y = element_text(color = "blue", size = 8, 
     margin = margin(1.5, 0, 1.5, 0, "cm")),
   panel.spacing.x = unit(c(.1), units = "cm"),
   panel.spacing.y = unit(.1, units = "cm"), 
   legend.position = "none")
ThisThemeEnd <- ThisTheme + theme(legend.position="bottom")
@

<<plot gender agewise, eval = F>>=
library(ggplot2)
#mbga <- qread(paste0(pathsaveThisVer, "MainByGenderAge.qs"))
Res2 <- qread(paste0(pathsaveThisVer, "TabulatedMainResults2.qs"))
Res2[, gender := factor(gender, levels = genderitems)]
mbga <- Res2[grepl("4|5|7", reg) & grepl("di", HHtype) & grepl("^de", demean) & 
  grepl(0, agdef) & grepl("^agHH.yr2$", Coef), ]
mbga[, hr := paste0(HHtype, "-", reg)]

g <- 
ggplot(data = mbga[grepl("agewise", agegroup), ], 
    aes(x = group, y = beta, group = reg, fill = reg, shape = reg, colour = reg)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .5)) +
  facet_grid( ~ gender, scales = "free_y")+
  ThisThemeEnd+
  scale_y_continuous(limits = c(-1, 1))+
  xlab("age groups") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 1),
    fill = guide_legend(title = "regression specifications", nrow = 1),
    shape = guide_legend(title = "regression specifications", nrow = 1)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "GenderAgewiseImpacts.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
<<plot gender AgeGroup1, eval = F>>=
library(ggplot2)
PointRange <-  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .25))
g <- 
ggplot(data = Res2[grepl("A.*1", agegroup), ], 
    aes(x = group, y = beta, group = reg, fill = reg, shape = reg, colour = reg)) + 
  PointRange + ThisTheme + facet_grid(gender ~ HHtype) +
  xlab("age groups") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 1),
    fill = guide_legend(title = "regression specifications", nrow = 1),
    shape = guide_legend(title = "regression specifications", nrow = 1)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "GenderAgeGroup1Impacts.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
<<plot gender AgeGroup2, eval = F>>=
library(ggplot2)
Res2 <- qread(paste0(pathsaveThisVer, "TabulatedMainResults2.qs"))
Res2[, gender := factor(gender, levels = genderitems)]
mbga <- Res2[grepl("4|5|7", reg) & grepl("di", HHtype) & grepl("^de", demean) & 
  grepl(0, agdef) & grepl("^agHH.yr2$", Coef), ]
mbga[, hr := paste0(HHtype, "-", reg)]
PointRange <-  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .25))
g <- 
ggplot(data = mbga[grepl("A.*2", agegroup) & !is.na(group), ], 
    aes(x = group, y = beta, group = hr, fill = hr, shape = hr, colour = hr)) + 
  PointRange + ThisTheme + facet_grid( ~ gender) +
  xlab("age groups") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  ThisThemeEnd +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 1),
    fill = guide_legend(title = "regression specifications", nrow = 1),
    shape = guide_legend(title = "regression specifications", nrow = 1)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "GenderAgeGroup2Impacts.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<plot gender AgeGroup3, eval = F>>=
library(ggplot2)
Res2 <- qread(paste0(pathsaveThisVer, "TabulatedMainResults2.qs"))
Res2[, gender := factor(gender, levels = genderitems)]
mbga <- Res2[grepl("4|5|7", reg) & grepl("di", HHtype) & grepl("^de", demean) & 
  grepl(0, agdef) & grepl("^agHH.yr2$", Coef), ]
mbga[, hr := paste0(HHtype, "-", reg)]
g <- 
ggplot(data = mbga[grepl("3", agegroup), ],
    aes(x = group, y = beta, group = hr, fill = hr, shape = hr, colour = hr)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .5)) +
  facet_grid(agdef ~ gender)+
  ThisThemeEnd+
  xlab("age groups") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 1),
    fill = guide_legend(title = "regression specifications", nrow = 1),
    shape = guide_legend(title = "regression specifications", nrow = 1)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "GenderAgegroup3Impacts.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<plot gender older siblings AgeGroup3, eval = F>>=
# Not an interesting nor convincing figure (better if we plot results of 10-18 for boys, 12-18 for girls)
library(ggplot2)
mbga <- qread(paste0(pathsaveThisVer, "MainByGenderAge.qs"))
mbga[, hs := paste0(HHtype, "-", spec)]
mbga[, Sib := gsub("OldSib", "", gsub("\\..*", "", Coef))]
mbga[, gs := paste0(Gender, "-", Sib)]
mbga <- mbga[grepl("3", Agegroup) & grepl("4|5|6", spec) & grepl("Sib.*H.yr2$", Coef), ]
g <- 
ggplot(data = mbga, 
    aes(x = Group, y = beta, group = hs, fill = hs, shape = hs, colour = hs)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .5)) +
  facet_grid(Agdef ~ gs)+
  ThisThemeEnd+
  xlab("age groups") + 
  scale_y_continuous(limits = c(-.75, .5))+
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 1),
    fill = guide_legend(title = "regression specifications", nrow = 1),
    shape = guide_legend(title = "regression specifications", nrow = 1)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "GenderAgegroup3SibInteractionImpacts.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<plot agewise, eval = F>>=
MainByAge <- qread(paste0(pathsaveThisVer, "MainByAge.qs"))
MainByAge <- MainByAge[grepl("4|5|6", spec), ]
MainByAge[, spec := factor(spec, label = 1:3)]
library(ggplot2)
g <- ggplot(data = MainByAge[grepl("age", Agegroup), ], 
    aes(x = Group, y = beta, group = spec, fill = spec, shape = spec, colour = spec)) + 
  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .5)) +
  facet_grid(. ~ HHtype)+
  ThisTheme+
  xlab("age groups") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 1),
    fill = guide_legend(title = "regression specifications", nrow = 1),
    shape = guide_legend(title = "regression specifications", nrow = 1)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "AgewiseImpacts.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
<<plot AgeGroup1, eval = F>>=
library(ggplot2)
PointRange <-  geom_pointrange(aes(ymin = CI_L, ymax = CI_U),
    stat = "identity", fatten = 1.75, 
    position = position_dodge(width = .25))
g <- ggplot(data = MainByAge[grepl("A.*1", Agegroup), ], 
    aes(x = Group, y = beta, group = spec, fill = spec, shape = spec, colour = spec)) + 
  PointRange + ThisTheme + facet_grid(. ~ HHtype) +
  xlab("age groups") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 1),
    fill = guide_legend(title = "regression specifications", nrow = 1),
    shape = guide_legend(title = "regression specifications", nrow = 1)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "AgeGroup1Impacts.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
<<plot AgeGroup2, eval = F>>=
library(ggplot2)
g <- ggplot(data = MainByAge[grepl("A.*2", Agegroup), ], 
    aes(x = Group, y = beta, group = spec, fill = spec, shape = spec, colour = spec)) + 
  PointRange + ThisTheme + facet_grid(. ~ HHtype) +
  xlab("age groups") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 1),
    fill = guide_legend(title = "regression specifications", nrow = 1),
    shape = guide_legend(title = "regression specifications", nrow = 1)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "AgeGroup2Impacts.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<plot AgeGroup3, eval = F>>=
library(ggplot2)
g <- ggplot(data = MainByAge[grepl("A.*3", Agegroup), ], 
    aes(x = Group, y = beta, group = spec, fill = spec, shape = spec, colour = spec)) + 
  PointRange + ThisTheme + facet_grid(. ~ HHtype) +
  xlab("age groups") + 
  labs(color  = "regression specifications", fill = "regression specifications", 
    shape = "regression specifications") +
  guides(
    colour = guide_legend(title = "regression specifications", nrow = 1),
    fill = guide_legend(title = "regression specifications", nrow = 1),
    shape = guide_legend(title = "regression specifications", nrow = 1)
    ) +
  geom_hline(aes(yintercept = yintercept), colour = "lightgreen")
pdf(
  paste0(pathsaveThisVer, "AgeGroup3Impacts.pdf")
  , width = 2*12/2.54, height = 2*8/2.54)
print(g)
whatever <- dev.off()
@
<<>>=
Enr.Agegroup <- qread(paste0(pathsaveThisVer, "Enr.Agegroup.qs"))
Enrchg.Agegroup <- qread(paste0(pathsaveThisVer, "Enrchg.Agegroup.qs"))
@


\subsubsection{Non Muslims estimation}

<<non muslim gender, eval = F, results = 'hide', cache = F>>=
# Estimation by main/placebo * aghh.defs * age lb * gender * demeaned/level interaction * HHtype
# with LiangZeger or Satterthwaite CRSEs.
# source(paste0(pathprogram, "PartialFile.R"))
library(clubSandwich)
clusterlevel <- "thana"
DivInto2Tables <- T
regressors.list <- list(
  main = regressorsN,
  placebo = regressorsN2002
)
Enr.Base <- qread(paste0(pathsaveThisVer, "Enr.Base.qs"))
Enrchg.Base <- qread(paste0(pathsaveThisVer, "Enrchg.Base.qs"))
source(paste0(pathprogram0, "TabGeneric.R"))
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds")) 
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds")) 
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds")) 
cohort.years.list <- list(# year age is defined
  main = rep(1999, 2), # main: use 1999 age to set age range
  placebo = c(rep(2002, 1), rep(1999, 1))
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
InterYearsList <- list(main = rep(2002, 2), placebo = rep(2006, 2))
yrXs <- c("yr2", "yr3")
variables.always.use <- "schoolp|Enrolled|^agHH.yr2|^agHH$|^thana$|uniqu|^UDnon|^UDfl|^UD.*Sib|^UDhds|^pcland$|^pcnlasset$"
muslim.reorder.JHR = c("^.Inter|^age$|age2|yield|^(any)?prog|^rain|^high|^low|Std|",
    "^agHH.yr\\d$|^nonmuslim.yr\\d$|^nonm.*agH|",
    "^sex.yr\\d$|^...e.*y.yr\\d$|hd.?sex.yr\\d$|Sib..yr\\d$|^pcland.y|^pcnlasset.y|water.y|latrine.y|",
    "^sex.*H.*\\d$|hd.ed.*H.*\\d$|hd.?sex.*H.*\\d$|Sib.*H.yr\\d$|^pcland.*H.*\\d$|^pcnlasset.*H.*\\d$|water.*H.y|latrine.*H.y")
muslim.reorder.JHR <- paste0(muslim.reorder.JHR, collapse = "")
reorder.list <- list(
  main = muslim.reorder.JHR,
  placebo = muslim.reorder.JHR
  )
var.always.use <- "schoolp|Enrolled|^agHH.yr2|^agHH$|^thana$|uniqu|^nonmuslim$|^UD.*Sib|^UDpcland$|^UDpcnlasset$|hdsex$"
boxWidth <- 4
centerWidth <- 1.3
# Below gives: IDinNonMuslimDID14
source(paste0(pathprogram0, "IDinNonMuslimDID14.R"))
z23 <- c("z2", "z3")
samples <- c("main", "placebo")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")[1]
zpobj <- c("zEp.2002", "zEp.1999")
results <- resultsN <- vector("list", length = length(samples)) # ii
names(results) <- names(resultsN) <- samples
Enr.NonMuslim <- Enrchg.NonMuslim <- NULL
SkipLowerBound <- 50
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  yrX <- yrXs[ii]
  var.always.use <- gsub("yr2", yrX, variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("schoolp", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  res <- list(demeaned = res, undemeaned = res) # dd, demeaned/level interactions
  # res[[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  names(results0) <- names(resultsN0) <- zSobj
  for (jj in 1:length(zSobj)) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    for (dd in 1:2) {
      z1 = copy(z01)
      if (dd == 2) {
        ## Restore undemeaned interactions: Start 
        # 1. Drop demeaned interactions
        iiyr <- grepout("\\.yr", colnames(z1))
        iiyr <- gsub("\\.yr.", "", iiyr)
        iiyr <- unique(gsub("\\...agHH|\\.agHH0", "", iiyr))
        # interactions
        iiyrX <- paste0(iiyr, ".", yrX)
        iiagHHyrX <- 
          paste0(rep(iiyr, each = length(aghh.defs)), ".", rep(aghh.defs, length(iiyr)), ".", yrX)
        # drop demeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NULL]
        # 2. Form undemeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NA]
        z1[, (yrX) := as.integer(1:.N-1), by = uniquid]
        # restore demeaned agHH def terms as binary variables
        for (mm in aghh.defs) {
          set(z1, i = which(z1[[mm]] > 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 1L)
          set(z1, i = which(z1[[mm]] <= 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 0L)
        }
        # restore demeaned covariates: copy from corresponding UDX (undemeaned X)
        for (kk in iiyr)
          set(z1, j = grep(kk, colnames(z1)), value = z1[[paste0("UD", kk)]])
        # form level interactions
        # X.yrx
        for (i in 1:length(iiyr))
          set(z1, j = grep(paste0("^", iiyrX[i]), colnames(z1)), value = z1[[iiyr[i]]]*z1[[yrX]])
        # X.agHH.yrx
        for (kk in iiyr)
          for (mm in aghh.defs)
            set(z1, j = grep(paste0("^", kk, ".", mm, ".", yrX),  colnames(z1)), 
              value = z1[[kk]]*z1[[mm]]*z1[[yrX]])
        ## Restore undemeaned interactions: End 
      } # end: if dd == 2
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      tabextend <- c("yes", "", "yes", "")
      tabcohortdemeaned <- c("", "yes", "", "yes")
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      if (ii == 2 & jj == 5) smax <- 1 else smax <- 3
      for (s in 1:smax)
      #  choice of age cutoff
      {
        s0 <- (10:12)[s]
        if (ii == 2 & jj == 5) {
          s0 <- 6
          MaxAge <- 9
        } else {
          MaxAge <- 18
        }
        i <- paste0("older", s0)
        # latter panel: s <= age < maxAge in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
          #maxAge
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        z4 <- z2[sd != 1, ]
        z4 <- dropunbalanced(z4, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
        for (j in 1:length(z23))
        {
          zz00 <- get(z23[j])
          setkey(zz00, uniquid, survey)
          zz00[, survey := NULL]
          for (ge in 1:3)
          {
            if (ge == 1) {
              zz0 = copy(zz00[sex <= 0, ]) 
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else  if (ge == 2){
              zz0 = copy(zz00[sex > 0, ])
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else zz0 = copy(zz00)
            if (nrow(zz0) < SkipLowerBound) {
              cat("Skipped due to small number of obs:", nrow(zz0), "\n")
              next
            }
            for (m in 1:length(aghh.defs))
            {
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              ns <- NULL
              resul <- est <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                # pick covariates for k-th regression: 
                #  paste " ..|.." & "..|.." with collapse = "|"
                #  then use it in grepout
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                # if (ii == 2 & jj == 1)
                #if (grepl("zEp.2|zSp", zSobj[jj]))
                # zEp.2002: UDOldSibF is all 0, UDOldSibM is all 0 but 2 obs, so drop them (and interactions).
                #  covariates <- covariates[!grepl("OldSib", covariates)]
                covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)] # drop real valued level variables
                zr <- zz[, covariates, with = F]
                # source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$|^UD|^pc.*[dt]$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   opposite.time.order = F, # Use t - (t-1) diff
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              if (!any(grepl("latrine.agHH.yr|water.agHH.yr", rownames(est[[k]])))) {
                cat(zSobj[jj], "agelb", s0, z234[j], c("boys", "girls", "boys+girls")[ge], 
                  c("demeaned", "undemeaned")[dd], aghh.defs[m], "\n")
                cat("Skipped, some covariates cannot be used due to too small number of obs:", nrow(zr), "\n\n")
                next
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[dd]][[s]][[j]][[ge]][[m]] <- resul
              # First run estimation data is stored in resul.
              # Pick the last item of data list which has the least num of obs. 
              # (This is data to use for all specifications.)
              # zidd: Differenced data of the last item in resul.
              # zid2: Level data to reconstruct and demean interaction terms of covariates.
              if (dd == 1) 
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) else {
                zidd <- lapply(resul, "[[", "diff.data")
                zidd <- zidd[[length(zidd)]]
                zid = copy(z2[uniquid %in% zidd[, uniquid], ])
                # drop other agHH defs and their interactions
                if (length(iiothag <- 
                  grep(paste0(gsub("\\\\\\.", "", aghh.defs.regexpr[-m]), collapse = "|"), colnames(zid))) > 0)
                  zid[, (iiothag) := NULL]
                # change agHH def name to "agHH"
                setnames(zid, 
                  grepout(aghh.defs[m], colnames(zid))
                  ,
                  gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zid)))
                )
                zid[, Enrolled := schoolp]
              }
              zidd[, tee := 1]
              zidd[, nonmuslim := as.numeric(eval(parse(text=paste0("nonmuslim.", yrX, ">0"))))]
              enrr <- zid[, .(EnRate = mean(Enrolled), Num = .N), by = .(agHH, nonmuslim, tee)]
              Enr.NonMuslim <- rbind(Enr.NonMuslim, 
                cbind(zSobj[jj], c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], s0, enrr),
                use.names = F
              )
              # Save mean enrollment rate changes
              # x: agHH, y: nonagHH
              if (length(zidd[nonmuslim > 0 & agHH == 0, LHS]) > 1 & 
                length(zidd[nonmuslim > 0 & agHH == 1, LHS]) > 1) {
                ttestE <- t.test(zidd[nonmuslim > 0 & agHH == 1, LHS], zidd[nonmuslim > 0 & agHH == 0, LHS])
                enrch <- t(c(zSobj[jj], group = "nonmuslim",
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], s0,
                    # DID, diff.x, diff.y, CIlower, CIupper, p value
                  round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                  unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
              } else 
                enrch <- t(c(zSobj[jj], group = "nonmuslim",
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], s0,
                    # DID, diff.x, diff.y, CIlower, CIupper, p value
                  rep(NA, 6)))
              enrch <- data.table(enrch)
              Enrchg.NonMuslim <- rbind(Enrchg.NonMuslim, enrch, use.names = F)
              if (length(zidd[nonmuslim <= 0 & agHH == 0, LHS]) > 1 & 
                length(zidd[nonmuslim <= 0 & agHH == 1, LHS]) > 1) {
                ttestE <- t.test(zidd[nonmuslim <= 0 & agHH == 1, LHS], zidd[nonmuslim <= 0 & agHH == 0, LHS])
                enrch <- t(c(zSobj[jj], group = "muslim",
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], s0,
                    # DID, diff.x, diff.y, CIlower, CIupper, p value
                  rep(NA, 6)))
              } else
                enrch <- t(c(zSobj[jj], group = "muslim", 
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], s0,
                  round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                  unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
              enrch <- data.table(enrch)
              Enrchg.NonMuslim <- rbind(Enrchg.NonMuslim, enrch, use.names = F)
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "Enrolled")
              #for (cl in c("LiangZeger", "satterthwaite", "wildclusterboot")) 
              for (cl in c("LiangZeger", "satterthwaite")) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl
                cat("\n\n###", cl, "###\n\n")
                #if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl) & any(grepl("Sib", colnames(zidd)))) {
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  # Julia fails for specification 6 in zEm.1999, zEp.1999, zEp.2002
                  if (grepl("wild", cl) & k == 6) next
                  #if (ii == 1 & grepl("S", zSobj[jj]) & s >= 1 & m == 4 & k >= 5 & grepl("wild", cl)) 
                  #zSm1999FDOlder10Occ
                  #  next
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  # var.always.use has level variables used only for destat purpose, so drop them
                  covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)]
                  # Commented out: Aug 2, 2023 Start
                  #if (grepl("zEp|zSp", zSobj[jj]))
                  #  covariates <- covariates[!grepl("OldSib", covariates)]
                  # Commented out: Aug 2, 2023 End
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "Enrolled", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  results0[[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                    list(est = rsl$est, ci = rsl$CI,
                      df = rsl$reg$df, reg = rsl$reg,
                      #level.data = leveldata[, gsub("Enrolled", "LHS", covariates), with = F], 
                      level.data = zid, 
                      diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  # Sign reversion is done before DID2. Below is redundant.
                  # Take19992002Diff is set to F in "read data chunk" at the beginning
                  # If (t-1) - t difference (opposite time order), signs of yrX cross terms are inverted.
                  #if (Take19992002Diff) est[[k]][grepout("Inter|yr.$", rownames(est[[k]])), c(1, 3)] <- 
                  #  -1 * est[[k]][grepout("Inter|yr.$", rownames(est[[k]])), c(1, 3)]
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsN)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean in 1999, muslim" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0 & nonmuslim == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "control mean in 1999, nonmuslim" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0 & nonmuslim == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "treated mean in 1999, muslim" =
                       rep(formatC(enrr[tee == 1 & agHH == 1 & nonmuslim == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "treated mean in 1999, nonmuslim" =
                       rep(formatC(enrr[tee == 1 & agHH == 1 & nonmuslim == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "change in control mean, nmuslim" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 0 & nonmuslim == 0, EnRate]-
                         enrr[tee == 1 & agHH == 0 & nonmuslim == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "change in control mean, nonmuslim" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 0 & nonmuslim == 1, EnRate]-
                         enrr[tee == 1 & agHH == 0 & nonmuslim == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "change in treated mean, muslim" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 1 & nonmuslim == 0, EnRate]-
                         enrr[tee == 1 & agHH == 1 & nonmuslim == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "change in treated mean, nonmuslim" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 1 & nonmuslim == 1, EnRate]-
                         enrr[tee == 1 & agHH == 1 & nonmuslim == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsN)),
                     "raw DID, muslim" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1 & nonmuslim == 0, EnRate] - 
                       enrr[tee == 1 & agHH == 1 & nonmuslim == 0, EnRate] 
                       -(enrr[tee == 2 & agHH == 0 & nonmuslim == 0, EnRate] - 
                         enrr[tee == 1 & agHH == 0 & nonmuslim == 0, EnRate]), 
                         digits = 3, format = "f"), length(regressorsN)),
                     "raw DID, nonmuslim" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1 & nonmuslim == 1, EnRate] - 
                       enrr[tee == 1 & agHH == 1 & nonmuslim == 1, EnRate] 
                       -(enrr[tee == 2 & agHH == 0 & nonmuslim == 1, EnRate] - 
                         enrr[tee == 1 & agHH == 0 & nonmuslim == 1, EnRate]), 
                         digits = 3, format = "f"), length(regressorsN))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "epc"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source(paste0(pathprogram, "tabulate_est.R"))
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, 
                  CIInTinySize = T, 
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$",
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                  # Split a table in to 2 tables
                if (DivInto2Tables) {
                  # Split a table in to 2 tables
                  if (grepl("e[ps]$", OUTformat)) 
                    NumRowsAfterEst <- 2 else 
                    NumRowsAfterEst <- 3
                  tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                  tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                  tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                  tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                  iispace11 <- which(
                    grepl(".", tbest11) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                    )
                  iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                  iispace21 <- which(
                    grepl(".", tbest21) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                    )
                  # drop last rows of tbest2 to shrink row space
                  iispace21 <- iispace21[iispace21 < max(grep("toilet|water|nonla", tbest21))]
                  iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                  if (grepl("e[ps]$", OUTformat)) {
                  # ep, es: 2 rows per estimate
                    AdjustLineSkipRows1 <- iispace11
                    AltColorRows1 <- c(iispace12, iispace12+1)
                    AdjustLineSkipRows2 <- iispace21
                    AltColorRows2 <- c(iispace22, iispace22+1)
                  } else {
                  # epc, esc, satt: 3 rows per estimate
                    AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                    AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                    AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                    AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                  }
                 #source("c:/seiro/settings/Rsetting/functions.R")
                  tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows1,
                    alternatecolorManual = AltColorRows1,
                    alternatecolorManualColor = "gray80")
                  tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest21),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows2,
                    alternatecolorManual = AltColorRows2,
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows1 <- grep("nteract.*\\d", tbl1)
                  InterRows2 <- grep("nteract.*\\d", tbl2)
                  for (ir in InterRows1) {
                    if (any(grepl("rowcolor", tbl1[ir])))
                      tbl1[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl1[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          )
                    # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                    # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                    tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                    tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                    tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                  }
                  for (ir in InterRows2) {
                    if (any(grepl("rowcolor", tbl2[ir])))
                      tbl2[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl2[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          )
                    tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                    tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                    tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                  }
                  clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                  # file path to saved table
                  pathtosavedtable1 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]), 
                    AgeCutoff = paste0("Older", (10:12)[s], "NonMuslim"),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 1)
                    )
                  pathtosavedtable2 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]), 
                    AgeCutoff = paste0("Older", (10:12)[s], "NonMuslim"),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 2)
                    )
                  write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable1, "\n")
                  cat("Table saved as", pathtosavedtable2, "\n")
                } else {
                  # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                  iispace <- which(
                    # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                    grepl(".", tbest[[1]]) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                    )
                  iispace2 <- iispace[seq(2, length(iispace), 2)]
                  # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                  # adjlskiprows = c(iispace, iispace+1)
                  # saveEstTable is in functions.R
                  # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                  tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest[[1]]),
                    hleft = "\\hfil\\tiny$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.5ex", 
                    adjlskiprows = c(iispace, iispace+1),
                    alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                    alternatecolorManualColor = "gray80")
                  if (grepl("Liang", cl))
                    tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                      estimationspacelast = grep("thana dummi", tbest[[1]]),
                      hleft = "\\hfil\\tiny$", hright = "$", 
                      hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                      delimiterline = NULL, adjustlineskip = "-0.5ex", 
                      adjlskiprows = c(iispace),
                      alternatecolorManual = c(iispace2, iispace2+1),
                      alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows <- grep("nteract.*\\d", tbl)
                  for (ir in InterRows)
                    if (any(grepl("rowcolor", tbl[ir])))
                      tbl[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          ) else
                        # rows without rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          )
                  pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]), 
                    AgeCutoff = paste0("Older", (10:12)[s], "NonMuslim"),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                  write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable, "\n")
                } # if end: DivInto2Tables
              } # cl: SE clustering option
            }  # m: ag HH definitions
          } # ge: gendered or both gender
        }  # j: z2 (incl. extended) or z3 (nuclear)
      }  # s: lowerbound age cutoffs (10, 11, 12)
    }  # dd: demeaned/level interaction
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
# https://cran.r-project.org/web/packages/qs/vignettes/vignette.html
library(qs)
qsave(results, paste0(pathsaveThisVer, "FD_NonMuslimGenderCRCoV_results.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "FD_N_NonMuslimGenderCRCoV_results.qs"))
Enr.NonMuslim <- data.table(Enr.NonMuslim)
Enrchg.NonMuslim <- data.table(Enrchg.NonMuslim)
setnames(Enrchg.NonMuslim, c("sample", "group", "HHtype", "agdef", "demean", "gender", "agelb", 
  "AgNonag", "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(Enr.NonMuslim, c("sample", "HHtype", "agdef", "demean", "gender", "agelb", 
  "agHH", "nonmuslim", "tee", "rate", "Obs"))
qsave(Enr.NonMuslim, paste0(pathsaveThisVer, "Enr.NonMuslimGender.qs"))
qsave(Enrchg.NonMuslim, paste0(pathsaveThisVer, "Enrchg.NonMuslimGender.qs"))
muslimftnote <- "A first-difference estimator with standard errors clustered at \\textit{thana} level. Non-Muslim dummy variable is interacted with year 2002 dummy and year 2002 * agricultural HH dummy. "
@




\subsubsection{Flooded areas estimation}

<<>>=
thanas <- as.character(lapply(unique(yzw[, thana]), function(x) 
  paste0(toupper(substring(x, 1, 1)), substring(x, 2, 30))))
thanas <- thanas[!grepl("NA", thanas)]
@

Flooded area is defined at thana level. These are \Sexpr{thanas[!grepl("Aailjhar|Chokoria|Kalia|Nilphamary|Mohadebpur", thanas)]}. 
<<flooded gender, eval = F, results = 'hide', message = F, warning = F, cache = F>>=
library(clubSandwich)
library(fwildclusterboot)
clusterlevel <- "thana"
DivInto2Tables <- T
regressors.list <- list(
  main = regressorsF,
  placebo = regressorsF2002
)
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zSm.1999 <- readRDS(paste0(pathsaveThisVer, "zSm1999.rds"))
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zSp.1999 <- readRDS(paste0(pathsaveThisVer, "zSp1999.rds"))
zSp.2002 <- readRDS(paste0(pathsaveThisVer, "zSp2002.rds"))
zYp.1999 <- readRDS(paste0(pathsaveThisVer, "zYp1999.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
zEp.1999[, AgeIn2002 := Age[survey == 2002], by = uniquid]
regsnd <- rep("schoolp", length(regressorsF))
samples <- c("main", "placebo")
z23 <- c("z2", "z3")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")[1]
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999")[c(1, 3)]
cohort.years.list <- list(# year age is defined
  main = rep(1999, 4), # main: use 1999 age to set age range
  placebo = c(rep(2002, 2), rep(1999, 2))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
InterYearsList <- list(# year age is defined
  main = rep(2002, 4), # main: use 1999 age to set age range
  placebo = c(rep(2006, 2), rep(2002, 2))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
variables.always.use <- "schoolp|Enrolled|^agHH.yr2|^agHH$|^thana$|uniqu|tee|^flooded$"
yrXs <- c("yr2", "yr3")
flood.reorder.JHR = c("^.Inter|^age$|age2|yield|^(any)?prog|rain|^high|^low|Std|",
    "^agHH$|^agHH.yr\\d$|^hdagHH.yr\\d$|",
    "fl.*d.y|fl.*H.*\\d$|^sex.yr\\d$|^...e.*y.yr\\d$|hd.?sex.yr\\d$|Sib..yr.$|^pcland.y|^pcnlasset.y|water.yr|latrine.yr|",
    "^sex.*H.*\\d$|hd.ed.*H.*\\d$|hd.?sex.*H.*\\d$|Sib.*H.*yr.$|^pcland.*H.*\\d$|^pcnlasset..*H.*\\d$|water.*H.yr|latrine.*H.yr")
flood.reorder.JHR <- paste(flood.reorder.JHR, collapse = "")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = flood.reorder.JHR
  , placebo = flood.reorder.JHR
)
boxWidth <- 4
centerWidth <- 1.3
Enr.Flood <- Enrchg.Flood <- NULL
table(zEm.1999[, .(aghh = agHH0>0, flooded)])
zFLobj <- c("zEm.1999", "zSm.1999")[1]
var.always.use <- variables.always.use
cohort.years <- c(1999, 1999)
cutout.year <- cutout.years[1]
InterYears <- InterYearsList[[1]]
reorder <- reorder.list[[1]]
results <- resultsN <- vector("list", length = length(samples))
SkipLowerBound <- 50
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  regressorsS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  InterYears <- InterYearsList[[ii]]
  yrX <- yrXs[ii]
  var.always.use <- gsub("yr2", yrX, variables.always.use)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("schoolp", length(regressorsS))
  est <- res <- vector("list", length = length(regressorsS)) # k, specification
  res <- list("LiangZeger" = res, "Satterthwaite" = res, "WildClusterBoot" = res) # cl, clustering correction choice
  res <- list(res, res, res, res) # m, agHH definition
  names(res) <- aghh.defs
  res <- list(boys = res, girls = res, "boys+girls" = res) # ge, gender
  res <- list("extended" = res, "nuclear" = res, "exonly" = res) # j, nuclear, extended, extended only HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  res <- list(demeaned = res, undemeaned = res) # dd, demeaned/level interactions
  # res[[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] is same for each jj in zSobj: An element of results0[[jj]]
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  names(results0) <- names(resultsN0) <- zSobj
  for (jj in 1:length(zSobj)) {
    resultsN0[[jj]] <- results0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z01 <- changehyphen(get(zSobj[jj]))
    for (dd in 1:2) {
      z1 = copy(z01)
      if (dd == 2) {
        ## Restore undemeaned interactions: Start 
        # 1. Drop demeaned interactions
        iiyr <- grepout("\\.yr", colnames(z1))
        iiyr <- gsub("\\.yr.", "", iiyr)
        iiyr <- unique(gsub("\\...agHH|\\.agHH0", "", iiyr))
        # interactions
        iiyrX <- paste0(iiyr, ".", yrX)
        iiagHHyrX <- 
          paste0(rep(iiyr, each = length(aghh.defs)), ".", rep(aghh.defs, length(iiyr)), ".", yrX)
        # drop demeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NULL]
        # 2. Form undemeaned interactions
        z1[, (c(iiyrX, iiagHHyrX)) := NA]
        z1[, (yrX) := as.integer(1:.N-1), by = uniquid]
        # restore demeaned agHH def terms as binary variables
        for (mm in aghh.defs) {
          set(z1, i = which(z1[[mm]] > 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 1L)
          set(z1, i = which(z1[[mm]] <= 0), j = grep(paste0("^", mm, "$"), colnames(z1)), value = 0L)
        }
        # restore demeaned covariates: copy from corresponding UDX (undemeaned X)
        for (kk in iiyr)
          set(z1, j = grep(kk, colnames(z1)), value = z1[[paste0("UD", kk)]])
        # form level interactions
        # X.yrx
        for (i in 1:length(iiyr))
          set(z1, j = grep(paste0("^", iiyrX[i]), colnames(z1)), value = z1[[iiyr[i]]]*z1[[yrX]])
        # X.agHH.yrx
        for (kk in iiyr)
          for (mm in aghh.defs)
            set(z1, j = grep(paste0("^", kk, ".", mm, ".", yrX),  colnames(z1)), 
              value = z1[[kk]]*z1[[mm]]*z1[[yrX]])
        ## Restore undemeaned interactions: End 
      } # end: if dd == 2
      z1[, grepout("dummy[A-Z].*HH0?.yr.$", colnames(z1)) := NULL]
      tabextend <- c("yes", "", "yes", "")
      tabcohortdemeaned <- c("", "yes", "", "yes")
      # keep UDOldSib, UDhdsex, UDnonmuslim, UDflooded as undemeaned levels
      setnames(z1, 
        grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1)),
        gsub("UD", "ud", grepout("UDOldSib|UDhds|UDnon|UDfl", colnames(z1))))
      z1[, grepout("^UD", colnames(z1)) := NULL]
      setnames(z1, 
        grepout("^ud", colnames(z1)),
        gsub("ud", "UD", grepout("^ud", colnames(z1))))
      if (ii == 2 & jj == 5) smax <- 1 else smax <- 3
      for (s in 1:smax)
      {
      #  choice of age cutoff
        s0 <- (10:12)[s]
        if (ii == 2 & jj == 5) {
          s0 <- 6
          MaxAge <- 9
        } else {
          MaxAge <- 18
        }
        i <- paste0("older", s0)
        # latter panel: s <= age < maxAge in 1999/2002
        iiid <- unique(z1[
          s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
          eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= MaxAge 
          #maxAge
          , uniquid])
        # Keep only former complete panel and respective years.
        z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
        z2[, grepout("exist|In", colnames(z2)) := NULL]
        z2 <- dropunbalanced(z2, returnDT = T)
        # z3: nuclear family
        z3 <- z2[sd == 1, ]
        z3 <- dropunbalanced(z3, returnDT = T)
        z4 <- z2[sd != 1, ]
        z4 <- dropunbalanced(z4, returnDT = T)
        cat("\n\nage cutoff:", i, "\n\n")
        print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
        cat("dimension of original z1:", dim(z1), "\n")
        cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
        dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
        cat("dimension of z2 after keeping only balanced portion:", 
        dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
        cat("number of individuals in the panel:")
        print(table(table(z2[, uniquid])))
        cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
        cat("first-diffference estimator\n")
        for (j in 1:length(z23))
        {
          zz00 = copy(get(z23[j]))
          setkey(zz00, uniquid, survey)
          zz00[, survey := NULL]
          for (ge in 1:3)
          {
            if (ge == 1) {
              zz0 = copy(zz00[sex <= 0, ]) 
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else  if (ge == 2){
              zz0 = copy(zz00[sex > 0, ])
              zz0[, grepout("^sex", colnames(zz0)) := NULL]
            } else zz0 = copy(zz00)
            if (nrow(zz0) < SkipLowerBound) {
              cat("Skipped due to small number of obs:", nrow(zz0), "\n")
              next
            }
            for (m in 1:length(aghh.defs))
            {
              zz = copy(zz0)
              # Use a particular agHH definition.
              # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
              setnames(zz, 
                grepout(aghh.defs[m], colnames(zz))
                ,
                gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
              )
              # drop other ag HH definition
              zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
              zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
              ns <- NULL
              resul <- est <- vector("list", length = length(regressorsS))
              # First run: Estimation loop for getting N (number of obs) and first-differenced data.
              for (k in 1:length(regressorsS))
              {
                if (s0 == 10 & j == 1 & m == 1) {
                  cat(paste0("(", k, ")\n"))
                  print0(paste0("+ ", 
                    grepout(paste(regressorsS[k], sep = "", collapse = "|"), colnames(zz))))
                }
                regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                # pick covariates for k-th regression: 
                #  paste " ..|.." & "..|.." with collapse = "|"
                #  then use it in grepout
                covariates <- grepout(
                  paste(var.always.use, regrsr, sep = "|", collapse = "|")
                  , colnames(zz))
                # if (ii == 2 & jj == 1)
                #if (grepl("zEp.2|zSp", zSobj[jj]))
                # zEp.2002: UDOldSibF is all 0, UDOldSibM is all 0 but 2 obs, so drop them (and interactions).
                #  covariates <- covariates[!grepl("OldSib", covariates)]
                covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)] # drop real valued level variables
                zr <- zz[, covariates, with = F]
                # source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                rs <- DID1(data.frame(zr), regressand = regsnd[k], 
                   clusterstring = clusterlevel, group = "^uniquid$", 
                   NotToBeDifferenced = "^agHH$|^UD|^pc.*[dt]$",
                   intercept = T, 
                   TimeVariant = "program|age2|meanY",
                   PeriodToDropForLC = 2, 
                   opposite.time.order = F, # Use t - (t-1) diff
                   TurnFactorToNumeric = T, returnV = T, print.messages = F)
                resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff, est = rs$est)
                est[[k]] <- round(rs$est[, -3], 5)
                ns <- c(ns, rs$N)
              }
              if (!any(grepl("latrine.agHH.yr|water.agHH.yr", rownames(est[[k]])))) {
                cat(zSobj[jj], "agelb", s0, z234[j], c("boys", "girls", "boys+girls")[ge], 
                  c("demeaned", "undemeaned")[dd], aghh.defs[m], "\n")
                cat("Skipped, some covariates cannot be used due to too small number of obs:", nrow(zr), "\n\n")
                next
              }
              # resultsN0: raw results (not under same obs)
              resultsN0[[jj]][[dd]][[s]][[j]][[ge]][[m]] <- resul
              # First run estimation data is stored in resul.
              # Pick the last item of data list which has the least num of obs. 
              # (This is data to use for all specifications.)
              # zidd: Differenced data of the last item in resul.
              # zid2: Level data to reconstruct and demean interaction terms of covariates.
              if (dd == 1) 
                # Reconstruct covariates and take demeaned interactions are done in the file below.
                source(paste0(pathprogram0, "ReconstructCovariatesForDemeanedInteractions.tex")) else {
                zidd <- lapply(resul, "[[", "diff.data")
                zidd <- zidd[[length(zidd)]]
                zid = copy(z2[uniquid %in% zidd[, uniquid], ])
                # drop other agHH defs and their interactions
                if (length(iiothag <- 
                  grep(paste0(gsub("\\\\\\.", "", aghh.defs.regexpr[-m]), collapse = "|"), colnames(zid))) > 0)
                  zid[, (iiothag) := NULL]
                # change agHH def name to "agHH"
                setnames(zid, 
                  grepout(aghh.defs[m], colnames(zid))
                  ,
                  gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zid)))
                )
                zid[, Enrolled := schoolp]
              }
              zidd[, tee := 1]
              zidd[, flooded := as.numeric(eval(parse(text=paste0("flooded.", yrX, ">0"))))]
              enrr <- zid[, .(EnRate = mean(Enrolled), Num = .N), by = .(agHH, flooded, tee)]
              Enr.Flood <- rbind(Enr.Flood, 
                cbind(zFLobj[jj], c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], s0, enrr),
                use.names = F
              )
              # Save mean enrollment rate changes
              # x: agHH, y: nonagHH
              if (length(zidd[flooded > 0 & agHH == 0, LHS]) > 1 & 
                length(zidd[flooded > 0 & agHH == 1, LHS]) > 1) {
                ttestE <- t.test(zidd[flooded > 0 & agHH == 1, LHS], zidd[flooded > 0 & agHH == 0, LHS])
                enrch <- t(c(zFLobj[jj], group= "flooded",
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], s0,
                    # DID, diff.x, diff.y, CIlower, CIupper, p value
                  round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                  unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
              } else 
                enrch <- t(c(zFLobj[jj], group= "flooded",
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], s0,
                    # DID, diff.x, diff.y, CIlower, CIupper, p value
                  rep(NA, 6)))
              enrch <- data.table(enrch)
              Enrchg.Flood <- rbind(Enrchg.Flood, enrch, use.names = F)
              if (length(zidd[flooded <= 0 & agHH == 0, LHS]) > 1 & 
                length(zidd[flooded <= 0 & agHH == 1, LHS]) > 1) {
                ttestE <- t.test(zidd[flooded <= 0 & agHH == 1, LHS], zidd[flooded <= 0 & agHH == 0, LHS])
                enrch <- t(c(zFLobj[jj], group= "unflooded",
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], s0,
                    # DID, diff.x, diff.y, CIlower, CIupper, p value
                  rep(NA, 6)))
              } else
                enrch <- t(c(zFLobj[jj], group= "unflooded", 
                  c("all", "direct", "exonly")[j], c("default", aghh.defs[-1])[m],
                  c("demeaned", "undemeaned")[dd], c("boys", "girls", "boys+girls")[ge], s0,
                  round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
                  unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
              enrch <- data.table(enrch)
              Enrchg.Flood <- rbind(Enrchg.Flood, enrch, use.names = F)
              if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "Enrolled")
              #for (cl in c("LiangZeger", "satterthwaite", "wildclusterboot")) 
              for (cl in c("LiangZeger", "satterthwaite")) 
              {
                Rs <- ns <- NULL
                est <- vector("list", length(regressorsS))
                UseSmallClusterCorrection <- cl
                cat("\n\n###", cl, "###\n\n")
                #if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl) & any(grepl("Sib", colnames(zidd)))) {
                if (grepl("Yp|S", zSobj[jj]) & grepl("wild", cl)) {
                  cat("fwildclusterboot fails in Julia for zSm.1999, zYp.1999 because Sib", 
                    "covariates are near zero. Skip to next.\n\n" )
                  next
                }
                for (k in 1:length(regressorsS))
                {
                  # Julia fails for specification 6 in zEm.1999, zEp.1999, zEp.2002
                  if (grepl("wild", cl) & k == 6) next
                  #if (ii == 1 & grepl("S", zSobj[jj]) & s >= 1 & m == 4 & k >= 5 & grepl("wild", cl)) 
                  #zSm1999FDOlder10Occ
                  #  next
                  regrsr <- paste(regressorsS[1:k], sep = "", collapse = "|")
                  covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
                    colnames(zidd))
                  # var.always.use has level variables used only for destat purpose, so drop them
                  covariates <- covariates[!grepl("^UD|^pc.*[dt]$", covariates)]
                  # Commented out: Aug 2, 2023 Start
                  #if (grepl("zEp|zSp", zSobj[jj]))
                  #  covariates <- covariates[!grepl("OldSib", covariates)]
                  # Commented out: Aug 2, 2023 End
                  zr <- zidd[, c(covariates, "tee"), with = F]
                  source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
                  rsl <- DID2(dX0 = zr, Regressand = "Enrolled", 
                           Group = "^uniquid$", TimeVar = "tee", Cluster = "thana", 
                           TimeVariant = "program|age2|meanY|yield",
                           opposite.time.order = F, Exclude = "^agHH$", intercept = T, 
                           SmallClusterCorrection = UseSmallClusterCorrection,
                           WCBType = "webb",
                           return.V = T, print.messages = T)
                  if (grepl("satter", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for clubSandwich outputs
                    rsl$est <- as.data.frame(rsl$est)
                    rsl$est <- rsl$est[, -1]
                    colnames(rsl$est)[c(1:2, 4:5)] <- c("Estimate", "Std. Error", "Satt. DoF", "Pr(>|t|)")
                  } else if (grepl("wild", UseSmallClusterCorrection)) {
                    # Correct format of estimation results for wildclusterboot outputs
                    rsl$est <- as.data.frame(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  } else {
                    # Correct format of estimation results for Liang-Zeger outputs
                    rsl$est <- as.matrix(rsl$est)
                    colnames(rsl$est)[c(1:2, 4)] <- c("Estimate", "Std. Error", "Pr(>|t|)")
                  }
                  # results0: results under same obs
                  clnum <- 1
                  if (cl == "satterthwaite") clnum <- 2 else if (cl == "wildclusterboot") clnum <- 3
                  results0[[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]] <- 
                    list(est = rsl$est, ci = rsl$CI,
                      df = rsl$reg$df, reg = rsl$reg,
                      #level.data = leveldata[, gsub("Enrolled", "LHS", covariates), with = F], 
                      level.data = zid, 
                      diff.data = rsl$data)
                  est[[k]] <- round(rsl$est[, -3], 5)
                  # Sign reversion is done before DID2. Below is redundant.
                  # Take19992002Diff is set to F in "read data chunk" at the beginning
                  # If (t-1) - t difference (opposite time order), signs of yrX cross terms are inverted.
                  #if (Take19992002Diff) est[[k]][grepout("Inter|yr.$", rownames(est[[k]])), c(1, 3)] <- 
                  #  -1 * est[[k]][grepout("Inter|yr.$", rownames(est[[k]])), c(1, 3)]
                  Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
                  ns <- c(ns, rsl$N)
                } # k: reg specification
                assign(paste0("addthis", j),
                   rbind("\\hspace{.5em}thana dummies" = 
                      paste0("\\mbox{", c(rep("", length(regressorsS)-1), rep("yes", 1)), "}"),
                     "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
                     "n" = ns,
                     "control mean in 1999, unflooded" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0 & flooded == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "control mean in 1999, flooded" = 
                       rep(formatC(enrr[tee == 1 & agHH == 0 & flooded == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "treated mean in 1999, unflooded" =
                       rep(formatC(enrr[tee == 1 & agHH == 1 & flooded == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "treated mean in 1999, flooded" =
                       rep(formatC(enrr[tee == 1 & agHH == 1 & flooded == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "change in control mean, unflooded" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 0 & flooded == 0, EnRate]-
                         enrr[tee == 1 & agHH == 0 & flooded == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "change in control mean, flooded" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 0 & flooded == 1, EnRate]-
                         enrr[tee == 1 & agHH == 0 & flooded == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "change in treated mean, unflooded" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 1 & flooded == 0, EnRate]-
                         enrr[tee == 1 & agHH == 1 & flooded == 0, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "change in treated mean, flooded" = 
                       rep(formatC(
                         enrr[tee == 2 & agHH == 1 & flooded == 1, EnRate]-
                         enrr[tee == 1 & agHH == 1 & flooded == 1, EnRate], 
                         digits = 3, format = "f"), length(regressorsS)),
                     "raw DID, unflooded" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1 & flooded == 0, EnRate] - 
                       enrr[tee == 1 & agHH == 1 & flooded == 0, EnRate] 
                       -(enrr[tee == 2 & agHH == 0 & flooded == 0, EnRate] - 
                         enrr[tee == 1 & agHH == 0 & flooded == 0, EnRate]), 
                         digits = 3, format = "f"), length(regressorsS)),
                     "raw DID, flooded" =
                       rep(formatC(
                       enrr[tee == 2 & agHH == 1 & flooded == 1, EnRate] - 
                       enrr[tee == 1 & agHH == 1 & flooded == 1, EnRate] 
                       -(enrr[tee == 2 & agHH == 0 & flooded == 1, EnRate] - 
                         enrr[tee == 1 & agHH == 0 & flooded == 1, EnRate]), 
                         digits = 3, format = "f"), length(regressorsS))
                   )
                )
                INformat <- "LZ"
                OUTformat <- "ep"
                if (cl == "wildclusterboot") {
                  INformat <- "wcb"
                  OUTformat <- "epc"
                } else if (cl == "satterthwaite") {
                  INformat <- "satt"
                  OUTformat <- "epc"
                  OUTformat <- "esDoF"
                }
                # Incorporate CI/DoF in table
                # reorder needs to be corrected
                # Tab.Est is in tabulate_est.R
                # source(paste0(pathprogram, "tabulate_est.R"))
                tbest <- Tab.Est(est, reorder, output.in.list = T,
                  Informat = INformat, Outformat = OUTformat, 
                  AddStars = T, 
                  CIInTinySize = T, 
                  LastLineVariables = c("lowMeanY$", "kut.*e.yr.$"),
                  InterWithTexts = paste0(InterYears[jj], c("", "*agricultural household")),
                  DeleteRowStrings = "^p\\$|^se\\$|^CI\\$|^DoF\\$",
                  addbottom = get(paste0("addthis", j)), subst.table = sbt)
                  # Split a table in to 2 tables
                if (DivInto2Tables) {
                  # Split a table in to 2 tables
                  if (grepl("e[ps]$", OUTformat)) 
                    NumRowsAfterEst <- 2 else 
                    NumRowsAfterEst <- 3
                  tbest11 <- tbest[[1]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst)]
                  tbest12 <- tbest[[2]][1:(grep("inter.*200..*ag", tbest[[1]])-NumRowsAfterEst), ]
                  tbest21 <- tbest[[1]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]])]
                  tbest22 <- tbest[[2]][grep("inter.*200..*ag", tbest[[1]]):length(tbest[[1]]), ]
                  iispace11 <- which(
                    grepl(".", tbest11) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest11)
                    )
                  iispace12 <- iispace11[seq(2, length(iispace11), 2)]
                  iispace21 <- which(
                    grepl(".", tbest21) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest21)
                    )
                  # drop last rows of tbest2 to shrink row space
                  iispace21 <- iispace21[iispace21 < max(grep("toilet|water|nonla", tbest21))]
                  iispace22 <- iispace21[seq(2, length(iispace21), 2)]
                  if (grepl("e[ps]$", OUTformat)) {
                  # ep, es: 2 rows per estimate
                    AdjustLineSkipRows1 <- iispace11
                    AltColorRows1 <- c(iispace12, iispace12+1)
                    AdjustLineSkipRows2 <- iispace21
                    AltColorRows2 <- c(iispace22, iispace22+1)
                  } else {
                  # epc, esc, satt: 3 rows per estimate
                    AdjustLineSkipRows1 <- c(iispace11, iispace11+1)
                    AltColorRows1 <- c(iispace12, iispace12+1, iispace12+2)
                    AdjustLineSkipRows2 <- c(iispace21, iispace21+1)
                    AltColorRows2 <- c(iispace22, iispace22+1, iispace22+2)
                  }
                 #source("c:/seiro/settings/Rsetting/functions.R")
                  tbl1 <- saveEstTable(tbest12, tbest11, boxWidth, 
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows1,
                    alternatecolorManual = AltColorRows1,
                    alternatecolorManualColor = "gray80")
                  tbl2 <- saveEstTable(tbest22, tbest21, boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest21),
                    hleft = "\\hfil\\scriptsize$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.7ex", 
                    adjlskiprows = AdjustLineSkipRows2,
                    alternatecolorManual = AltColorRows2,
                    alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows1 <- grep("nteract.*\\d", tbl1)
                  InterRows2 <- grep("nteract.*\\d", tbl2)
                  for (ir in InterRows1) {
                    if (any(grepl("rowcolor", tbl1[ir])))
                      tbl1[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl1[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl1[ir]))
                          )
                          )
                    # \multicolumn{5}{l}{\makebox[Xcm]{inter with A}} \\\rowcolor{}
                    # => \multicolumn{5}{l}{\makebox[10cm]{\textit{inter with A}\hfill}}\\[.5ex]\rowcolor{}
                    tbl1[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl1[ir])
                    tbl1[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl1[ir])
                    tbl1[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl1[ir])
                  }
                  for (ir in InterRows2) {
                    if (any(grepl("rowcolor", tbl2[ir])))
                      tbl2[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # For rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          ) else
                        # For rows without rowcolor command at the end
                      tbl2[ir] <- 
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          #gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl2[ir]))
                          )
                          )
                    tbl2[ir] <- gsub("makebox\\[.cm\\]", "makebox[10cm]", tbl2[ir])
                    tbl2[ir] <- gsub("(\\\\textit\\{.*?\\})", "\\1\\\\hfill", tbl2[ir])
                    tbl2[ir] <- gsub("\\\\rowcolor", "[.5ex]\\\\rowcolor", tbl2[ir])
                  }
                  clCap <- paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100))
                  # file path to saved table
                  pathtosavedtable1 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]), 
                    AgeCutoff = paste0("Older", (10:12)[s], "Flood"),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 1)
                    )
                  pathtosavedtable2 <- TabFilePathF(
                    FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]), 
                    AgeCutoff = paste0("Older", (10:12)[s], "Flood"),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(clCap, 2)
                    )
                  write.tablev(tbl1, pathtosavedtable1, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  write.tablev(tbl2, pathtosavedtable2, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable1, "\n")
                  cat("Table saved as", pathtosavedtable2, "\n")
                } else {
                  # iispace2, iispace2+1, iispace2+2: (group of) rows to be coloured
                  iispace <- which(
                    # rows with \hspace{.5em} and "non-estimate" rows (R2, n, ...)
                    grepl(".", tbest[[1]]) & 
                    !grepl("interaction with|^n$|bar.R|thana dum|mean at|raw DID", tbest[[1]])
                    )
                  iispace2 <- iispace[seq(2, length(iispace), 2)]
                  # iispace, iispace+1: rows i to shrink rowspace between row i+1 to group together
                  # adjlskiprows = c(iispace, iispace+1)
                  # saveEstTable is in functions.R
                  # source("C:/seiro/settings/Rsetting/functions.R", echo=F)
                  tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                    estimationspacelast = grep("thana dummi", tbest[[1]]),
                    hleft = "\\hfil\\tiny$", hright = "$", 
                    hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                    delimiterline = NULL, adjustlineskip = "-0.5ex", 
                    adjlskiprows = c(iispace, iispace+1),
                    alternatecolorManual = c(iispace2, iispace2+1, iispace2+2),
                    alternatecolorManualColor = "gray80")
                  if (grepl("Liang", cl))
                    tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
                      estimationspacelast = grep("thana dummi", tbest[[1]]),
                      hleft = "\\hfil\\tiny$", hright = "$", 
                      hcenter = c(boxWidth, rep(centerWidth+.15, ncol(tbest[[2]]))), 
                      delimiterline = NULL, adjustlineskip = "-0.5ex", 
                      adjlskiprows = c(iispace),
                      alternatecolorManual = c(iispace2, iispace2+1),
                      alternatecolorManualColor = "gray80")
                  # Modify "interaction with ..." lines to use multicolumn
                  InterRows <- grep("nteract.*\\d", tbl)
                  for (ir in InterRows)
                    if (any(grepl("rowcolor", tbl[ir])))
                      tbl[ir] <- 
                        # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                        # rows with rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          ) else
                        # rows without rowcolor command at the end
                        paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                          gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                          gsub("\\\\hfill", "}", gsub("\\&", "", tbl[ir]))
                          )
                          )
                  pathtosavedtable <- TabFilePathF(FolderPath = pathsaveThisVer, 
                    Sample = paste0(gsub("\\.", "", zSobj[jj]), 
                      c("", "Undemeaned")[dd]), 
                    AgeCutoff = paste0("Older", (10:12)[s], "Flood"),
                    HHType = paste0(c("Boys", "Girls", "")[ge],
                      c("", "Nuclear", "ExOnly")[j]),
                    AgHHDef = c("", "Is", "Hd", "Occ")[m],
                    CRSEMethod = paste0(toupper(substr(cl, 1, 1)), substr(cl, 2, 100)))
                  write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
                  cat("Table saved as", pathtosavedtable, "\n")
                } # if end: DivInto2Tables
              } # cl: SE clustering option
            }  # m: ag HH definitions
          } # ge: gendered or both gender
        }  # j: z2 (incl. extended) or z3 (nuclear)
      }  # s: lowerbound age cutoffs (10, 11, 12)
    }  # dd: demeaned/level interaction
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs with BRL (satterthwaith dof) information
# resultsN: Results under varying number of obs between specifications
Enr.Flood <- data.table(Enr.Flood)
Enrchg.Flood <- data.table(Enrchg.Flood)
setnames(Enrchg.Flood, c("sample", "group", "HHtype", "agdef", "demean", "gender", "agelb",
  "AgNonag", "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(Enr.Flood, c("sample", "HHtype", "agdef", "demean", "gender", "agelb", "agHH", 
  "flood", "tee", "rate", "Obs"))
library(qs)
qsave(results, paste0(pathsaveThisVer, "FD_FloodGenderCRCoV_results.qs"))
qsave(resultsN, paste0(pathsaveThisVer, "FD_N_FloodGenderCRCoV_results.qs"))
qsave(Enr.Flood, paste0(pathsaveThisVer, "Enr.FloodGender.qs"))
qsave(Enrchg.Flood, paste0(pathsaveThisVer, "Enrchg.FloodGender.qs"))
floodftnote <- "A first-difference estimator with standard errors clustered at \\textit{thana} level. Flood dummy variable is interacted with year 2002 dummy and year 2002 * agricultural HH dummy. "
@




<<tabulate flooded nonmuslim results, eval = F>>=
# Flooded: results[[ii]][[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]]
resultsF <- qread(paste0(pathsaveThisVer, "FD_FloodGenderCRCoV_results.qs"))
#resultsFN <- qread(paste0(pathsaveThisVer, "FD_N_NonFloodGenderCRCoV_results.qs"))
# Nonmuslims: results[[ii]][[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]][[k]]
resultsM <- qread(paste0(pathsaveThisVer, "FD_NonMuslimGenderCRCoV_results.qs"))
#resultsMN <- qread(paste0(pathsaveThisVer, "FD_N_NonMuslimGenderCRCoV_results.qs"))
zsobj <- c("zmobj", "zpobj")
zmobj <- "zEm.1999"
zpobj <- c("zEp.2002", "zEp.1999")
EstFM <- NR <- Enr <- NULL
for (fm in 1:2) {   # flood or muslim
  for (ii in 1) { # main results only
    zSobj <- get(zsobj[[ii]])
    for (jj in 1:length(zSobj)) {
      thisdata <- zSobj[[jj]]
      for (dd in 1:2) {
        for (s in 1:3) {
          for (j in 1:2) {
            for (ge in 1:3) {
              for (m in 1:4) {
                for (clnum in 1:2) {
                  if (fm == 1)  {
                    estFM1 <- resultsF[[ii]][[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]]
                  } else {
                    estFM1 <- resultsM[[ii]][[jj]][[dd]][[s]][[j]][[ge]][[m]][[clnum]]
                  }
                  if (all(unlist(lapply(estFM1, is.null)))) next
                  estFM <- lapply(estFM1, "[[", "ci")
                  estFM <- lapply(estFM, data.table)
                  estFM <- lapply(1:length(estFM), function(i) estFM[[i]][, reg := i])
                  estFM <- rbindlist(estFM, use.names = T, fill = T)
                  # if clnum == 1, estFM only contain CIs
                  if (clnum == 1) {
                    esp <- lapply(estFM1, "[[", "est")
                    esp <- lapply(esp, as.matrix)
                    esprn <- unlist(lapply(esp, rownames))
                    esp <- lapply(esp, function(x) as.data.table(x[, ]))
                    dfs <- lapply(lapply(estFM1, "[[", "est"), function(x) attributes(x)$df)
                    esp <- lapply(1:length(esp), function(i) esp[[i]][, df := dfs[[i]]])
                    esp <- rbindlist(esp, use.names = T, fill = T)
                    if (any(grepl("z value", colnames(esp)))) esp[, "z value" := NULL]
                    estFM <- cbind(Coef = esprn, esp, estFM)
                    setnames(estFM,  c("Coef", "beta", "SE", "t", "p_val", "df", "CI_L", "CI_U", "reg"))
                    estFM[, t := NULL]
                  }
                  estFM[, p_val := round(p_val, 6)]
                  estFM[, SE := round(SE, 8)]
                  estFM[, inference := c("LZ", "BRL")[clnum]]
                  estFM[, gender := genderitems[ge]]
                  estFM[, agdef := aghh.defs[m]]
                  estFM[, agelb := c(10:12)[s]]
                  estFM[, HHtype := c("all", "direct", "exonly")[j]]
                  estFM[, data := thisdata]
                  estFM[, demean := c("demeaned", "undemeaned")[dd]]
                  estFM[, objective := c("main", "placebo")[ii]]
                  estFM[, file := c("flood", "muslim")[fm]]
                  setcolorder(estFM,  c("file", "objective", "data", "gender", "agdef", "agelb", "HHtype", 
                    "demean", "Coef", "beta", "SE", "df", "p_val", "CI_L", "CI_U", "reg", "inference"))
                  EstFM <- rbindlist(list(EstFM, estFM), use.names = T, fill = T)
                  # n and R2
                  nR <- lapply(lapply(estFM1, "[[", "reg"), 
                    function(x) t(c(length(summary(x)$res), summary(x)$r.sq)))
                  nR <- lapply(nR, data.table)
                  nR <- lapply(1:length(nR), function(i) nR[[i]][, spec := i])
                  nR <- rbindlist(nR, use.names = T, fill = T)
                  nR[, gender := genderitems[ge]]
                  setnames(nR, c("n", "R", "spec", "gender"))
                  nR[, n := formatC(n, digits = 0, format = "f")]
                  nR[, R := formatC(R, digits = 4, format = "f")]
                  # number of agHHs
                  nR2 <- unique(unlist(lapply(lapply(estFM1, "[[", "diff.data"), 
                    function(x) sum(x[, agHH]>0))))
                  if (fm == 1) 
                    nR3 <- unique(unlist(lapply(lapply(estFM1[-1], "[[", "diff.data"), 
                      function(x) sum(x[, paste0("flooded.yr", ii+1), with = F]>0)))) else
                    nR3 <- unique(unlist(lapply(lapply(estFM1[-1], "[[", "diff.data"), 
                      function(x) sum(x[, paste0("nonmuslim.yr", ii+1), with = F]>0))))
                  nR[, Yes := formatC(nR2, digits = 0, format = "f")]
                  nR[, Ngroup := formatC(nR3, digits = 0, format = "f")]
                  nR[, agdef := aghh.defs[m]]
                  nR[, agelb := c(10:12)[s]]
                  nR[, HHtype := c("all", "direct", "exonly")[j]]
                  nR[, data := thisdata]
                  nR[, demean := c("demeaned", "undemeaned")[dd]]
                  nR[, objective := c("main", "placebo")[ii]]
                  nR[, file := c("flood", "muslim")[fm]]
                  NR <- rbind(NR, nR, use.names = T, fill = T)
                  # treated and control means
                  zid <- lapply(estFM1, "[[", "level.data")
                  zidd <- lapply(estFM1, "[[", "diff.data")
                  zid <- lapply(1:length(zid), function(i) zid[[i]][uniquid %in% zidd[[i]][, uniquid], ])
                  zid <- lapply(zid, function(x) x[eval(parse(text=grepout("agHH$", colnames(x)))) > 0, 
                            agHH := 1L])
                  zid <- lapply(zid, function(x) x[eval(parse(text=grepout("agHH$", colnames(x)))) < 0, 
                            agHH := 0L])
                  zid <- lapply(zid, function(x) x[, tee := 1:.N, by = uniquid])
                  if (any(grepl("Enrolled", colnames(zid[[1]]))))
                    lapply(zid, function(x) setnames(x, "Enrolled", "schoolp"))
                  enr <- lapply(zid, function(x) x[, .(EnRate = mean(schoolp), Num = .N), by = .(agHH, tee)])
                  enr <- lapply(1:length(enr), function(i) enr[[i]][, spec := i])
                  enr <- rbindlist(enr, use.names = T, fill = T)
                  enr[, gender := genderitems[ge]]
                  enr[, agdef := aghh.defs[m]]
                  enr <- unique(enr[, spec := NULL])
                  enr[, agelb := c(10:12)[s]]
                  enr[, HHtype := c("all", "direct", "exonly")[j]]
                  enr[, data := thisdata]
                  enr[, demean := c("demeaned", "undemeaned")[dd]]
                  enr[, objective := c("main", "placebo")[ii]]
                  enr[, inference := c("LZ", "BRL")[clnum]]
                  enr[, file := c("flood", "muslim")[fm]]
                  Enr <- rbind(Enr, enr, use.names = T, fill = T)
                } # clnum
              } # m
            } # ge
          } # j
        } # s
      } # dd
    } # jj
  } # ii
} # fm
setnames(EstFM, "p_val", "p")
EstFM[, coeff := as.character(NA)]
EstFM[grepl("^agHH.yr.$", Coef), coeff := "main"]
EstFM[grepl("SibF.*H", Coef), coeff := "older female siblings"]
EstFM[grepl("SibM.*H", Coef), coeff := "older male siblings"]
EstFM[, coeff := factor(coeff)]
EstFM[, Coef := factor(Coef)]
EstFM[, inference := factor(inference)]
EstFM[, objective := factor(objective)]
EstFM[, data := factor(data)]
EstFM[, agdef := factor(agdef)]
EstFM[, gender := factor(gender, levels = genderitems)]
EstFM[, HHtype := factor(HHtype)]
EstFM[, demean := factor(demean)]
EstFM[, file := factor(file)]
NR[, inference := factor(inference)]
NR[, objective := factor(objective)]
NR[, data := factor(data)]
NR[, agdef := factor(agdef)]
NR[, gender := factor(gender, levels = genderitems)]
NR[, HHtype := factor(HHtype)]
NR[, demean := factor(demean)]
NR[, file := factor(file)]
Enr[, inference := factor(inference)]
Enr[, objective := factor(objective)]
Enr[, data := factor(data)]
Enr[, agdef := factor(agdef)]
Enr[, gender := factor(gender, levels = genderitems)]
Enr[, HHtype := factor(HHtype)]
Enr[, demean := factor(demean)]
Enr[, file := factor(file)]
qsave(EstFM, paste0(pathsaveThisVer, "TabulatedFloodMuslimResults.qs"))
qsave(Enr, paste0(pathsaveThisVer, "TabulatedFloodMuslimResultsEnr.qs"))
qsave(NR, paste0(pathsaveThisVer, "TabulatedFloodMuslimResultsNR.qs"))
floodftnote <- "A first-difference estimator with standard errors clustered at \\textit{thana} level. Flood dummy variable is interacted with year 2002 dummy and year 2002 * agricultural HH dummy. "
@






\subsection{Clustering of standard errors at a lower (village) level}


<<main and placebo cluster at village, eval = F, results = 'hide', cache = F>>=
clusterlevel <- "village"
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zEm.1999[, agHH0 :=  as.numeric(agHH0 > 0)]
zSm.1999 <- readRDS(paste0(pathsaveThisVer, "zSm1999.rds"))
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zSp.1999 <- readRDS(paste0(pathsaveThisVer, "zSp1999.rds"))
zSp.2002 <- readRDS(paste0(pathsaveThisVer, "zSp2002.rds"))
zYp.1999 <- readRDS(paste0(pathsaveThisVer, "zYp1999.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
zSp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
samples <- c("main", "placebo")
z23 <- c("z2", "z3")
zsobj <- c("zmobj", "zpobj")
zmobj <- c("zEm.1999", "zSm.1999")
zpobj <- c("zEp.2002", "zSp.2002", "zEp.1999", "zSp.1999")
cohort.years.list <- list(# year age is defined
  main = rep(1999, 4), # main: use 1999 age to set age range
  placebo = c(rep(2002, 2), rep(1999, 2))
  # placebo: use 1999 and 2002 age to set age range
  # placebo: cohorts 10-18 in 1999, 10-18 in 2002 are 
  #   tested for impacts between 2002-2006
  )
cutout.years<- c(2006, 1999) # year to drop in data, main = 2006, placebo 1999
regressors.list <- list(
  main = regressorsM,
  placebo = regressors
)
variables.always.useCV <- "schoolp|Enrolled|^agHH.yr2|^agHH$|^village$|uniqu"
yrXs <- c("yr2", "yr3")
main.reorder = c("^.Inter|^age$|age2|yield|^(any)?prog|Mean|Std|",
    "^agHH.yr2$|^hdagHH.yr2$|",
    "^sex|hd\\.age|hd.e|sp.a|sp.e|sp.sex|land|nla|water|latri|coho")
main.reorder.JHR = c("^.Inter|^age$|age2|yield|^(any)?prog|Mean|Std|",
    "^agHH$|^agHH.yr\\d$|^hdagHH.yr\\d$|",
    "^sex.yr\\d$|^...e.*y.yr\\d$|sp.sex.yr\\d$|^pcland.y|^pcnlasset.y|water|latri|",
    "^sex.*H.*\\d$|hd.e.*H.*\\d$|sp.sex.*H.*\\d$|^pcland.*H.*\\d$|^pcnlasset..*H.*\\d$")
mix.reorder <- function(x, y=main.reorder.JHR) 
  paste0(c(y[1], x, y[3], y[4]), collapse = "")
sub.reorder <- function(x, z, y=main.reorder.JHR) 
  paste0(c(y[1], gsub(x, z, y[2]), y[3], y[4]), collapse = "")
reorder.list <- list(
    main = paste0(main.reorder.JHR, collapse = "")
  , placebo = paste0(main.reorder.JHR, collapse = "")
  , main.agewise = mix.reorder("^agHH$|^agH.*2$|^D.*yA.*agHH.yr2$|^D.*yA.*\\.1\\d\\.yr2$|")
  , main.classwise = mix.reorder("^agHH$|^agH.*2$|^D.*yA.*agHH.yr2$|^D.*yA.*\\.1\\d\\.yr2$|^Du.*Ed.*|")
  , placebo.young = mix.reorder("^agHH$|^agHH.yr3$|^hdagHH.yr3$|")
  , placebo.agewise = mix.reorder("^agHH$|^agH.*3$|^D.*yA.*agHH.yr3$|^D.*yA.*\\.1\\d\\.yr3$|")
)
boxWidth <- 4
centerWidth <- 1.3
EnrCV <- EnrCVchg <- NULL
results <- resultsN <- vector("list", length = length(samples)) # ii
for (ii in 1:length(samples)) {
  zSobj <- get(zsobj[ii])
  regressorS <-  regressors.list[[ii]]
  cohort.years <- cohort.years.list[[ii]]
  cutout.year <- cutout.years[ii]
  var.always.use <- gsub("yr2", yrXs[ii], variables.always.useCV)
  reorder <- reorder.list[[ii]]
  regsnd <- rep("schoolp", length(regressorS))
  est <- res <- vector("list", length = length(regressorS)) # k, specification
  res <- list(m1 = res, m2 = res, m3 = res, m4 = res) # m, agHH definition
  res <- list(z2 = res, z3 = res) # j, nuclear or extended HHs
  res <- list("LB10" = res, "LB11" = res, "LB12" = res) # s, age lowerbound
  results0 <- resultsN0 <- vector("list", length = length(zSobj)) # jj, zE/zS sample selection
  for (jj in 1:length(zSobj)) {
    results0[[jj]] <- resultsN0[[jj]] <- res
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    z1 <- changehyphen(get(zSobj[jj]))
    tabextend <- c("yes", "", "yes", "")
    tabcohortdemeaned <- c("", "yes", "", "yes")
    z1[, village := factor(gsub(" ", "", village))]
    for (s in 1:3)
    #  choice of age cutoff
    {
      s0 <- (10:12)[s]
      i <- paste0("older", s0)
      # latter panel: s <= age < maxAge in 1999/2002
      iiid <- unique(z1[
        s0 <= eval(parse(text = paste0("AgeIn", cohort.years[jj]))) & 
        eval(parse(text = paste0("AgeIn", cohort.years[jj]))) <= 18 
        #maxAge
        , uniquid])
      # Keep only former complete panel and respective years.
      z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
      z2[, grepout("exist|In", colnames(z2)) := NULL]
      z2 <- dropunbalanced(z2, returnDT = T)
      # nuclear family
      z3 <- z2[sd == 1, ]
      z3 <- dropunbalanced(z3, returnDT = T)
      cat("\n\nage cutoff:", i, "\n\n")
      print(table0(z1[, .(survey, agegroup = (uniquid %in% iiid))]))
      cat("dimension of original z1:", dim(z1), "\n")
      cat("dimension of z2 after keeping only", s0, "-", maxAge, "year olds:", 
      dim(z1)[1], "==>", dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "\n")
      cat("dimension of z2 after keeping only balanced portion:", 
      dim(z1[uniquid %in% iiid & survey != cutout.year, ])[1], "==>", dim(z2)[1], "\n")
      cat("number of individuals in the panel:")
      print(table(table(z2[, uniquid])))
      cat("dimension of z3 after keeping only nuclear members:", dim(z3), "\n\n")
      cat("first-diffference estimator\n")
      for (j in 1:length(z23))
      {
        zz0 <- get(z23[j])
        setkey(zz0, uniquid, survey)
        zz0[, survey := NULL]
        for (m in 1:length(aghh.defs))
        {
          zz = copy(zz0)
          # Use a particular agHH definition.
          # change the name of current ag HH (agHH0, isagHH, ocagHH) to "agHH"
          setnames(zz, 
            grepout(aghh.defs[m], colnames(zz))
            ,
            gsub(aghh.defs[m], "agHH", grepout(aghh.defs[m], colnames(zz)))
          )
          # drop other ag HH definition
          zz[, grepout(paste0(aghh.defs.regexpr[-m], collapse = "|"), colnames(zz)) := NULL]
          zz[, grepout(paste0("^", aghh.defs[-m], "$", collapse = "|"), colnames(zz)) := NULL]
          ns <- NULL
          resul <- vector("list", length = length(regressorS))
          # First run: Estimation loop for getting N (number of obs) and first-differenced data.
          for (k in 1:length(regressorS))
          {
            if (s0 == 10 & j == 1 & m == 1) {
              cat(paste0("(", k, ")\n"))
              print0(paste0("+ ", 
                grepout(paste(regressorS[k], sep = "", collapse = "|"), colnames(zz))))
            }
            regrsr <- paste(regressorS[1:k], sep = "", collapse = "|")
            # pick covariates for k-th regression: 
            #  paste " ..|.." & "..|.." with collapse = "|"
            #  then use it in grepout
            covariates <- grepout(
              paste(var.always.use, regrsr, sep = "|", collapse = "|")
              , colnames(zz))
            zr <- zz[, covariates, with = F]
            rs <- DID1(data.frame(zr), regressand = regsnd[k], 
               clusterstring = clusterlevel, group = "^uniquid$", 
               NotToBeDifferenced = "^agHH$",
               intercept = T, 
               TimeVariant = "program|age2|meanY",
               PeriodToDropForLC = 2, 
               # opposite.time.order: set to F to get t-(t-1) difference. 
               # (to be used in DID2 in the later chunk)
               # Under F, diff(LHS) = -1 if schoolp 1 (1999) -> 0 (2002).
               # agHH.yr2 is demeaned interaction (of agHH and yr2=1999 dummies), 
               #   275 of obs (agHH==0) =  .59 because   -.39  (1999)  ->  .20 (2002)
               #   407 of obs (agHH==1) = -.401 because  .266 (1999) -> -.135 (2002)
               # In diff data, ag HH who dropped out: LHS = -1, agHH.yr2 = -.4 => OLS estimate > 0.
               # A larger drop in LHS (more negative) for agHH == 1 dummy 
               # needs agHH.yr2 to be defined as a positive value.
               # Similarly, sex (female) == 1 gives diff(sex.yr2) < 0 for females in t-(t-1) diff. 
               # X.yr2 needs to be defind as positive. To do so, in DID2, 
               # one needs to set opposite.time.order = F & all time variant covariates
               # to be X.yr2 := -1 * X.yr2 [so diff(agHH.yr2) > 0].
               opposite.time.order = F,
               TurnFactorToNumeric = T, returnV = T, print.messages = F)
            resul[[k]] <- list(level.data = rs$level, diff.data = rs$diff)
            #jj: zF, zE, zS
            #s: age cutoff
            #j: nuclear or extended
            #m: agHH def
            #k: specification
            est[[k]] <- round(rs$est[, -3], 5)
            ns <- c(ns, rs$N)
          }
          # resultsN0: raw results (not under same obs)
          resultsN0[[jj]][[s]][[j]][[m]] <- resul
          # First run estimation data is stored in resul.
          # Pick the last item of data list which has the least num of obs. 
          # (This is data to use for all specifications.)
          # zidd: Differenced data of the last item in resul.
          # zid: Level data only to get agHH (because agHH is not included in zidd).
          # Merge zidd with zid to attach agHH to zidd.
          zid <- lapply(resul, "[[", "level.data")
          zid <- leveldata <- zid[[length(zid)]]
          zidd <- lapply(resul, "[[", "diff.data")
          zidd <- zidd[[length(zidd)]]
          # one needs to set opposite.time.order = F & all time variant covariates
          # to be X.yr2 := -1 * X.yr2 [so diff(agHH.yr2) > 0].
          TimeVariant <- grepout("program|age2|meanY|\\.yr\\d$", colnames(zidd))
          zidd[, (TimeVariant) := lapply(.SD, function(x) x * -1), .SDcols = TimeVariant]
          zid <- zid[uniquid %in% zidd[, uniquid], ]
          # Reconstruct agHH (it was demeaned)
          if (is.numeric(zid[,agHH])) {
            zid[eval(parse(text=grepout("agHH$", colnames(zid)))) > 0, 
              agHH := 1L]
            zid[eval(parse(text=grepout("agHH$", colnames(zid)))) <= 0, 
              agHH := 0L]
          }
          zid[, tee := 1:.N, by = uniquid]
          setkey(zid, uniquid, tee)
          zid2 <- unique(zid[, .(uniquid, agHH)])
          # Drop agHH if it is in regression data
          if (any(grepl("^agHH$", colnames(zidd)))) zidd[, agHH := NULL]
          # Merge zid2 (uniquid, agHH) with zidd
          setkey(zid2, uniquid)
          setkey(zidd, uniquid)
          zidd <- zid2[zidd]
          # Save mean enrollment rates
          enrr <- zid[, .(EnRate = round(mean(LHS), 3), Num = .N), by = .(agHH, tee)]
          EnrCV <- rbind(EnrCV, 
            cbind(zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], 
              s0, enrr),
            use.names = F
          )
          # Save mean enrollment rate changes
          # x: agHH, y: nonagHH
          ttestE <- t.test(zidd[agHH == 1, LHS], zidd[agHH == 0, LHS])
          EnrCVchg <- rbind(EnrCVchg, 
            t(c(zSobj[jj], c("all", "nuclear")[j], c("default", aghh.defs[-1])[m], s0, 
              round(-diff(unlist(ttestE["estimate"])), 3), # -diff = -(y - x) = AgHH - nonagHH
              unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4)))),
            use.names = F
          )
          if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "Enrolled")
          zidd[, tee := 1]
          Rs <- ns <- NULL
          est <- vector("list", length(regressorS))
          # Second run: This will be saved as the results.
          for (k in 1:length(regressorS))
          {
            regrsr <- paste(regressorS[1:k], sep = "", collapse = "|")
            covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), 
              colnames(zidd))
            zr <- zidd[, c(covariates, "tee"), with = F]
            source("c:/seiro/settings/Rsetting/panel_estimator_functions.R")
            rsl <- DID2(dX0 = zr, Regressand = "Enrolled", 
                     Group = "^uniquid$", TimeVar = "tee", Cluster = "village", 
                     TimeVariant = "program|age2|meanY|yield",
                     opposite.time.order = F, 
                     Exclude = "^agHH$", intercept = T, return.V = T, print.messages = T)
           # results0: results under same obs
            results0[[jj]][[s]][[j]][[m]][[k]] <- list(est = rsl$est, 
              df = rsl$reg$df, reg = rsl$reg,
              level.data = leveldata, diff.data = rsl$data)
            est[[k]] <- round(rsl$est[, -3], 5)
            if (Take19992002Diff) est[[k]][, 1] <- -1 * est[[k]][, 1]
            Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
            ns <- c(ns, rsl$N)
          }
          assign(paste0("addthis", j),
             rbind("\\hspace{.5em}thana dummies" = 
                paste0("\\mbox{", c(rep("", length(regressorS)-1), rep("yes", 1)), "}"),
               "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
               "n" = ns,
               "control mean at baseline" = 
                 rep(formatC(enrr[tee == 1 & agHH == 0, EnRate], 
                   digits = 2, format = "f"), length(regressorS)),
               "treated mean at baseline" =
                 rep(formatC(enrr[tee == 1 & agHH == 1, EnRate], 
                   digits = 2, format = "f"), length(regressorS))
             )
          )
          #tbest <- tabulate.est(est, reorder, output.in.list = T,
          #  lastLevelVariable = "^r.*Y$|^l.*Y", inter.with = cohort.years[1],
          #  addbottom = get(paste0("addthis", j)), subst.table = sbt)
          tbest <- tabulate.est(est, reorder, output.in.list = T,
            LastLineVariables = c("^r.*Y$|^l.*Y", "latrine.yr.$"),
            InterWithTexts = paste0(cohort.years[jj], c("", "*agricultural household")),
            addbottom = get(paste0("addthis", j)), subst.table = sbt)
          iNum <- paste0(zSobj[jj], "_ClusterVillage", c("", "_nuclear")[j], c("", "_is", "_hd", "_occ")[m])
          tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
            estimationspacelast = grep("thana dummi", tbest[[1]]),
            hleft = "\\hfil\\scriptsize$", hright = "$", 
            hcenter = c(boxWidth, rep(centerWidth, ncol(tbest[[2]]))), 
            delimiterline = NULL, adjustlineskip = "-0.5ex", 
            alternatecolor2 = "gray80")
          # Modify "interaction with ..." lines to use multicolumn
          InterRows <- grep("nteract.*\\d", tbl)
          for (ir in InterRows)
            if (any(grepl("rowcolor", tbl[ir])))
              tbl[ir] <- 
                # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
                # rows with rowcolor command at the end
                paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                  gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir])))
                  ) else
                # rows without rowcolor command at the end
                paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
                  gsub("(\\\\\\\\.*ex.$)", "}\\1", 
                  gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir]))
                  )
                  )
          pathtosavedtable <- paste0(pathsaveThisVer, "FD_", i, "_", iNum, ".tex")
          write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
          cat("Table saved as", pathtosavedtable, "\n")
        }  # m: ag HH definitions
      }  # j: z2 (incl. extended) or z3 (nuclear)
    }  # s: lowerbound age cutoffs (10, 11, 12)
  }  # jj: zE / zS sample selection
  results[[ii]] <- results0
  resultsN[[ii]] <- resultsN0
}  # ii: main / placebo samples
# results: Results under same obs
# resultsN: Results under varying number of obs between specifications
saveRDS(results, paste0(pathsaveThisVer, "FD_sameN_ClusterVillage_results.rds"))
saveRDS(resultsN, paste0(pathsaveThisVer, "FD_N_ClusterVillage_results.rds"))
EnrCV <- data.table(EnrCV)
EnrCVchg <- data.table(EnrCVchg)
setnames(EnrCVchg, c("sample", "HHtype", "agHHdef", "age", "AgNonag", 
  "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(EnrCV, c("sample", "HHtype", "agHHdef", "age", "agHH", "tee", "rate", "Obs"))
clusterlevel <- "district"
@


<<same sample size estimation for agewise cluster at village, eval = F, results = 'hide', warning = F, cache = F>>=
clusterlevel <- "village"
zEm.1999 <- readRDS(paste0(pathsaveThisVer, "zEm1999.rds"))
zSm.1999 <- readRDS(paste0(pathsaveThisVer, "zSm1999.rds"))
zEp.1999 <- readRDS(paste0(pathsaveThisVer, "zEp1999.rds"))
zEp.2002 <- readRDS(paste0(pathsaveThisVer, "zEp2002.rds"))
zYp.1999 <- readRDS(paste0(pathsaveThisVer, "zYp1999.rds"))
zEp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
zSp.1999[, AgeIn1999 := Age[survey == 2002] - 3, by = uniquid]
zf <- unique(zEm.1999[, .(uniquid, AgeGroup1999, Agegroup1999)])
zf[, AgeGroup1999 := droplevels(AgeGroup1999)]
zf[, Agegroup1999 := droplevels(Agegroup1999)]
setkey(zf, uniquid)
ze <- unique(zEm.1999[, .(uniquid, Edu1999)])
ze <- ze[!grepl("other", Edu1999), ]
ze[, Edu1999 := droplevels(Edu1999)]
setkey(ze, uniquid)
# Edu1999 is actual class in 1999 which is not defined for outofschool children.
#    6-10: Primary (primary0103, primary0405)
#  11-13: Junior secondary (secondary 0608)
#  14-15: Secondary (secondary0912)
#  16-17: Higher secondary (secondary0912)
# Supposed school age: Class to be enrolled under official school system schedule
# But this is just another labeling of age.
# In class wise regressions, default category becomes Edu1999 = NA and schoolp = 0.
# This is a group of children who are out of school for long period (so they do not
# provide class information). This is not a natural reference category, 
# so we may drop the class wise estimation.
# We can leave class wise regressions in the code for now.
samples.age <- c("main", "placebo2", "placebo9", "mainC")#, "placeboY")
# data vector names: 
# zA is age wise, 
# AP2 is placebo age wise 2002 cohort
# AP9 is placebo age wise 1999 cohort
# zC is class wise, zY is young cohorts
zsobj <- c("zAobj", "zAP2obj", "zAP9obj", "zCobj", "zYobj")
# Data vector elements. 
# Except for Y, each has 3 elements because there are 3 age groupings.
# zAobj: 1999 shocks on 1999 cohorts (agewise, AgeGroup, Agegroup)
# zAP2obj: 2002 shocks on 2002 cohorts (agewise, AgeGroup, Agegroup)
# zAP9obj: 2002 shocks on 1999 cohorts (agewise, AgeGroup, Agegroup)
# zCobj: 1999 shocks on 1999 class group (classwise)
# zYobj: 2002 shocks on young 1999 cohorts
zAobj <- rep(c("zEm.1999", "zSm.1999"), each = 3)
zAP2obj <- rep("zEp.2002", 3)
zAP9obj <- rep("zEp.1999", 3)
zCobj <- c("zEm.1999", "zSm.1999") 
zYobj <- "zYp.1999"
cohort.yearsAge.list <- list(
    main = 1999
  , placebo2 = 2002
  , placebo9 = 1999
  , mainC = 1999
  , placeboY = 1999
)
# year to drop from data
cutoutAge.years <- c(2006, 1999, 1999, 2006, 1999)
agegroupings1 <- list(
    main = rep(c("agewise", "AgeGroup1", "AgeGroup2"), 2)
  # agewise = (currently) Not age wise. Same as main. 
  # AgeGroup1 = AgeGroup: 6-10, 11-13, 14-15, 16-17, above17
  # AgeGroup2 = Agegroup: 6-10, 11-17, above17
  # mainC: Class wise = Group children by enrolled class in 1999
  # Note: placeboY only have one age group, below 10 in 1999
  , placebo2 = rep(c("agewise", "AgeGroup1", "AgeGroup2"), 2)
  , placebo9 = rep(c("agewise", "AgeGroup1", "AgeGroup2"), 2)
  , mainC = rep("Classwise", 2)
  , placeboY = "YoungCohorts"
)
variables.always.useCV <- "schoolp|Enrolled|^agHH.yr2|^village$|uniqu"
## Age wise agHH.yrX was created in Construct3RoundPanel_JHR.rnw
#  zEm.1999: Main, exist sample.
#  zSm.1999: Main, schooling sample.
#  zEp.1999: Placebo, 2002 shocks on 1999 cohort.
#  zEp.2002: Placebo, 2002 shocks on 2002 cohort.
#  zYp.1999: Placebo, 2002 shocks on young 1999 cohort.
for (zob in c("zEm.1999", "zSm.1999", "zEp.1999", "zEp.2002"){ #, "zYp.1999")) {
  zdata <- get(zob)
  for (agstring in aghh.defs) {
    for (aa in 6:maxAge) {
      if (grepl("m", zob)) # zEm.1999, zSm.1999
      {
        zdata[, dumage := as.numeric(eval(parse(text=paste0("Age==", aa, ""))))]
        zdata[, dumage := dumage - mean(dumage, na.rm = T)]
        zdata[, (paste0("DummyAgeIn1999.", putzeroontop(aa, F, 2), ".yr2")) :=
          eval(parse(text="(survey == 1999)*dumage"))] 
        # agHH.yr2 * dumage
        zdata[, (paste0("DummyAgeIn1999.", putzeroontop(aa, F, 2), ".", agstring, ".yr2")) :=
          eval(parse(text=paste0(agstring, ".yr2*dumage")))] 
      } else if (grepl("p.1", zob)) # zEp.1999, zYp.1999
      {
        zdata[, dumage := as.numeric(eval(parse(text=paste0("Age==", aa, ""))))]
        zdata[, dumage := dumage - mean(dumage, na.rm = T)]
        zdata[, (paste0("DummyAgeIn1999.", putzeroontop(aa, F, 2), ".yr3")) :=
          eval(parse(text="(survey == 2002)*dumage"))] 
        zdata[, (paste0("DummyAgeIn1999.", putzeroontop(aa, F, 2), ".", agstring, ".yr3")) :=
          eval(parse(text=paste0(agstring, ".yr3*dumage")))] 
      } else { # zEp.2002
        zdata[, dumage := as.numeric(eval(parse(text=paste0("Age==", aa, ""))))]
        zdata[, dumage := dumage - mean(dumage, na.rm = T)]
        zdata[, (paste0("DummyAgeIn2002.", putzeroontop(aa, F, 2), ".yr3")) :=
          eval(parse(text="(survey == 2002)*dumage"))] 
        zdata[, (paste0("DummyAgeIn2002.", putzeroontop(aa, F, 2), ".", agstring, ".yr3")) :=
          eval(parse(text=paste0(agstring, ".yr3*dumage")))] 
      }
    }
  }
  assign(zob, zdata)
}
# year to interact with agHH. yr2 is yr1-yr2 diff, yr3 is yr2-yr3 diff.
yrXs <- c("yr2", "yr3", "yr3", "yr2", "yr3")
ShockYears <- c(1999, 2002, 2002, 1999, 2002)
# set reordering strings in estimation table
# mix.reorder is defined in main-placebo estimation chunk
reorderAge.list <- list(
    mainA = mix.reorder("^agH.*2$|^D.*yA.*\\d\\.yr2$|^D.*yA.*agHH.yr2$|")
  , placeboA2 = mix.reorder("^agH.*3$|^D.*yA.*agHH.yr3$|^D.*yA.*\\d\\.yr3$|")
  , placeboA9 = mix.reorder("^agH.*3$|^D.*yA.*agHH.yr3$|^D.*yA.*\\d\\.yr3$|")
  , mainC = mix.reorder("^agH.*2$|^D.*yA.*agHH.yr2$|^D.*yA.*\\.1\\d\\.yr2$|^Du.*Ed.*|")
  , placeboY = mix.reorder("^agHH.yr3$|^hdagHH.yr3$|")
)
# EnrCV.age: enrollment rates by agHH*agegroup*period
# EnrCVchg.age: enrollment rate changes by agHH*agegroup*period
EnrCV.age <- EnrCVchg.age <- NULL
results <- vector("list", length = length(samples.age)) # ii
boxWidth <- 4
centerWidth <- 1.2
for (ii in 1:length(samples.age)) {
  zSobj <- get(zsobj[ii])
  agegroupings <- agegroupings1[[ii]] # agewise, AgeGroup (=AgeGroup1), Agegroup (=AgeGroup2)
  regressorS0 <-  regressorsAge.list[[ii]]
  cohort.years <- cohort.yearsAge.list[[ii]] # tested on cohort 1999 or cohort 2002
  cutout.year <- cutoutAge.years[ii]
  reorder <- reorderAge.list[[ii]]
  yrxYear <- ShockYears[ii] # Supposed shock year: 1999 or 2002
  yrx <- yrXs[ii]  # Supposed shock year in yrY description: yr2 or yr3
  regsnd <- rep("schoolp", length(regressorS0[[1]]))
  est <- res <- vector("list", length = length(regressorS0[[1]])) # k
  results0 <- vector("list", length = length(zSobj)) # jj
  for (jj in 1:length(zSobj)) {
    if (grepl("Class", agegroupings[jj])) next
    var.always.use = copy(variables.always.useCV)
    results0[[jj]] <- res
    z1 <- changehyphen(get(zSobj[jj]))
    # use only agHH0 (discard ocagHH, isagHH)
    z1[, grepout("\\wagHH", colnames(z1)) := NULL]
    # change agHH0 to agHH
    setnames(z1, grepout("HH", colnames(z1)), gsub("HH0", "HH", grepout("HH", colnames(z1))))
    z1[, village := factor(gsub(" ", "", village))]
    tabextend <- c("yes", "", "yes", "")
    tabcohortdemeaned <- c("", "yes", "", "yes")
    regressorS <- regressorS0[[1]]
    if (jj == 2 | jj == 5) 
      # AgeGroup: 6-10, 11-13, 14-15, 16-17, above17
      regressorS <- regressorS0[[2]] else 
    if (jj == 3 | jj == 6) 
      # Agegroup: 6-10, 11-17, above17
      regressorS <- regressorS0[[3]]
      # keep only cohorts defined by cohort.years
    if (cohort.years == 1999)
      z1[, grepout("DummyAge.*02", colnames(z1)) := NULL] else
      z1[, grepout("DummyAge.*99", colnames(z1)) := NULL]
    # For young cohorts, 6 <= age <= 10
    # For class wise, primary or secondary, drop DummyAge variables
    # For main (11 <= age <= 17, 18+), drop younger cohorts
    if (grepl("Young", agegroupings[jj])) {
      iiid <- unique(z1[6 <= AgeIn1999 & AgeIn1999 <= 10, uniquid])
      z1[, grepout("DummyAge.*\\.1[1-9]|DummyAge.*Above", colnames(z1)) := NULL]
      var.always.use <- gsub("\\^agHH.yr.", "DummyAgeIn1999.0..yr3$", var.always.use)
    } else if (grepl("Class", agegroupings[jj])) {
      iiid <- unique(z1[grepl("pri|sec", Edu1999), uniquid])
      z1[, grepout("DummyAge|Other", colnames(z1)) := NULL]
      # primary0103, primary0405, secondary0608, secondary0912
      var.always.use <- gsub("\\^agHH.yr.", "DummyEdu1999.*yr.$", var.always.use)
    } else {
      # target ages: minAge - maxAge in cohort.years
      iiid <- unique(z1[eval(parse(text = paste0("AgeIn", cohort.years))) >= minAge 
        & eval(parse(text = paste0("AgeIn", cohort.years))) <= maxAge, uniquid]) 
      # drop young cohort columns
      #z1[, grepout("DummyAge.*\\.0[6-9]|DummyAge.*\\.10", colnames(z1)) := NULL]
      # agewise: keep only minAge-maxAge and drop agHH.yrY, age.10.yrY (default age category)
      #              sub agHH.yrY with AgeInYYYY.*.yrY in var.always.use
      # AgeGroupX: Drop agHH.yrY, Age.10.*yrY
      if (grepl("agewise", agegroupings[jj])) 
          var.always.use <- gsub("\\^agHH.yr.", 
            paste0("^DummyAgeIn", cohort.years, ".*yr.$"), var.always.use) else 
      if (grepl("Group1", agegroupings[jj]))
          var.always.use <- gsub("\\^agHH.yr.", 
            paste0("^DummyAgeGroup", cohort.years, ".*yr.$"), var.always.use) else
      if (grepl("Group2", agegroupings[jj]))
          var.always.use <- gsub("\\^agHH.yr.", 
            paste0("^DummyAgegroup", cohort.years, ".*yr.$"), var.always.use)
      # Drop Above17 for AgeGroup1 and AgeGroup2 because of incidental nonsingularity
      # In principle, I can leave Above17*agHH*yr2 but it results in a singular matrix. 
      #z1[, grepout("DummyAge.*Above17", colnames(z1)) := NULL]
      var.always.use <- paste0(var.always.use, "|^agHH.yr.")
    }
    z2 <- z1[uniquid %in% iiid & survey != cutout.year, ]
    z2[, grepout("exist|^AgeIn|^..agHH|\\-\\d$", colnames(z2)) := NULL]
    # change yr2 => yr3 if placebo, yr3 => yr2 if main
     if (grepl("yr2", yrXs[ii])) 
      var.always.use <- gsub("yr3", "yr2", var.always.use) else
      var.always.use <- gsub("yr2", "yr3", var.always.use)
    # drop yrX other than yrx
    if (any(grepl(unique(yrXs[yrx != yrXs]), colnames(z2))))
      z2[, grepout(unique(yrXs[yrx != yrXs]), colnames(z2)) := NULL]
    # Do not drop agHH.yrY becase we use it as the regressor of reference category
    # In agewise, drop Age.06 - 08.yrY to set them as reference category
    # In AgeGroup1, 2, drop 0610.yr2 and 0610.agHH.yr2 age group so this becomes the default category.
    if (grepl("agewise", agegroupings[jj])) 
      z2[, grepout("06|07|08", colnames(z2)) := NULL] else 
    if (grepl("Grou", agegroupings[jj])) 
      z2[, grepout("0610", colnames(z2)) := NULL]
    z2 <- dropunbalanced(z2, returnDT = T)
    est <- vector("list", length = length(regressorS))
    aghhvar <- aghh.defs[1]
    ns <- NULL
    cat("\n\n")
    print0(zSobj[jj])
    cat("\n")
    # estimation loop for getting number of obs
    for (k in 1:length(regressorS))
    {
      regrsr <- paste(regressorS[1:k], sep = "", collapse = "|")
      covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), colnames(z2))
      print0(paste0("+ ", grepout(regressorS[k], colnames(z2))))
      zr <- z2[, covariates, with = F]
      rs <- DID1(data.frame(zr), regressand = regsnd[k], 
          clusterstring = clusterlevel, group = "^uniquid$", 
          intercept = T, PeriodToDropForLC = 2, 
         # opposite.time.order: set to F to keep regression data in tact 
         # (to be used in DID2 in the later chunk). Signs of estimates
         # are oppositte between DID1 and DID2.
          opposite.time.order = F,
          TurnFactorToNumeric = T, returnV = T, print.messages = F)
      if (k==length(regressorS)) 
        result <- list(level.data = rs$level, diff.data = rs$diff)
      est[[k]] <- round(rs$est[, -3], 5)
      if (Take19992002Diff) est[[k]][, 1] <- -1 * est[[k]][, 1]
      ns <- c(ns, rs$N)
    }
    zidd <- result$diff.data
    zid <- result$level.data
    if (grepl("Class", agegroupings[jj])) {
    # if class wise, summary of enrolled class in regression data
      classdata <- z2[, .(
        uniquid, survey, age, schoolp, Edu1999, 
        p0103=as.numeric(grepl("0103", Edu1999)), 
        p0405=as.numeric(DummyEdu1999.Primary0405>0), 
        s0608=as.numeric(DummyEdu1999.Secondary0608>0), 
        s0912=as.numeric(DummyEdu1999.Secondary0912>0))][
          survey==1999 & schoolp == 1, 
          .(uniquid, survey, age, schoolp, Edu1999, p0103, p0405, s0608, s0912, .N,
          class=factor(paste0(p0103, p0405, s0608, s0912)))]
      print("Classwise summary excluding nonenrollers in 1999 (schoolp = 0 is excluded)")
      print(summary(classdata))
    }
    TimeVariant <- grepout("program|age2|meanY|\\.yr\\d$", colnames(zidd))
    zidd[, (TimeVariant) := lapply(.SD, function(x) x * -1), .SDcols = TimeVariant]
    iiuq <- unique(zidd[, uniquid])
    zidd[, agHH := 0L]
    zidd[uniquid %in% zEm.1999[agHH0 > 0, uniquid], agHH := 1L]
   # zid[eval(parse(text=grepout("agHH$", colnames(zid)))) > 0, agHH := 1L]
    #zid[eval(parse(text=grepout("agHH$", colnames(zid)))) <= 0, agHH := 10L]
    # zt: data for computing enrollment rates
    # retain original baseline year obs
    zt <- z1[uniquid %in% iiuq & survey != cutout.year[1], ]
    # add agegroup or class group
    if (any(grepl("schoolp", colnames(zt)))) setnames(zt, "schoolp", "Enrolled")
    setkey(zt, uniquid)
    if (jj == 2 | jj == 5) {
      zt[, grepout("^Ageg", colnames(zt)) := NULL] 
      setnames(zt, grepout("^Age[gG]roup.*", colnames(zt)), "AgeGroup")
    } else 
    if (jj == 3 | jj == 6) {
      zt[, grepout("^AgeG", colnames(zt)) := NULL]
      setnames(zt, grepout("^Age[gG]roup.*", colnames(zt)), "AgeGroup")
    }
    # save mean enrollment rate changes
    zt[, aghh := 1L]
    zt[agHH <= 0, aghh := 0L]
    zt[, tee := 1]
    zt[survey == max(survey), tee := 2]
    enrr <- zt[, .(EnRate = round(mean(Enrolled), 3), Obs = .N), 
      by = .(aghh, tee)]
    if (jj == 1 | jj == 4) {
      Enrr <- zt[, .(EnRate = round(mean(Enrolled), 3), Obs = .N), 
        by = .(aghh, tee, Age)]
      setkey(Enrr, aghh, Age, tee)
      d1 <- zt[aghh == 1L, Enrolled]
      d0 <- zt[aghh == 0L, Enrolled]
      ttestE <- t.test(d1, d0)
      EnrCV.age <- rbind(EnrCV.age, 
        cbind(zSobj[jj], 
          if (ii != 4) rep(c("agewise", "AgeGrouping1", "AgeGrouping2"), 2)[jj] else "Classwise",
          Enrr)
        , use.names = T, fill = T)
      EnrCVchg.age <- rbind(EnrCVchg.age, 
        t(c(zSobj[jj], rep(c("agewise", "AgeGrouping1", "AgeGrouping2"), 2)[jj], "overall", 
          round(-diff(unlist(ttestE["estimate"])), 3),
          unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4))))
        , use.names = F)
    } else {
      zt[, AgeGroup := droplevels(AgeGroup)]
      for (ll in levels(zt[, AgeGroup])) {
        d1 <- zt[aghh == 1L & AgeGroup == ll, Enrolled]
        d0 <- zt[aghh == 0L & AgeGroup == ll, Enrolled]
        ttestE <- t.test(d1, d0)
      # enrollment rates by (agHH)*(age/agegroup)*(period)
        EnrCV.age <- rbind(EnrCV.age, 
          cbind(zSobj[jj], 
          if (ii != 4) rep(c("agewise", "AgeGrouping1", "AgeGrouping2"), 2)[jj] else "Classwise",
          #rep(c("agewise", "AgeGrouping1", "AgeGrouping2"), 2)[jj],
            zt[, .(EnRate = round(mean(Enrolled), 3), Obs = .N), 
            by = .(aghh, AgeGroup, tee)])
        , use.names = T, fill = T)
        EnrCVchg.age <- rbind(EnrCVchg.age, 
          c(zSobj[jj], rep(c("agewise", "AgeGrouping1", "AgeGrouping2"), 2)[jj], ll, 
            round(-diff(unlist(ttestE["estimate"])), 3),
            unlist(lapply(ttestE[c("estimate", "conf.int", "p.value")], round, 4)))
         )
      }
    } # end: if not mainC
    if (any(grepl("LHS", colnames(zidd)))) setnames(zidd, "LHS", "Enrolled")
    Rs <- ns <- NULL
    est <- vector("list", length(regressorS))
    for (k in 1:length(regressorS))
    {
      # DID2 use first-differenced data (zidd from DID1 with opposite.time.order = F) 
      # zidd took t - (t-1) difference, so schoolp is usually 0 or -1 (1 in 1999, 0 in 2002).
      # In our estimation, we take (t-1) - t difference.
      regrsr <- paste(regressorS[1:k], sep = "", collapse = "|")
      covariates <- grepout(paste(var.always.use, regrsr, sep = "|"), colnames(zidd))
      zr <- zidd[, covariates, with = F]
      zr[, tee := 1]
      rsl <- DID2(zr, Regressand = "Enrolled", 
              Group = "^uniquid$", TimeVar = "tee", Cluster = "village", 
              TimeVariant = "program|age2|meanY|yield",
              opposite.time.order = F, 
              Exclude = "^agHH$", 
              intercept = T, return.V = T, print.messages = T)
      results0[[jj]][[k]] <- 
        list(est = rsl$est, df = rsl$reg$df, level.data = rsl$level, diff.data = rsl$diff)
      est[[k]] <- round(rsl$est[, -3], 5)
      Rs <- c(Rs, summary(rsl$nonrobust)$adj.r)
      ns <- c(ns, rsl$N)
    }
    assign(paste0("addthis", jj),
      rbind("\\hspace{.5em}thana dummies" = 
        paste0("\\mbox{", c(rep("", length(regressorS)-1), rep("yes", 1)), "}"),
        "$\\bar{R}^{2}$" = gsub("^0", "", formatC(Rs, digits = 4, format = "f")),
        "n" = ns,
        "control mean at baseline" = 
            rep(formatC(enrr[tee == 1 & aghh == 0, EnRate], 
              digits = 2, format = "f"), length(regressorS)),
        "treated mean at baseline" =
            rep(formatC(enrr[tee == 1 & aghh == 1, EnRate], 
              digits = 2, format = "f"), length(regressorS))
      ))
    #tbest <- tabulate.est(est, reorder, output.in.list = T,
    #  lastLevelVariable = "^r.*Y$|^l.*Y", inter.with = cohort.years[1],
    #  addbottom = get(paste0("addthis", j)), subst.table = sbt)
    tbest <- tabulate.est(est, reorder, output.in.list = T,
      LastLineVariables = c("^r.*Y$|^l.*Y", "latrine.yr.$"),
      InterWithTexts = paste0(yrxYear, c("", "*agricultural household")),
      addbottom = get(paste0("addthis", jj)), subst.table = sbt)
    tbl <- saveEstTable(tbest[[2]], tbest[[1]], boxWidth, 
      estimationspacelast = grep("thana dummi", tbest[[1]]),
      hleft = "\\hfil\\scriptsize$", hright = "$", 
      hcenter = c(boxWidth, rep(centerWidth, ncol(tbest[[2]]))), 
      delimiterline = NULL, adjustlineskip = "-0.5ex", 
      alternatecolor2 = "gray80")
    # Modify "interaction with ..." lines to use multicolumn
    InterRows <- grep("nteract.*\\d", tbl)
    for (ir in InterRows) {
      if (any(grepl("rowcolor", tbl[ir])))
        tbl[ir] <- 
          # \makbox[]{inter with A} &&&& \\[-1ex] => \multicolumn{5}{l}{\makebox[]{inter with A}} \\[-1ex]
          # rows with rowcolor command at the end
          paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
            gsub("(\\\\\\\\.*ex.*?rowcolor.*?)$", "}\\1", gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir])))
            ) else
          # rows without rowcolor command at the end
          paste0("\\multicolumn{", ncol(tbest[[2]]), "}{l}{", 
            gsub("(\\\\\\\\.*ex.$)", "}\\1", gsub("\\\\hfill", "", gsub("\\&", "", tbl[ir])))
            )
    }
    pathtosavedtable <- paste0(pathsaveThisVer, "FD_", 
        samples.age[ii], c(rep("_", 3), "", "")[ii], agegroupings[jj], "_ClusterVillage_", zSobj[jj], ".tex")
    write.tablev(tbl, pathtosavedtable, colnamestrue = F, rownamestrue = F, nastrings = "") 
    cat("Table saved as", pathtosavedtable, "\n")
  }  # jj
  results[[ii]] <- results0
}  # ii
saveRDS(results, paste0(pathsaveThisVer, "FD_agewise_ClusterVillage_results.rds"))
EnrCV.age <- data.table(EnrCV.age)
EnrCVchg.age <- data.table(EnrCVchg.age)
setnames(EnrCVchg.age, c("sample", "AgeGrouping", "ages", 
  "AgNonag", "agHH", "nonagHH", "lb95", "ub95", "pvalue"))
setnames(EnrCV.age, c("sample", "AgeGrouping", "agHH", "survey", "Age", "rate", "Obs", "AgeGroup"))
EnrCV.age[, AgeGroup := as.character(AgeGroup)]
EnrCV.age[is.na(AgeGroup), AgeGroup := Age]
EnrCV.age[, AgeGroup := factor(AgeGroup)]
EnrCV.age[, Age := NULL]
EnrCV.age <- unique(EnrCV.age)
EnrCV.age[, sample := factor(sample)]
EnrCV.age[, AgeGrouping := factor(AgeGrouping)]
clusterlevel <- "thana"
@

